<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>知识 on Weiming Hu</title><link>https://huweim.github.io/categories/%E7%9F%A5%E8%AF%86/</link><description>Recent content in 知识 on Weiming Hu</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 05 Jan 2025 07:45:52 +0000</lastBuildDate><atom:link href="https://huweim.github.io/categories/%E7%9F%A5%E8%AF%86/index.xml" rel="self" type="application/rss+xml"/><item><title>关于 Deep Work</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_deep_work/</link><pubDate>Sun, 08 May 2022 20:56:54 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_deep_work/</guid><description>&lt;h2 id="01-知乎">0.1 知乎&lt;/h2>
&lt;p>知乎一位作者写的自我观察非常好，在我需要去完成论文的那段时间，我也是进入了这样一种状态。这个任务必须去交付（DDL 4.14），而且需要交互（修改之后给娄老师，并且完成娄老师交代的改动），是一种紧张，紧凑的任务，但是不觉得效率很高，写初稿反而磕磕盼盼，但是事后来看，在一段比较短的时间内（4.4-4.13）产出了一篇有结构的初稿并且慢慢完善并投稿。而现在，你需要记住、重拾这种状态，并把他融入到你的日常工作中。&lt;/p></description></item><item><title>CSAPP阅读笔记</title><link>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>最近刚把 adaptive 调度的一部分工作写成了文章，在 SOCC DDL（4.14） 投了出去。这段时间希望浏览一下 CSAPP，一方面是复习体系结构中的一些知识，另一方面再构建一下对整个计算机结构，操作系统，C语言的了解和认识。&lt;/p></description></item><item><title>LeetCode刷题记录</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 16 Mar 2022 08:59:50 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>&lt;h4 id="关键字检索">关键字检索&lt;/h4>
&lt;ul>
&lt;li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。&lt;/li>
&lt;li>知识点：题目所涉及到的大概知识点。&lt;/li>
&lt;li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针&lt;/li>
&lt;li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。&lt;/li>
&lt;/ul>
&lt;h4 id="短板总结">短板总结&lt;/h4>
&lt;ul>
&lt;li>短板：二叉树，矩阵，DFS，BFS&lt;/li>
&lt;/ul>
&lt;p>2022-04-15 17:28:42，BFS，DFS，二叉树 稍微熟练了一些；目前的短板&lt;/p></description></item><item><title>Software Design of GPGPU-Sim</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</link><pubDate>Sun, 14 Nov 2021 20:35:44 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</guid><description>&lt;p>4 Software Design of GPGPU-Sim&lt;/p>
&lt;p>所有标题都可以升一级，整个文档全是 manual 的第 4 章&lt;/p>
&lt;h1 id="1-file-list-and-brief-description">1. File list and brief description&lt;/h1>
&lt;ul>
&lt;li>cuda-sim - The functional simulator that executes PTX kernels generated by NVCC or OpenCL compiler&lt;/li>
&lt;li>gpgpu-sim - The performance simulator that simulates the timing behavior of a GPU (or other many core accelerator architectures)&lt;/li>
&lt;li>intersim - The interconnection network simulator adopted from Bill Dally&amp;rsquo;s BookSim&lt;/li>
&lt;/ul>
&lt;h2 id="11-overallutilities">1.1 Overall/Utilities&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>abstract_hardware_model.h abstract_hardware_model.cc&lt;/th>
 &lt;th>Provide a set of classes that interface between functional and timing simulator.&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>shader.h &lt;!-- raw HTML omitted -->shader.cc&lt;/td>
 &lt;td>SIMT core timing model. It calls cudu-sim for functional simulation of a particular thread and cuda-sim would return with performance-sensitive information for the thread.&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>visualizer.h &lt;!-- raw HTML omitted -->visualizer.cc&lt;/td>
 &lt;td>Output dynamic statistics for the visualizer&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="13-gpgpu-sim">1.3 gpgpu-sim&lt;/h2>
&lt;p>几个需要注意的列出来，gluing 时钟频率，注意有单独的 gpu-cache.cc 和 l2cache.cc&lt;/p></description></item><item><title>GPU_benchmark说明（转）</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</link><pubDate>Sun, 14 Nov 2021 20:34:48 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>本文内容主要系摘录翻译自&lt;a href="http://parse.ele.tue.nl/ali">Ang Li&lt;/a>的博士毕业论文。&lt;/p>
&lt;h1 id="1perfect">1.Perfect&lt;/h1>
&lt;p>Power Efficiency Revolution for Embedded Computing&lt;/p>
&lt;p>&lt;a href="http://hpc.pnl.gov/PERFECT/">http://hpc.pnl.gov/PERFECT/&lt;/a>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">&lt;strong>Application Domains&lt;/strong>&lt;/th>
 &lt;th style="text-align: left">&lt;strong>Kernels&lt;/strong>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">PERFECT Application 1&lt;/td>
 &lt;td style="text-align: left">Discrete Wavelet Transform&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">2D Convolution&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Histogram Equalization&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Space Time Adaptive Processing&lt;/td>
 &lt;td style="text-align: left">System Solver&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Inner Product&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Outer Product&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Synthetic Aperture Radar&lt;/td>
 &lt;td style="text-align: left">Interpolation 1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Interpolation 2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Back Projection (Non-Fourier SAR)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Wide Area Motion Imaging&lt;/td>
 &lt;td style="text-align: left">Debayer&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Image Registration&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Change Detection&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Required Kernels&lt;/td>
 &lt;td style="text-align: left">Sort&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">FFT 1D&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">FFT 2D&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="2-axbench">2. AxBench&lt;/h1>
&lt;p>A Multiplatform Benchmark Suite for Approximate Computing&lt;/p></description></item><item><title>文档_GPGPU-sim - Performance Simulation Engine</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_gpgpu-sim---performance-simulation-engine/</link><pubDate>Tue, 28 Sep 2021 14:59:35 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_gpgpu-sim---performance-simulation-engine/</guid><description>&lt;p>GPGPU-sim - Performance Simulation Engine&lt;/p>
&lt;h1 id="1-performance-model-software-objects">1 Performance Model Software Objects&lt;/h1>
&lt;div class="highlight-container">

 &lt;button class="copy-code-btn outline">Copy&lt;/button>

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>ldst_unit &lt;span style="color:#f92672">*&lt;/span>m_ldst_unit;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>前面的 m 可能表示这个类型的变量&lt;/p>
&lt;h2 id="12-simt-core-class">1.2 SIMT Core Class&lt;/h2>
&lt;p>SIMT Core 中的微架构在 shader.h/cc 的类 shader_core_ctx 中实现&lt;/p>
&lt;ul>
&lt;li>shd_warp_t objects 的集合用于建模每个 warp 在 core 中的状态&lt;/li>
&lt;li>simt_stack object, 处理每个 warp 的分支&lt;/li>
&lt;li>set of scheduler_unit obj, 选择 set 中 warp 的一条 or 多条指令发射执行&lt;/li>
&lt;li>Scoreboard obj 处理 data hazard&lt;/li>
&lt;li>opndcoll_rfu_t obj, model operand collector&lt;/li>
&lt;li>set of &lt;code>simd_function_unit&lt;/code> obj 实现 ALU pipeline&lt;/li>
&lt;li>&lt;code>ldst_unit&lt;/code> 实现 memory pipeline&lt;/li>
&lt;li>&lt;code>shader_memroy_interface&lt;/code> 将 SIMT Core 连接到相应的 SIMT Core Cluster&lt;/li>
&lt;/ul>
&lt;p>每个 core cycle, 调用 &lt;code>shader_core_ctx::cycle()&lt;/code> 来模拟 SIMT Core 的一个 cycle。cycle function 以按从下往上的顺序 (也就是从 writeback() 到 fetch()) 调用下列函数&lt;/p></description></item><item><title>SIMT_Core</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_simt_core/</link><pubDate>Sat, 04 Sep 2021 19:04:57 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_simt_core/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>搞懂 SIMT Core 对于理解 GPGPU 的指令 fetch、指令发射、内存访问、数据传输等步骤非常重要，按照 GPGPU-Sim 的官方文档进行一个简单的梳理&lt;/p>
&lt;p>SIMT Core 的微架构模型中有几个比较重要的硬件单元，接下来会一一介绍他们的作用，&lt;/p></description></item><item><title>Ca2_lab2</title><link>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab2/</link><pubDate>Wed, 28 Jul 2021 18:23:41 +0800</pubDate><guid>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab2/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。&lt;/p></description></item><item><title>Ca2_lab1</title><link>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab1/</link><pubDate>Wed, 28 Jul 2021 16:09:45 +0800</pubDate><guid>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab1/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。&lt;/p></description></item><item><title>Ca2_lab0</title><link>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab0/</link><pubDate>Wed, 28 Jul 2021 15:23:39 +0800</pubDate><guid>https://huweim.github.io/post/%E8%AF%BE%E7%A8%8B_ca2_lab0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。&lt;/p></description></item><item><title>GPGPU_Architecture</title><link>https://huweim.github.io/post/%E6%95%99%E6%9D%90_gpgpu_architecture/</link><pubDate>Sat, 24 Jul 2021 16:35:27 +0800</pubDate><guid>https://huweim.github.io/post/%E6%95%99%E6%9D%90_gpgpu_architecture/</guid><description>&lt;h1 id="gpgpu-architecture">GPGPU Architecture&lt;/h1>
&lt;p>从有缩进的那一段开始成为第一段&lt;/p>
&lt;h1 id="1-introduction">1. Introduction&lt;/h1>
&lt;h2 id="11-the-landspace-of-computation-accelerators">1.1 The Landspace Of Computation Accelerators&lt;/h2>
&lt;p>1 提升性能不能光依赖于摩尔定律了，需要从 Computer Arch 中去寻找提升&lt;/p>
&lt;p>2 GPU 的性能优势, vector HW&lt;/p>
&lt;p>3 专用的硬件对应用的性能提升帮助很大，如谷歌 TPU&lt;/p></description></item></channel></rss>