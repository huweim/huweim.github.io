<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>工具 on Cory Code</title><link>https://huweim.github.io/categories/%E5%B7%A5%E5%85%B7/</link><description>Recent content in 工具 on Cory Code</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Athul</copyright><lastBuildDate>Wed, 16 Mar 2022 08:56:32 +0800</lastBuildDate><atom:link href="https://huweim.github.io/categories/%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml"/><item><title>tmux: Linux 下终端复用</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</link><pubDate>Wed, 16 Mar 2022 08:56:32 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</guid><description>0. 前言 个人理解：最重要的思想感觉是将 session 和终端分离，这样的话退出终端时不会中断 session 以及里面的任务，session 还是在后台运行。最重要的是，下次进入终端时可以连接 session，使得可以还原上一次退出时的状态，且后台任务不会中断。
前缀键：Ctrl + B，用&amp;lt;prefix&amp;gt;表示。比如&amp;lt;prefix&amp;gt; %表示先按Ctrl，再按B键，再%键，其完成的功能就是竖直分屏。
0.1 安装、启动、退出 $ sudo apt-get install tmux $ tmux #进入 Tmux 窗口，底部状态栏左侧是窗口信息（编号和名称），右侧是系统信息 $exit #或者 ctrl + d，退出 1. 基本概念 1.1 Session 会话(session): 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话
Session 一大特点：打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也随之结束
基于这个 Motivation，为了解决这种关闭窗口工作丢失的问题，会话和窗口可以解绑。窗口关闭时，会话并不会终止，而是继续运行，有需要的时候（理解为需要交互的时候）再让会话绑定其他窗口。
窗口(window): 容纳多个窗格
窗格(pane): 可以在窗口中分成多个窗格
1.2 Tmux Tmux 就是让会话与窗口解绑的工具
可以在单个窗口中同时访问多个会话。对于同时运行多个命令行程序很有用 可以让新窗口 接入 已存在的会话 允许每个会话有多个连接窗口，可以多人实时共享会话 支持窗口任意的垂直和水平拆分 1. Session 1.1 new 第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</description></item><item><title>Vim 中常用的操作</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Wed, 16 Mar 2022 08:54:13 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>Vim 中常用的操作
复制、删除中，定位的逻辑都是对应的，找最后一行 G，找第一行 1G，找行首 0，找行尾 $
复制/粘贴 复制当前行之后的内容，yG
复制第一行到当前行，y1G
复制当前行，dd；向下复制 10 行，10dd
复制游标到行首/行尾，y0/y$
粘贴在光标下/上一行，p/P
删除 删除当前行之后的内容
光标定位到某行，:,$d，dG 删除第一行到当前行
1,.d，d1G 删除当前行，dd；向下删除 10 行，10dd
向后/向前删除 10 个字符，10x/10X
删除游标到行首/行尾，d0/d$
恢复上一个动作（类似 Ctrl + Z）,u
重做上一个动作（往前恢复），ctrl + r
重复上一个动作（再做一次），.
跳转/移动 跳转到指定第x行，:x
跳转到文件最后一行，shift + g、G、:$
跳转到文件第一行，gg
跳转到下一页，ctrl + f (forward)
跳转到上一页，ctrl + b (back)
向下移动 30 行，30j，30 &amp;lt;Enter&amp;gt;
向右移动 20 个字符，20 &amp;lt;space&amp;gt;，为空格
:star: 移动到当前行首/尾，0 or [home]/$ or [End]
搜索 查找 /</description></item><item><title>Python处理输出log信息并绘图</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</link><pubDate>Wed, 08 Dec 2021 09:05:41 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</guid><description>0. 前言 修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。
需要两个绘图工具
对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等 对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等 1. 正则表达式 1.1 实例 def read_string(file,metrics): output={} for it_metrics in metrics: if(it_metrics==&amp;#34;gpu_ipc&amp;#34;): pattern=re.compile(it_metrics+&amp;#34; =(\s+)(\d+\.\d+)&amp;#34;) elif(it_metrics==&amp;#34;Stall&amp;#34;): pattern=re.compile(it_metrics+&amp;#34;:(\d+)&amp;#34;) else: pattern=re.compile(it_metrics+&amp;#34; = (\d+)&amp;#34;) output_sum=0 for i,line in enumerate(open(get_file_path()+file)): for match in re.finditer(pattern, line): if(it_metrics==&amp;#34;gpu_ipc&amp;#34;): output_part=list(match.group(2)) else: output_part=list(match.group(1)) output_part=float(&amp;#39;&amp;#39;.join(output_part)) output_sum+=output_part output[it_metrics]=output_sum return output 其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。
for i,line in enumerate(open(file)) 遍历 log 的每一行，一定要加上 i 否则会报错。</description></item><item><title>Linux任务调度</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 29 Nov 2021 23:00:09 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid><description>0. 前言 记录一下 Linux 中 fg、bg、jobs、&amp;amp;、ctrl + z 等相关指令对任务进程的操作。
也正好借此机会学习一下进程（process）的概念
1. Process 1.0 进程类型 前台进程（交互式进程） 这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能/服务的一部分自动启动。 后台进程 1.1 并发执行 To run commands concurrently you can use the &amp;amp; command separator
~$ command1 &amp;amp; command2 &amp;amp; command3 This will start command1, then runs it in the background. The same with command2. Then it starts command3 normally.
这样的话 command3 是在前台运行
The output of all commands will be garbled together, but if that is not a problem for you, that would be the solution.</description></item><item><title>Docker 常用的命令</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 17 Sep 2021 16:25:25 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。
1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的用法 $ sudo systemctl start docker 2. Image文件 **Docker 把应用程序及其依赖，打包在 image 文件里面。**只有通过这个文件，才能生成 Docker 容器。 image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
# 列出本机的所有 image 文件。 $ docker image ls $ docler images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest fb52e22af1b0 2 weeks ago 72.8MB hello-world latest d1165f221234 6 months ago 13.3kB ubuntu 15.</description></item><item><title>Git中常用的操作</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Mon, 08 Mar 2021 19:12:40 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_git%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>Git中常用的操作 1. Remote Repo 1.1 Add Remote Repo $ git remote add origin git@github.com:huweim/repo_name.git 1.2 Delete Remote Repo Add a wrong remote repo, we could delete it. $ git remote -v origin git@github.com:huweim/huweim.github.io.git (fetch) origin git@github.com:huweim/huweim.github.io.git (push) Delete it $ git remote rm origin 1.3 Pull Origin Master to Local :x:似乎 push 之前如果有东西需要先 pull
是因为远端已经创建了 README.md，local 也有README.md。有冲突，所以需要先 pull 过来同步。 git pull 命令用于从远程获取代码并合并本地的版本。
git pull 其实就是 git fetch 和 git merge FETCH_HEAD 的简写。 命令格式如下：</description></item></channel></rss>