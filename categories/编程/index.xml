<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on Cory Code</title><link>https://huweim.github.io/categories/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on Cory Code</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>© Athul</copyright><lastBuildDate>Wed, 08 Dec 2021 09:05:41 +0800</lastBuildDate><atom:link href="https://huweim.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Python处理输出log信息并绘图</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</link><pubDate>Wed, 08 Dec 2021 09:05:41 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</guid><description>0. 前言 修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。
需要两个绘图工具
对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等 对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等 1. 正则表达式 1.1 实例 def read_string(file,metrics): output={} for it_metrics in metrics: if(it_metrics==&amp;#34;gpu_ipc&amp;#34;): pattern=re.compile(it_metrics+&amp;#34; =(\s+)(\d+\.\d+)&amp;#34;) elif(it_metrics==&amp;#34;Stall&amp;#34;): pattern=re.compile(it_metrics+&amp;#34;:(\d+)&amp;#34;) else: pattern=re.compile(it_metrics+&amp;#34; = (\d+)&amp;#34;) output_sum=0 for i,line in enumerate(open(get_file_path()+file)): for match in re.finditer(pattern, line): if(it_metrics==&amp;#34;gpu_ipc&amp;#34;): output_part=list(match.group(2)) else: output_part=list(match.group(1)) output_part=float(&amp;#39;&amp;#39;.join(output_part)) output_sum+=output_part output[it_metrics]=output_sum return output 其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。
for i,line in enumerate(open(file)) 遍历 log 的每一行，一定要加上 i 否则会报错。</description></item><item><title>Ubuntu多版本CUDA,GCC切换</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_ubuntu%E5%A4%9A%E7%89%88%E6%9C%ACcudagcc%E5%88%87%E6%8D%A2/</link><pubDate>Sun, 14 Nov 2021 22:07:35 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_ubuntu%E5%A4%9A%E7%89%88%E6%9C%ACcudagcc%E5%88%87%E6%8D%A2/</guid><description>Ubuntu多版本CUDA,GCC切换 切换CUDA9.0和CUDA10.0 保证多个CUDA版本共存的前提是NVIDIA的驱动都能够支持你所安装的CUDA版本，所以驱动的版本尽可能高，越新的驱动支持的CUDA版本越多，博主的430能够支持9.0和10.0。
在先前安装的CUDA的过程中，大家一般都会选择生成cuda-x.0文件夹的软链接/usr/local/cuda，这个文件夹是实际安装的cuda-x.0文件夹的链接，不包含实际文件，是方便系统设置环境变量直接调用cuda的，安装多个版本的CUDA，然后利用软链接就可以实现版本切换。
理解这个软链接，用到了很多次 Step 1 更换软链接 不过之前环境变量用的 cuda11.1 的地址而非软链接，现在替换成软链接
sudo rm -rf /usr/local/cuda #删除之前生成的软链接 sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda #生成新的软链接 sudo ln -s /usr/local/cuda-11.1 /usr/local/cuda #使用11.1版本 2 Check 环境变量的地址 export CUDA_INSTALL_PATH=/usr/local/cuda/ export PATH=$PATH:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$CUDA_INSTALL_PATH/bin:$MPI_ROOT/bin export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$CUDA_INSTALL_PATH/lib64 #这个不用改 export NVIDIA_COMPUTE_SDK_LOCATION=~/cuda/sdk/4.2 3 查看版本信息 上述步骤全部没问题就可以弹出版本信息了，source ~/.bashrc 或者重启终端
nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2012 NVIDIA Corporation Built on Thu_Apr__5_00:24:31_PDT_2012 Cuda compilation tools, release 4.2, V0.2.1221 4. Bug 4.1 sh: 1: nvopencc: Permission denied 解决方法</description></item><item><title>Docker Image and Container</title><link>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Fri, 17 Sep 2021 16:25:25 +0800</pubDate><guid>https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。
1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的用法 $ sudo systemctl start docker 2. Image文件 **Docker 把应用程序及其依赖，打包在 image 文件里面。**只有通过这个文件，才能生成 Docker 容器。 image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。
# 列出本机的所有 image 文件。 $ docker image ls $ docler images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu latest fb52e22af1b0 2 weeks ago 72.8MB hello-world latest d1165f221234 6 months ago 13.3kB ubuntu 15.</description></item></channel></rss>