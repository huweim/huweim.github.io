<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage data-theme=light><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Makefile学习和实践 - Weiming Hu
</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=color-scheme content="light dark"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=generator content="Hugo 0.140.2"><link rel=canonical href=https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_makefile%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E8%B7%B5/><meta name=author content="Cory"><meta name=description content="1. 简介和基础知识 C语言中文网 http://c.biancheng.net/view/7096.html
1.1 Makefile文件是什么？ 1.1.1 Definition Makefile是什么？
用于描述编译规则的工程文件 即哪些文件先编译，哪些文件无需编译 使得项目的编译自动化，不需要每次都手动输入一堆源文件和参数。 可以理解为一个脚本语言，类似 Shell, Perl, Python Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，无需手写
"><meta name=keywords content="makefile"><meta property="og:url" content="https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_makefile%E5%AD%A6%E4%B9%A0%E5%92%8C%E5%AE%9E%E8%B7%B5/"><meta property="og:site_name" content="Weiming Hu"><meta property="og:title" content="Makefile学习和实践"><meta property="og:description" content="1. 简介和基础知识 C语言中文网 http://c.biancheng.net/view/7096.html
1.1 Makefile文件是什么？ 1.1.1 Definition Makefile是什么？
用于描述编译规则的工程文件 即哪些文件先编译，哪些文件无需编译 使得项目的编译自动化，不需要每次都手动输入一堆源文件和参数。 可以理解为一个脚本语言，类似 Shell, Perl, Python Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，无需手写"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-03-23T11:00:42+08:00"><meta property="article:modified_time" content="2023-03-23T11:00:42+08:00"><meta property="article:tag" content="Makefile"><meta itemprop=name content="Makefile学习和实践"><meta itemprop=description content="1. 简介和基础知识 C语言中文网 http://c.biancheng.net/view/7096.html
1.1 Makefile文件是什么？ 1.1.1 Definition Makefile是什么？
用于描述编译规则的工程文件 即哪些文件先编译，哪些文件无需编译 使得项目的编译自动化，不需要每次都手动输入一堆源文件和参数。 可以理解为一个脚本语言，类似 Shell, Perl, Python Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，无需手写"><meta itemprop=datePublished content="2023-03-23T11:00:42+08:00"><meta itemprop=dateModified content="2023-03-23T11:00:42+08:00"><meta itemprop=wordCount content="6638"><meta itemprop=keywords content="Makefile"><meta name=twitter:card content="summary"><meta name=twitter:title content="Makefile学习和实践"><meta name=twitter:description content="1. 简介和基础知识 C语言中文网 http://c.biancheng.net/view/7096.html
1.1 Makefile文件是什么？ 1.1.1 Definition Makefile是什么？
用于描述编译规则的工程文件 即哪些文件先编译，哪些文件无需编译 使得项目的编译自动化，不需要每次都手动输入一堆源文件和参数。 可以理解为一个脚本语言，类似 Shell, Perl, Python Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，无需手写"><link rel=icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.1acfe3c0bf85aa6c451ba764236bb3ab12c22cd38eee8ecc8fac33defcc7156d.css integrity="sha256-Gs/jwL+FqmxFG6dkI2uzqxLCLNOO7o7Mj6wz3vzHFW0=" media=screen crossorigin=anonymous><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script>(function(){var e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script></head><body><div id=back-to-top></div><header class=site-header><div class=desktop-header><div class=desktop-header-logo><a href=/ class=logo>Weiming Hu</a></div><nav class=desktop-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li><li class=menu-item><a class="theme-toggle menu-item-link" href=javascript:void(0);><svg aria-hidden="true" class="lucide lucide-sun hi-svg-inline theme-icon-light" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg><svg aria-hidden="true" class="lucide lucide-moon hi-svg-inline theme-icon-dark" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline icon--rss" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav></div><div class=mobile-header><div id=mobile-navbar class=mobile-navbar><div id=mobile-navbar-icon class=mobile-navbar-icon><svg aria-hidden="true" class="lucide lucide-menu hi-svg-inline icon--menu" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div><div class=mobile-navbar-logo><a href=/ class=logo>Weiming Hu</a></div></div><div id=mobile-menu-close-modal class=mobile-menu-close-modal></div><nav id=mobile-menu class=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li><li class=mobile-menu-item><a class="theme-toggle menu-item-link" href=javascript:void(0);><svg aria-hidden="true" class="lucide lucide-sun hi-svg-inline theme-icon-light" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg><svg aria-hidden="true" class="lucide lucide-moon hi-svg-inline theme-icon-dark" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline icon--rss" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav></div></header><main id=main class="main pico container"><div class=content-wrapper><aside class=sidebar></aside><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Makefile学习和实践</h1><div class=post-meta-list><div class="post-meta-item post-meta-author"><svg aria-hidden="true" class="lucide lucide-user-round-pen hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M2 21a8 8 0 0110.821-7.487"/><path d="M21.378 16.626a1 1 0 00-3.004-3.004l-4.01 4.012a2 2 0 00-.506.854l-.837 2.87a.5.5.0 00.62.62l2.87-.837a2 2 0 00.854-.506z"/><circle cx="10" cy="8" r="5"/></svg>
Cory</div><div class="post-meta-item post-meta-time"><svg aria-hidden="true" class="lucide lucide-calendar-days hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M8 2v4"/><path d="M16 2v4"/><rect width="18" height="18" x="3" y="4" rx="2"/><path d="M3 10h18"/><path d="M8 14h.01"/><path d="M12 14h.01"/><path d="M16 14h.01"/><path d="M8 18h.01"/><path d="M12 18h.01"/><path d="M16 18h.01"/></svg>
<time datetime=2023-03-23>2023-03-23</time></div><div class=post-meta__right><span class=post-meta-more>6638 words -
14 min read</span><div class="post-meta-item post-meta-category"><a href=https://huweim.github.io/categories/%E7%BC%96%E7%A8%8B/>编程</a></div></div></div></header><div class=post-content><h1 id=1-简介和基础知识>1. 简介和基础知识</h1><p>C语言中文网 <a href=http://c.biancheng.net/view/7096.html>http://c.biancheng.net/view/7096.html</a></p><h2 id=11-makefile文件是什么>1.1 Makefile文件是什么？</h2><h3 id=111-definition>1.1.1 Definition</h3><p>Makefile是什么？</p><ul><li>用于描述编译规则的工程文件<ul><li>即哪些文件先编译，哪些文件无需编译</li><li>使得项目的编译自动化，不需要每次都手动输入一堆源文件和参数。</li><li>可以理解为一个脚本语言，类似 Shell, Perl, Python</li></ul></li></ul><p>Windows 下的集成开发环境（IDE）已经内置了 Makefile，或者说会自动生成 Makefile，无需手写</p><p>对于 Linux，不懂 Makefile，就操作不了多文件编程，就完成不了相对于大的工程项目的操作。如果你想在 Linux(Unix) 环境下做开发的话，Makefile 是必须掌握的一项技能。</p><h3 id=112-case>1.1.2 Case</h3><p>比如多文件编译生成一个文件</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>gcc -o outfile name1.c name2.c ...</span></span></code></pre></div></div><p>文件数量多了，就会有问题</p><h3 id=113-链接库>1.1.3 链接库</h3><ul><li>C语言，编译的时候 gcc 只会默认链接一些基本的C语言标准库，很多源文件依赖的标准库都需要我们手动链接。</li><li>name1.c 用到了数学计算库 math 中的函数，我们得手动添加参数 -Im；</li><li>name5.c 使用到了线程，我们需要去手动添加参数 -lpthread。<ul><li>这个情况在写 CUDA 的时候就遇到了</li></ul></li><li>可以把要链接的库文件放在 Makefile 中，制定相应的规则和对应的链接顺序。这样只需要执行 make 命令，工程就会自动编译。</li></ul><p>编译大的工程会花费很长的时间</p><ul><li>Makefile 支持多线程并发操作，会极大的缩短我们的编译时间，</li></ul><blockquote><p>具体操作应该是 <code>make -j8</code>，使用八个线程</p></blockquote><ul><li>并且当我们修改了源文件之后，编译整个工程的时候，make 命令只会编译我们修改过的文件，没有修改的文件不用重新编译，也极大的解决了我们耗费时间的问题。</li></ul><h2 id=12-makefile-文件结构>1.2 Makefile 文件结构</h2><h3 id=121-目标依赖-targetprerequisite>1.2.1 目标，依赖 target，prerequisite</h3><p>它的规则主要是两个部分组成，分别是依赖的关系和执行的命令，其结构如下所示：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>targets </span><span style=color:#f92672>:</span> prerequisites
</span></span><span style=display:flex><span>    command
</span></span></code></pre></div></div><p>or</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>targets </span><span style=color:#f92672>:</span> prerequisites; command
</span></span><span style=display:flex><span>    command
</span></span></code></pre></div></div><ul><li>targets：规则的目标，可以是 Object File（一般称它为中间文件），也可以是可执行文件，还可以是一个标签；<ul><li>也就是 command 的输出</li></ul></li><li>prerequisites：是我们的依赖文件，要生成 targets 需要的文件或者是目标。可以是<strong>多个</strong>，也可以是没有<ul><li>a &ldquo;prerequisite&rdquo; is a file or target that must exist before a particular target can be built；</li><li>构造 target 的前置条件</li></ul></li><li>command：make 需要执行的命令（任意的 shell 命令）。可以有多条命令，每一条命令占一行。</li><li>recipe：a series of commands that are executed to create or update a target</li></ul><p>&#x2757; Notion：我们的目标和依赖文件之间要使用冒号分隔开，命令的开始一定要使用<code>Tab</code>键。</p><ul><li>使用了空格就会报错</li><li><code>Makefile:2: *** 缺失分隔符。 停止。</code></li></ul><blockquote><p>2022-11-25 19:55:02。这个特点和 shell 文件类似，空格的标准是一开始很容易出错而意识不到的地方</p></blockquote><h4 id=1211-case>1.2.1.1 Case</h4><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>main </span><span style=color:#f92672>:</span> main.c fun1.c fun2.c
</span></span><span style=display:flex><span>	gcc -o main main.c fun1.c fun2.c
</span></span></code></pre></div></div><p>实际情况中一行规则是肯定不够用的</p><h2 id=13-变量>1.3 变量</h2><h3 id=131-变量定义>1.3.1 变量定义</h3><p>基本语法&#x2757;</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>变量的名称 <span style=color:#f92672>=</span> 值列表
</span></span></code></pre></div></div><p>变量的名称可以由大小写字母、阿拉伯数字和下划线构成。</p><p>&#x2757;等号左右的空白符没有明确的要求，因为在执行 make 的时候多余的空白符会被自动的删除。</p><blockquote><p>2022-11-25 19:54:29。shell 赋值的话，在 <code>=</code> 两边不能留有空白。</p></blockquote><ul><li>这一点很重要，因为 gcc 之前是必须用 <code>Tab</code>，而变量赋值无需</li></ul><p>至于值列表，既可以是零项，又可以是一项或者是多项。
调用变量的时候可以用 &ldquo;$(VALUE_LIST)&rdquo; 或者是 &ldquo;${VALUE_LIST}&rdquo; 来替换，这就是变量的引用</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>OBJ<span style=color:#f92672>=</span>main.o test.o test1.o test2.o
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span><span style=color:#f92672>:</span><span style=color:#66d9ef>$(</span>OBJ<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>      gcc -o test <span style=color:#66d9ef>$(</span>OBJ<span style=color:#66d9ef>)</span>
</span></span></code></pre></div></div><h3 id=132-变量的基本赋值>1.3.2 变量的基本赋值</h3><ul><li>简单赋值 ( := ) 编程语言中常规理解的赋值方式，只对当前语句的变量有效。</li><li>递归赋值 ( = ) 赋值语句可能影响多个变量，所有目标变量相关的其他变量都受影响。</li><li>条件赋值 ( ?= ) 如果变量未定义，则使用符号中的值定义变量。如果该变量已经赋值，则该赋值语句无效。</li><li>追加赋值 ( += ) 原变量用空格隔开的方式追加一个新值。</li></ul><p>详细说明如下：</p><h4 id=1321-简单赋值->1.3.2.1 简单赋值 :=</h4><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>x<span style=color:#f92672>:=</span>foo
</span></span><span style=display:flex><span>y<span style=color:#f92672>:=</span><span style=color:#66d9ef>$(</span>x<span style=color:#66d9ef>)</span>b
</span></span><span style=display:flex><span>x<span style=color:#f92672>:=</span>new
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>test：</span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;y=&gt;$(y)&#34;</span>
</span></span><span style=display:flex><span>      <span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;x=&gt;$(x)&#34;</span></span></span></code></pre></div></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>y<span style=color:#f92672>=</span>&gt;foob
</span></span><span style=display:flex><span>x<span style=color:#f92672>=</span>&gt;new</span></span></code></pre></div></div><h4 id=1322-递归赋值->1.3.2.2 递归赋值 =</h4><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>x<span style=color:#f92672>=</span>foo
</span></span><span style=display:flex><span>y<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>x<span style=color:#66d9ef>)</span>b
</span></span><span style=display:flex><span>x<span style=color:#f92672>=</span>new
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>test：</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;y=&gt;$(y)&#34;</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;x=&gt;$(x)&#34;</span></span></span></code></pre></div></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>y<span style=color:#f92672>=</span>&gt;newb	<span style=color:#75715e>#理解为当某变量 x 更新后，所以和 x 相关的变量都会更新</span>
</span></span><span style=display:flex><span>x<span style=color:#f92672>=</span>&gt;new</span></span></code></pre></div></div><h4 id=1323-条件赋值->1.3.2.3 条件赋值 ?=</h4><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>x<span style=color:#f92672>:=</span>foo
</span></span><span style=display:flex><span>y<span style=color:#f92672>:=</span><span style=color:#66d9ef>$(</span>x<span style=color:#66d9ef>)</span>b
</span></span><span style=display:flex><span>x<span style=color:#f92672>?=</span>new
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>test：</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;y=&gt;$(y)&#34;</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;x=&gt;$(x)&#34;</span></span></span></code></pre></div></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>y<span style=color:#f92672>=</span>&gt;foob
</span></span><span style=display:flex><span>x<span style=color:#f92672>=</span>&gt;foo <span style=color:#75715e># x 已经定位为 foo 所以忽略掉 new 的赋值</span></span></span></code></pre></div></div><h4 id=1324-追加赋值->1.3.2.4 追加赋值 +=</h4><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>x<span style=color:#f92672>:=</span>foo
</span></span><span style=display:flex><span>y<span style=color:#f92672>:=</span><span style=color:#66d9ef>$(</span>x<span style=color:#66d9ef>)</span>b
</span></span><span style=display:flex><span>x<span style=color:#f92672>+=</span><span style=color:#66d9ef>$(</span>y<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>test：</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;y=&gt;$(y)&#34;</span>      
</span></span><span style=display:flex><span>	<span style=color:#960050;background-color:#1e0010>@echo</span> <span style=color:#e6db74>&#34;x=&gt;$(x)&#34;</span></span></span></code></pre></div></div><p>在 shell 命令行执行<code>make test</code>我们会看到:</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>y<span style=color:#f92672>=</span>&gt;foob
</span></span><span style=display:flex><span>x<span style=color:#f92672>=</span>&gt;foo foob <span style=color:#75715e>#为什么有空格？</span></span></span></code></pre></div></div><h3 id=133-通配符>1.3.3 通配符</h3><p>回想一下数据库的知识</p><table><thead><tr><th>通配符</th><th>使用说明</th><th>自动变量</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>匹配0个或者是任意个字符</td><td>$&lt;</td><td>第一个依赖文件</td></tr><tr><td>？</td><td>匹配任意一个字符 # 注意是 1 个</td><td>$@</td><td>目标</td></tr><tr><td>[]</td><td>我们可以指定匹配的字符放在 &ldquo;[]&rdquo; 中</td><td>$^</td><td>所有不重复的依赖文件，以空格分开</td></tr></tbody></table><h4 id=1331-case-1>1.3.3.1 Case 1</h4><p>测试可用 &#x2b07;&#xfe0f;</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>test</span><span style=color:#f92672>:</span>*.c	gcc -o $@ $^</span></span></code></pre></div></div><p>这个实例可以说明我们的通配符不仅可以使用在规则的命令中，还可以使用在规则中。用来表示生所有的以 .c 结尾的文件。</p><ul><li>表示所有以 .c 结尾的文件同时编译，生成 test 文件</li></ul><h4 id=1332-case-2>1.3.3.2 Case 2</h4><p>&#9888;&#xfe0f; 讲述变量和通配符不要混用</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>OBJ<span style=color:#f92672>=</span>*.c
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span><span style=color:#f92672>:</span><span style=color:#66d9ef>$(</span>OBJ<span style=color:#66d9ef>)</span>    
</span></span><span style=display:flex><span>	gcc -o $@ $^
</span></span></code></pre></div></div><p>&#x2b50;我们去执行这个命令的时候会出现错误，提示我们没有 &ldquo;*.c&rdquo; 文件，实例中我们相要表示的是当前目录下所有的 &ldquo;.c&rdquo; 文件，但是我们在使用的时候并没有展开，而是直接识别成了一个文件。文件名是 &ldquo;*.c&rdquo;。</p><p>&#x1f17f;&#xfe0f; 不过自己测试的时候可以成功编译，这可能是 makefile 自己做了优化</p><h3 id=134-wildcard-函数>1.3.4 wildcard 函数</h3><p>如果我们就是相要通过引用变量的话，我们要使用一个函数 &ldquo;wildcard&rdquo;，这个函数在我们引用变量的时候，会帮我们展开。我们把上面的代码修改一下就可以使用了。</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>OBJ<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>wildcard *.c<span style=color:#66d9ef>)</span>test:<span style=color:#66d9ef>$(</span>OBJ<span style=color:#66d9ef>)</span>    gcc -o $@ $^
</span></span></code></pre></div></div><p>这样我们再去使用的时候就可以了。调用函数的时候，会帮我们自动展开函数。</p><p>还有一个和通配符 &ldquo;*&rdquo; 相类似的字符，这个字符是 &ldquo;%"，也是匹配任意个字符，使用在我们的的规则当中。</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>test</span><span style=color:#f92672>:</span>test.o test1.o    gcc -o $@ $^%.o:%.c    gcc -o $@ $^</span></span></code></pre></div></div><p>&ldquo;%.o&rdquo; 把我们需要的所有的 &ldquo;.o&rdquo; 文件组合成为一个列表，从列表中挨个取出的每一个文件，&rdquo;%" 表示取出来文件的文件名（不包含后缀），然后找到文件中和 &ldquo;%&ldquo;名称相同的 &ldquo;.c&rdquo; 文件，然后执行下面的命令，直到列表中的文件全部被取出来为止。</p><h2 id=14-简单实例>1.4 简单实例</h2><p>来自知乎 <a href=https://www.zhihu.com/question/23792247/answer/600773044>https://www.zhihu.com/question/23792247/answer/600773044</a></p><h3 id=141-第一版>1.4.1 第一版</h3><p>测试过，可以 work</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>main </span><span style=color:#f92672>:</span> main.c fun1.c fun2.c	gcc -o main main.c fun1.c fun2.c</span></span></code></pre></div></div><p>&#x2757; 缺点</p><ul><li>对于简单代码还好，而对于大型项目，具有成千上万代码来说，仅用一行规则是完全不够的，即使够的话也需要写很长的一条规则</li><li>任何文件只要稍微做了修改就需要整个项目完整的重要编译<ul><li>Which means 有办法在修改一部分时只编译那一小部分</li></ul></li></ul><p>2023-03-23 10:28:52，自己的理解：这样写的话，所有的 .c 文件都是 <code>main</code> 的依赖，那么任意改其中一个 .c 文件，<code>main</code> 都需要重新编译，src code 之间的独立性不强。</p><h3 id=142-第二版>1.4.2 第二版</h3><p>为了避免改动任何代码就需要重新编译整个项目的问题，我们将主规则的各个依赖替换成各自的中间文件
即main.c &ndash;> main.o，fun1.c &ndash;> fun1.o，fun2.c &ndash;> fun2.o，再对每个中间文件的生成分别写一条规则
比如对于main.o，规则为：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>main.o</span><span style=color:#f92672>:</span> main.c      
</span></span><span style=display:flex><span>  gcc -c main.c -o main.o  
</span></span></code></pre></div></div><p>这样做的好处是，当有一个文件发生改动时，只需重新编译此文件即可，而无需重新编译整个项目。完整Makefile如下：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>app </span><span style=color:#f92672>:</span> main.o fun1.o fun2.o  	
</span></span><span style=display:flex><span>  gcc main.o fun1.o fun2.o -o app  
</span></span><span style=display:flex><span><span style=color:#a6e22e>main.o </span><span style=color:#f92672>:</span> main.c  	
</span></span><span style=display:flex><span>  gcc -c main.c -o main.o  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fun1.o </span><span style=color:#f92672>:</span> fun1.c  	
</span></span><span style=display:flex><span>  gcc -c fun1.c -o fun1.o  
</span></span><span style=display:flex><span><span style=color:#a6e22e>fun2.o </span><span style=color:#f92672>:</span> fun2.c  	
</span></span><span style=display:flex><span>  gcc -c fun2.c -o fun2.o
</span></span></code></pre></div></div><p>&#9888;&#xfe0f; 注意不要加多余的空格，(gcc) 命令的开始一定要使用<code>Tab</code>键，不能是空格</p><p>&#x2757; 缺点</p><ul><li>里面存在一些重复的内容，可以考虑用变量代替；</li><li>后面三条规则非常类似，可以考虑用一条模式规则代替。<ul><li>说白了也就是有重复</li></ul></li></ul><p>2023-03-23 10:31:39，但是这里的重复只是写法上的重复，而 <code>app</code> 对 src code 的依赖关系已经独立开来，能够提升重新编译的效率。</p><h3 id=143-第三版>1.4.3 第三版</h3><p>引入了变量的概念</p><p>在第三版Makefile中，我们使用变量及模式规则使Makefile更加简洁。使用的三个变量如下：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>obj <span style=color:#f92672>=</span> main.o fun1.o fun2.o  
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> app  
</span></span><span style=display:flex><span>CC <span style=color:#f92672>=</span> gcc  
</span></span></code></pre></div></div><p>使用的模式规则为：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>%.o</span><span style=color:#f92672>:</span> %.c  	
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> -c $&lt; -o $@ 
</span></span></code></pre></div></div><p>Means -> 所有的.o文件都由对应的.c文件生成。在规则里，我们又看到了两个自动变量：<code>$&lt;</code> 和 <code>$@</code>。
其实自动变量有很多，常用的有三个：</p><ul><li><code>$&lt;</code>：第一个依赖文件；</li><li><code>$@</code>：目标；</li><li><code>$^</code>：所有不重复的依赖文件，以空格分开</li></ul><p>直接复制过来的源码是有问题的，需要手动调整一下 Tab。&#x2b07;&#xfe0f; 是可以使用的。</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>obj <span style=color:#f92672>=</span> main.o fun1.o fun2.o  
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> app  
</span></span><span style=display:flex><span>CC <span style=color:#f92672>=</span> gcc  
</span></span><span style=display:flex><span><span style=color:#a6e22e>$(target)</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span>  	
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span> -o <span style=color:#66d9ef>$(</span>target<span style=color:#66d9ef>)</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>%.o</span><span style=color:#f92672>:</span> %.c  	
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> -c $&lt; -o $@     <span style=color:#75715e>#这个 百分号% 就类似于数据库中的匹配 所有以 .o 结尾的是 target 以 .c 结尾的是 prerequisites</span>
</span></span></code></pre></div></div><p>&#x2757; 缺点</p><ul><li>obj对应的文件需要一个个输入，工作量大；</li><li>文件数目比较少时还好，文件数目一旦很多的话，obj将很长；</li><li>而且每增加/删除一个文件，都需要修改Makefile。</li></ul><p>2023-03-23 10:35:37，这里的意思应该是要事先准备好所有需要的 .o 文件，而 .o 文件需要从 .c 文件编译得到。其中仍然是存在将所有 .c 编译成对应的 .o 文件的过程，不够自动化。</p><h3 id=144-第四版>1.4.4 第四版</h3><p>在第四版Makefile中，推出了两个函数：<strong>wildcard</strong> 和 <strong>patsubst</strong>。</p><h4 id=1441-wildcard>1.4.4.1 wildcard</h4><p>作用：扩展通配符，搜索指定文件。在此我们使用</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>src <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>wildcard ./*.c<span style=color:#66d9ef>)</span>，#代表在当前目录下搜索所有的.c文件，并赋值给src。函数执行结束后，src的值为：main.c fun1.c fun2.c。
</span></span></code></pre></div></div><h4 id=1442-patsubst>1.4.4.2 patsubst</h4><p>作用：替换通配符，按指定规则做替换。在此我们使用</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>patsubst %.c, %.o, <span style=color:#66d9ef>$(</span>src<span style=color:#66d9ef>))</span>
</span></span></code></pre></div></div><p>代表将src里的每个文件都由.c替换成.o。函数执行结束后，<code>obj</code> 的值为 <code>main.o fun1.o fun2.o</code>，其实跟第三版 Makefile 的 obj 值一模一样，只不过在这里它更智能一些，也更灵活。</p><p>除了使用 <code>patsubst</code> 函数外，我们也可以使用模式规则达到同样的效果，比如：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>src:%.c<span style=color:#f92672>=</span>%.o<span style=color:#66d9ef>)</span>
</span></span></code></pre></div></div><p>也是代表将src里的每个文件都由.c替换成.o。</p><p>几乎每个 Makefile 里都会有一个 <strong>伪目标</strong> clean，这样我们通过执行make clean命令就是将中间文件如 .o 文件及目标文件全部删除，留下干净的空间。一般是如下写法：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> clean  clean:  	rm -rf <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>target<span style=color:#66d9ef>)</span>  </span></span></code></pre></div></div><p>.PHONY代表声明clean是一个 <strong>伪目标</strong>，这样每次执行 <code>make clean</code> 时，下面的规则都会被执行。</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span>src <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>wildcard ./*.c<span style=color:#66d9ef>)</span>  
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>patsubst %.c, %.o, <span style=color:#66d9ef>$(</span>src<span style=color:#66d9ef>))</span>  
</span></span><span style=display:flex><span>obj <span style=color:#f92672>=</span> <span style=color:#66d9ef>$(</span>src:%.c<span style=color:#f92672>=</span>%.o<span style=color:#66d9ef>)</span>  
</span></span><span style=display:flex><span>target <span style=color:#f92672>=</span> app  
</span></span><span style=display:flex><span>CC <span style=color:#f92672>=</span> gcc  
</span></span><span style=display:flex><span><span style=color:#a6e22e>$(target)</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span> -o <span style=color:#66d9ef>$(</span>target<span style=color:#66d9ef>)</span>  
</span></span><span style=display:flex><span><span style=color:#a6e22e>%.o</span><span style=color:#f92672>:</span> %.c
</span></span><span style=display:flex><span>  	<span style=color:#66d9ef>$(</span>CC<span style=color:#66d9ef>)</span> -c $&lt; -o $@  
</span></span><span style=display:flex><span><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> clean  
</span></span><span style=display:flex><span><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    rm -rf <span style=color:#66d9ef>$(</span>obj<span style=color:#66d9ef>)</span> <span style=color:#66d9ef>$(</span>target<span style=color:#66d9ef>)</span>
</span></span></code></pre></div></div><h1 id=2-常用的编译选项-cli-option>2. 常用的编译选项 CLI option</h1><p>给出几个自己用到过的选项</p><h2 id=21--n-打印所有编译命令但并不执行>2.1 -n 打印所有编译命令，但并不执行</h2><p><code>make -n mlp_learning_an_image</code></p><h2 id=22--s--f>2.2 -s -f</h2><p><code>-s</code>：禁止输出编译命令信息 -s。
<code>-f</code>：用于指定 makefile 文件的名称或路径。它告诉 make 命令使用指定的 makefile 文件而不是默认的 Makefile 文件来执行编译。</p><p>下面的代码中，Makefile 文件是 <code>build.make</code>，因为 <code>make</code> 命令默认是找目录下的名为 <code>Makefile</code> 文件。这里的 Makefile 并非默认的名称，因此需要用 <code>-f</code> 选项来指定文件。而 <code>make</code> target 是 <code>dependencies/fmt/CMakeFiles/fmt.dir/build</code></p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>make</span> <span style=color:#960050;background-color:#1e0010>-s</span> <span style=color:#960050;background-color:#1e0010>-f</span> <span style=color:#960050;background-color:#1e0010>dependencies/fmt/CMakeFiles/fmt.dir/build.make</span> <span style=color:#960050;background-color:#1e0010>dependencies/fmt/CMakeFiles/fmt.dir/build</span></span></span></code></pre></div></div><h1 id=3-变量-variable>3. 变量 variable</h1><h1 id=4-条件语句和函数-conditional-syntax-and-functions>4. 条件语句和函数 conditional syntax and functions</h1><h1 id=5-关键字-built-in-targets>5. 关键字 built-in targets</h1><h2 id=51-phony>5.1 .PHONY</h2><blockquote><p>In a Makefile, .PHONY is a special target that is used to declare a target that doesn&rsquo;t represent an actual file. Instead, it is used to specify a target that is always considered out of date, and therefore, its recipe will always be executed whenever it is requested.</p></blockquote><p>也就是说在对于 .PHONY 关键字后面的内容，只要有请求，就会执行。还是很绕，直接看例子吧。使用 .PHONY 声明了 CMakeFiles/tiny-cuda-nn.dir/depend，也就是说只要输入命令 <code>make CMakeFiles/tiny-cuda-nn.dir/depend</code>，就会执行其命令行，不管有哪种依赖</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#a6e22e>CMakeFiles/tiny-cuda-nn.dir/depend</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>	cd /home/wmhu/work/tiny-cuda-nn/build <span style=color:#f92672>&amp;&amp;</span> <span style=color:#66d9ef>$(</span>CMAKE_COMMAND<span style=color:#66d9ef>)</span> -E cmake_depends <span style=color:#e6db74>&#34;Unix Makefiles&#34;</span> /home/wmhu/work/tiny-cuda-nn /home/wmhu/work/tiny-cuda-nn /home/wmhu/work/tiny-cuda-nn/build /home/wmhu/work/tiny-cuda-nn/build /home/wmhu/work/tiny-cuda-nn/build/CMakeFiles/tiny-cuda-nn.dir/DependInfo.cmake --color<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>COLOR<span style=color:#66d9ef>)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>.PHONY </span><span style=color:#f92672>:</span> CMakeFiles/tiny-cuda-nn.dir/depend</span></span></code></pre></div></div><p>再来一个例子，关于 clean。声明之后，不管 .o 文件和 bin 文件是不是存在，只要 <code>make clean</code>，就会执行 <code>rm -f *.o myprogram</code></p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=display:flex><span><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> clean
</span></span><span style=display:flex><span><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    rm -f *.o myprogram
</span></span></code></pre></div></div><h2 id=52-default>5.2 .DEFAULT</h2><h1 id=6-应用技巧>6. 应用技巧</h1><p>这一章描述一些实践过程中的技巧，可以参考 chatgpt 给的大纲，查缺补漏，细细完善。</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Makefile 基础知识
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>什么是 Makefile
</span></span><span style=display:flex><span>Makefile 的工作原理
</span></span><span style=display:flex><span>Makefile 的基本语法
</span></span><span style=display:flex><span>Makefile 中的变量
</span></span><span style=display:flex><span>Makefile 中的目标和依赖关系
</span></span><span style=display:flex><span>Makefile 的常用命令
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>make 命令
</span></span><span style=display:flex><span>clean 命令
</span></span><span style=display:flex><span>distclean 命令
</span></span><span style=display:flex><span>install 命令
</span></span><span style=display:flex><span>uninstall 命令
</span></span><span style=display:flex><span>Makefile 的高级应用
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Makefile 中的条件语句
</span></span><span style=display:flex><span>Makefile 中的函数
</span></span><span style=display:flex><span>Makefile 中的自动化变量
</span></span><span style=display:flex><span>Makefile 中的模式规则
</span></span><span style=display:flex><span>Makefile 中的多目标规则
</span></span><span style=display:flex><span>实际问题和解决方案
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>如何在 Makefile 中设置编译器和编译选项
</span></span><span style=display:flex><span>如何在 Makefile 中编译和链接多个源文件
</span></span><span style=display:flex><span>如何在 Makefile 中编译和链接静态库和动态库
</span></span><span style=display:flex><span>如何在 Makefile 中定义和使用宏定义
</span></span><span style=display:flex><span>如何在 Makefile 中使用条件编译
</span></span><span style=display:flex><span>Makefile 的调试技巧
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>如何使用 Makefile 的调试选项
</span></span><span style=display:flex><span>如何输出 Makefile 中的变量和宏定义
</span></span><span style=display:flex><span>如何查看 Makefile 中的依赖关系
</span></span><span style=display:flex><span>如何查看 Makefile 中的编译和链接命令
</span></span><span style=display:flex><span>Makefile 的最佳实践
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>如何编写可移植的 Makefile
</span></span><span style=display:flex><span>如何编写可维护的 Makefile
</span></span><span style=display:flex><span>如何编写高效的 Makefile
</span></span><span style=display:flex><span>如何组织 Makefile 的目录结构
</span></span><span style=display:flex><span>以上是一些可以作为 Makefile 笔记的主题和子主题，你可以根据自己的需要进行扩充和调整。在整理笔记的过程中，你可以结合自己的实际学习和应用情况，将理论知识和实践问题结合起来，这样能够使笔记更加丰富和实用。</span></span></code></pre></div></div><h1 id=7-通过实例学习>7. 通过实例学习</h1><h2 id=71-cutlass-实例>7.1 cutlass 实例</h2><h3 id=712-make-中的选项>7.1.2 make 中的选项</h3><p><code>make -s -f CMakeFiles/Makefile2 samples/CMakeFiles/mlp_learning_an_image.dir/all</code></p><p>这一句命令表示使用 CMakeFiles/Makefile2 文件中定义的规则来编译 samples/CMakeFiles/mlp_learning_an_image.dir/all 目标。-s 选项指示 make 命令在执行编译过程时不显示编译命令。</p><p>all 是一个伪目标，指示 make 命令编译所有的目标。在这个上下文中，samples/CMakeFiles/mlp_learning_an_image.dir/all 是一个特殊的目标，它实际上是由 CMake 自动生成的一个中间目标。它的作用是将 samples/CMakeFiles/mlp_learning_an_image.dir 目录中所有的源文件编译成目标文件，并将它们链接为一个可执行文件。</p><p>在 Makefile 中，通常会定义一个名为 all 的伪目标，用于编译所有的目标。all 目标通常是默认目标，也就是在不指定目标的情况下，make 命令将会编译它。当然，开发者也可以定义其他的伪目标来执行指定的编译任务。</p><p>什么是伪目标？</p><p>实际目标指的是编译生成的文件或其他需要执行的任务。
伪目标则是指用来控制 Makefile 中规则执行顺序的目标，不生成对应的文件。</p><p>伪目标的作用是在执行 make 命令时，告诉 make 命令要执行哪些规则。它通常用来控制 Makefile 中规则的执行顺序，或者执行一些特定的任务，如清除生成的文件等。</p><p>在 Makefile 中，伪目标的特征是没有对应的文件名，并且在规则中使用了 .PHONY 声明，以告诉 make 命令它是一个伪目标。例如：</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=display:flex><span><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> clean
</span></span><span style=display:flex><span><span style=color:#a6e22e>clean</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    rm -f *.o
</span></span></code></pre></div></div><p>在上面的例子中，clean 是一个伪目标，它的作用是删除当前目录下的所有 .o 文件。.PHONY 声明告诉 make 命令 clean 是一个伪目标，不对应任何文件，只是一个控制规则执行顺序的目标。</p><p>需要注意的是，如果不使用 .PHONY 声明声明一个伪目标，那么当在当前目录下存在一个与目标同名的文件时，make 命令会将其误认为是实际目标，导致错误的行为。因此，定义伪目标时一定要加上 .PHONY 声明。</p><hr><h1 id=0-cmake-和-makefile-异同>0. Cmake 和 Makefile 异同</h1><p>这一章参考 <a href=https://www.zhihu.com/question/27455963/answer/36722992>知乎文章</a></p><h2 id=01-功能描述>0.1 功能描述</h2><ul><li><code>make</code> command 是用来执行 Makefile 的</li><li>Makefile 是类 UNIX 环境下(比如Linux)的类似于批处理的"脚本"文件。
其基本语法是: <strong>目标+依赖+命令</strong>，只有在<strong>目标</strong>文件不存在，或<strong>目标</strong>比<strong>依赖</strong>的文件更旧，<strong>命令</strong>才会被执行。由此可见，Makefile和make可适用于任意工作，不限于编程。比如，可以用来管理latex。</li></ul><blockquote><p>2022-11-25 19:47:20，从这个描述来看，猜测判断 <strong>目标</strong> 是否 <code>Already Update..</code> 的依据是系统时间。判断 <strong>目标</strong> 的修改时间是否晚于 <strong>依赖</strong> 文件的修改时间。</p></blockquote><ul><li><p>Makefile+make可理解为类unix环境下的项目管理工具，但它太基础了，抽象程度不高，而且在windows下不太友好(针对visual studio用户)，于是就有了跨平台项目管理工具cmake</p></li><li><p>cmake是跨平台项目管理工具，它用更抽象的语法来组织项目。虽然，仍然是目标，依赖之类的东西，但更为抽象和友好，比如你可用math表示数学库，而不需要再具体指定到底是math.dll还是libmath.so，在windows下它会支持生成visual studio的工程，在linux下它会生成Makefile，甚至它还能生成eclipse工程文件。也就是说，从同一个抽象规则出发，它为各个编译器定制工程文件。</p></li><li><p>cmake是抽象层次更高的项目管理工具，cmake命令执行的CMakeLists.txt文件</p></li><li><p>cmake 抽象程度更高</p></li><li><p>qmake是Qt专用的项目管理工具，对应的工程文件是*.pro，在Linux下面它也会生成Makefile，当然，在命令行下才会需要手动执行qmake，完全可以在qtcreator这个专用的IDE下面打开*.pro文件，使用qmake命令的繁琐细节不用你管了。</p></li></ul><p><strong>总结</strong></p><p>总结一下，make用来执行Makefile，cmake用来执行CMakeLists.txt，qmake用来处理*.pro工程文件。Makefile的抽象层次最低，cmake和qmake在Linux等环境下最后还是会生成一个Makefile。cmake和qmake支持跨平台，cmake的做法是生成指定编译器的工程文件，而qmake完全自成体系。</p><h2 id=02-个人理解>0.2 个人理解</h2><ul><li>&#x2b50; ​具体使用时，Linux下，小工程可手动写Makefile，<ul><li>所以学会自己手写 Makefile 对于一些测试工作也是比较重要的</li></ul></li><li>大工程用automake来帮你生成Makefile，</li><li>要想跨平台，就用cmake。</li><li>如果GUI用了Qt，也可以用qmake+*.pro来管理工程，这也是跨平台的。当然，cmake中也有针对Qt的一些规则，并代替qmake帮你将qt相关的命令整理好了。</li></ul><p>另外，需要指出的是，make和cmake主要命令只有一条，make用于处理Makefile，cmake用来转译CMakeLists.txt，而qmake是一个体系，用于支撑一个编程环境，它还包含除qmake之外的其它多条命令(比如uic，rcc,moc)。</p><p>上个简图，其中cl表示visual studio的编译器，gcc表示linux下的编译器</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Cory</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2023-03-23</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://huweim.github.io/tags/makefile/>makefile</a></div><nav class=post-nav><a class=next href=/post/%E7%BC%96%E7%A8%8B_%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E9%83%A8%E7%BD%B2transformer%E6%A8%A1%E5%9E%8B_huggingface/><span class="next-text nav-default">自己动手部署transformer模型 by huggingface</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg aria-hidden="true" class="lucide lucide-chevron-right hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="m9 18 6-6-6-6"/></svg></i></a></nav></footer></article></div><nav class=toc id=toc><div class=toc-title>Table of Contents</div><div class="toc-content custom-scrollbar"><nav id=TableOfContents><ul><li><a href=#1-简介和基础知识>1. 简介和基础知识</a><ul><li><a href=#11-makefile文件是什么>1.1 Makefile文件是什么？</a><ul><li><a href=#111-definition>1.1.1 Definition</a></li><li><a href=#112-case>1.1.2 Case</a></li><li><a href=#113-链接库>1.1.3 链接库</a></li></ul></li><li><a href=#12-makefile-文件结构>1.2 Makefile 文件结构</a><ul><li><a href=#121-目标依赖-targetprerequisite>1.2.1 目标，依赖 target，prerequisite</a><ul><li><a href=#1211-case>1.2.1.1 Case</a></li></ul></li></ul></li><li><a href=#13-变量>1.3 变量</a><ul><li><a href=#131-变量定义>1.3.1 变量定义</a></li><li><a href=#132-变量的基本赋值>1.3.2 变量的基本赋值</a><ul><li><a href=#1321-简单赋值->1.3.2.1 简单赋值 :=</a></li><li><a href=#1322-递归赋值->1.3.2.2 递归赋值 =</a></li><li><a href=#1323-条件赋值->1.3.2.3 条件赋值 ?=</a></li><li><a href=#1324-追加赋值->1.3.2.4 追加赋值 +=</a></li></ul></li><li><a href=#133-通配符>1.3.3 通配符</a><ul><li><a href=#1331-case-1>1.3.3.1 Case 1</a></li><li><a href=#1332-case-2>1.3.3.2 Case 2</a></li></ul></li><li><a href=#134-wildcard-函数>1.3.4 wildcard 函数</a></li></ul></li><li><a href=#14-简单实例>1.4 简单实例</a><ul><li><a href=#141-第一版>1.4.1 第一版</a></li><li><a href=#142-第二版>1.4.2 第二版</a></li><li><a href=#143-第三版>1.4.3 第三版</a></li><li><a href=#144-第四版>1.4.4 第四版</a><ul><li><a href=#1441-wildcard>1.4.4.1 wildcard</a></li><li><a href=#1442-patsubst>1.4.4.2 patsubst</a></li></ul></li></ul></li></ul></li><li><a href=#2-常用的编译选项-cli-option>2. 常用的编译选项 CLI option</a><ul><li><a href=#21--n-打印所有编译命令但并不执行>2.1 -n 打印所有编译命令，但并不执行</a></li><li><a href=#22--s--f>2.2 -s -f</a></li></ul></li><li><a href=#3-变量-variable>3. 变量 variable</a></li><li><a href=#4-条件语句和函数-conditional-syntax-and-functions>4. 条件语句和函数 conditional syntax and functions</a></li><li><a href=#5-关键字-built-in-targets>5. 关键字 built-in targets</a><ul><li><a href=#51-phony>5.1 .PHONY</a></li><li><a href=#52-default>5.2 .DEFAULT</a></li></ul></li><li><a href=#6-应用技巧>6. 应用技巧</a></li><li><a href=#7-通过实例学习>7. 通过实例学习</a><ul><li><a href=#71-cutlass-实例>7.1 cutlass 实例</a><ul><li><a href=#712-make-中的选项>7.1.2 make 中的选项</a></li></ul></li></ul></li><li><a href=#0-cmake-和-makefile-异同>0. Cmake 和 Makefile 异同</a><ul><li><a href=#01-功能描述>0.1 功能描述</a></li><li><a href=#02-个人理解>0.2 个人理解</a></li></ul></li></ul></nav></div></nav></div></main><footer id=footer class=site-footer><div class=social-icon-links><a href=mailto:huwm1@shanghaitech.edu.cn rel="me noopener" class=social-icon-link title=email><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1451 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a><a href=http://localhost:1313 rel="me noopener" class=social-icon-link title=linkedin target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M872.405333 872.618667H720.768V635.008c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333.0-91.136 61.653333-91.136 125.397334v241.792H398.976V384H544.64v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667.0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667.0 01-88.021333-88.106666A88.064 88.064.0 11227.712 317.141333zm76.032 555.477334H151.68V384h152.064v488.618667zM948.266667.0h-872.704C33.792.0.0 33.024.0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667.0 948.138667.0h.128z"/></svg>
</a><a href=https://github.com/huweim rel="me noopener" class=social-icon-link title=github target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg>
</a><a href=https://www.zhihu.com/people/hu-wei-ming-31-86 rel="me noopener" class=social-icon-link title=zhihu target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg>
</a><a href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=social-icon-link title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span><span class=copyright-year>&copy;
2020 -
2025
<span class=heart><i class=iconfont><svg aria-hidden="true" class="lucide lucide-heart hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5.0 0016.5 3c-1.76.0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5.0 002 8.5c0 2.3 1.5 4.05 3 5.5l7 7z"/></svg>
</i></span><span class=author>Weiming Hu</span></span></div></footer><script type=text/javascript src=/js/main.eb94e793601239645bc98e36c443aef1b210646ccb43e2217ea949a0212e0ed1.js integrity="sha256-65Tnk2ASOWRbyY42xEOu8bIQZGzLQ+IhfqlJoCEuDtE=" crossorigin=anonymous></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>