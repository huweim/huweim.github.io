<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Docker 常用的命令 - Cory Code</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Cory"><meta name=description content="0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。 1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.109.0"><link rel=canonical href=https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.fa4b2b9f31b5c6d0b683db81157a9226e17b06e61911791ab547242a4a0556f2.css integrity="sha256-+ksrnzG1xtC2g9uBFXqSJuF7BuYZEXkatUckKkoFVvI=" media=screen crossorigin=anonymous><meta property="og:title" content="Docker 常用的命令"><meta property="og:description" content="0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。 1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的"><meta property="og:type" content="article"><meta property="og:url" content="https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_docker%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-09-17T16:25:25+08:00"><meta property="article:modified_time" content="2022-11-26T16:20:58+00:00"><meta itemprop=name content="Docker 常用的命令"><meta itemprop=description content="0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。 1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的"><meta itemprop=datePublished content="2021-09-17T16:25:25+08:00"><meta itemprop=dateModified content="2022-11-26T16:20:58+00:00"><meta itemprop=wordCount content="5010"><meta itemprop=keywords content="Docker,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Docker 常用的命令"><meta name=twitter:description content="0. 前言 最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。 1. 启动Docker服务 # service 命令的用法 $ sudo service docker start # systemctl 命令的"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Cory Code</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>Cory Code</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>Docker 常用的命令</h1><div class=post-meta><time datetime=2021-09-17 class=post-time>2021-09-17</time><div class=post-category><a href=https://huweim.github.io/categories/%E5%B7%A5%E5%85%B7/>工具</a></div><span class=more-meta>5010 words</span>
<span class=more-meta>10 min read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Table of Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#21-本地-image-管理>2.1 本地 image 管理</a></li><li><a href=#22-查找image>2.2 查找Image</a></li><li><a href=#23-pull镜像>2.3 pull镜像</a></li><li><a href=#24-运行镜像>2.4 运行镜像</a></li><li><a href=#25-创建镜像>2.5 创建镜像</a><ul><li><a href=#251-更新镜像>2.5.1 更新镜像</a></li><li><a href=#252-构建镜像>2.5.2 构建镜像</a></li><li><a href=#253-设置镜像标签>2.5.3 设置镜像标签</a></li><li><a href=#254-生成容器>2.5.4 生成容器</a></li><li><a href=#255-cmd命令>2.5.5 CMD命令</a></li></ul></li><li><a href=#26-删除镜像>2.6 删除镜像</a></li></ul><ul><li><a href=#41-删除容器>4.1 删除容器</a></li><li><a href=#42-停止容器>4.2 停止容器</a></li><li><a href=#43-启动已停止的容器>4.3 启动已停止的容器</a></li><li><a href=#44-后台运行>4.4 后台运行</a><ul><li><a href=#441-进入容器>4.4.1 进入容器</a></li></ul></li><li><a href=#45-导入导出容器>4.5 导入导出容器</a><ul><li><a href=#451-导出容器>4.5.1 导出容器</a></li><li><a href=#452-导入容器快照>4.5.2 导入容器快照</a></li></ul></li><li><a href=#46-拷贝容器文件到本机>4.6 拷贝容器文件到本机</a></li></ul><ul><li><a href=#51-保存迁移镜像>5.1 保存/迁移镜像</a></li><li><a href=#52-移动镜像文件>5.2 移动镜像文件</a></li><li><a href=#53-导入镜像>5.3 导入镜像</a></li><li><a href=#54-总结-importsave-之间的差别>5.4 总结 import/save 之间的差别</a></li></ul><ul><li><a href=#61-补充>6.1 补充</a></li><li><a href=#62-修改容器的挂载目录>6.2 修改容器的挂载目录</a></li><li><a href=#63-直接修改-docker-中挂载目录>6.3 直接修改 docker 中挂载目录</a></li><li><a href=#64-在服务器上使用-docker-以及挂载文件夹>6.4 在服务器上使用 Docker 以及挂载文件夹</a><ul><li><a href=#641-step1>6.4.1 Step1</a></li><li><a href=#642-step2>6.4.2 Step2</a></li></ul></li></ul><ul><li><a href=#81-改名>8.1 改名</a></li><li><a href=#82-更改存储位置>8.2 更改存储位置</a></li></ul><ul><li><a href=#91-step>9.1 Step</a></li></ul><ul><li><a href=#101>10.1</a></li><li><a href=#102>10.2</a></li><li><a href=#103>10.3</a></li></ul></nav></div></div><div class=post-content><h1 id=0-前言>0. 前言</h1><p>最近需要使用到 Docker, 记一下笔记和常用的操作。主要是参考菜鸟教程和阮一峰老师的教程。</p><h1 id=1-启动docker服务>1. 启动Docker服务</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># service 命令的用法</span>
</span></span><span style=display:flex><span>$ sudo service docker start
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># systemctl 命令的用法</span>
</span></span><span style=display:flex><span>$ sudo systemctl start docker
</span></span></code></pre></div><h1 id=2-image>2. Image</h1><h2 id=21-本地-image-管理>2.1 本地 image 管理</h2><p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong> 只有通过这个文件，才能生成 Docker 容器。</p><p><strong>image 文件可以看作是容器的模板</strong> Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 列出本机的所有 image 文件。</span>
</span></span><span style=display:flex><span>$ docker image ls
</span></span><span style=display:flex><span>$ docler images
</span></span><span style=display:flex><span>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE
</span></span><span style=display:flex><span>ubuntu        latest    fb52e22af1b0   <span style=color:#ae81ff>2</span> weeks ago    72.8MB
</span></span><span style=display:flex><span>hello-world   latest    d1165f221234   <span style=color:#ae81ff>6</span> months ago   13.3kB
</span></span><span style=display:flex><span>ubuntu        15.10     9b9cb95443b5   <span style=color:#ae81ff>5</span> years ago    137MB
</span></span><span style=display:flex><span><span style=color:#75715e>#仓库源		标签		ID				创建时间		大小</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 删除 image 文件</span>
</span></span><span style=display:flex><span>$ docker image rm <span style=color:#f92672>[</span>imageName<span style=color:#f92672>]</span>
</span></span></code></pre></div><blockquote><p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p><p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库 <a href=https://hub.docker.com/>Docker Hub</a> 是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p></blockquote><h2 id=22-查找image>2.2 查找Image</h2><p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong><a href=https://hub.docker.com/>https://hub.docker.com/</a></strong></p><p>我们也可以使用 docker search 命令来搜索镜像。比如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker search gpgpusim
</span></span><span style=display:flex><span>NAME                                DESCRIPTION                                 STARS     OFFICIAL AUTOMATED
</span></span><span style=display:flex><span>findhao/gpgpusim_runtime            gpgpusim docker                                 <span style=color:#ae81ff>0</span>                <span style=color:#f92672>[</span>OK<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>pli11/gpgpusim                                                                      <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>syuan3/gpgpusim                     a docker container <span style=color:#66d9ef>for</span> gpgpusim simulaator      <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>socalucr/gpgpusim-homework          Container used to evaluate GPU homework @UCR    <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>pitipat1998/gpgpusim                                                                <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>yhgong/gpgpusimdev_200318                                                           <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>lemonsien/gpgpusim                                                                  <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>jefferlee/gpgpusim_runtime                                                          <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>msharmavikram/gpgpusimdnn           The repository has all required elements <span style=color:#66d9ef>for</span>…   <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>minttmdgh/gpgpusim-setting          default                                         <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>marziehlenjani/gpgpusimwithcuda11                                                   <span style=color:#ae81ff>0</span>                    
</span></span><span style=display:flex><span>sis013/injesim4                     gpgpusim-4.0 with jonghyun                      <span style=color:#ae81ff>0</span>     
</span></span><span style=display:flex><span><span style=color:#75715e>#仓库源的名称							镜像描述				         类似github star 是否docker官方发布 自动构建</span>
</span></span></code></pre></div><h2 id=23-pull镜像>2.3 pull镜像</h2><p>使用命令 docker pull 来下载镜像</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker pull findhao/gpgpusim_runtime
</span></span><span style=display:flex><span>$ docker pull ubuntu:20.04
</span></span></code></pre></div><p>没想到 UCR 那个还挺大的，下了一会儿失败了，换成了 findhao/gpgpusim_runtime</p><h2 id=24-运行镜像>2.4 运行镜像</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker run -it findhao/gpgpusim_runtime
</span></span><span style=display:flex><span>$ docker run -it ubuntu:20.04 /bin/bash
</span></span></code></pre></div><p><strong>选项</strong></p><p><code>--gpus all</code>: 把所有 GPU 映射到镜像</p><h2 id=25-创建镜像>2.5 创建镜像</h2><p>两种方法</p><ul><li>从已经创建的容器中更新镜像，并且提交这个镜像。即把容器快照导入镜像</li><li>使用 Dockerfile 指令来创建一个新的镜像</li></ul><h3 id=251-更新镜像>2.5.1 更新镜像</h3><p>更新镜像之前，我们需要使用镜像来创建一个容器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker run -t -i ubuntu:15.10 /bin/bash
</span></span><span style=display:flex><span>root@b251c90ca048:/# 
</span></span></code></pre></div><p>在运行的容器内使用 <strong>apt-get update</strong> 命令进行更新。</p><p>在完成操作之后，输入 exit 命令来退出这个容器。</p><p>此时 ID 为 b251c90ca048 的容器，是按我们的需求更改的容器。我们可以通过命令 docker commit 来提交容器副本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker commit -m<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;has update&#34;</span> -a<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;cory&#34;</span> b251c90ca048  huweim/ubuntu:v2
</span></span><span style=display:flex><span><span style=color:#75715e>#-m 描述信息 -a 指定作者 b251c90ca048 容器ID huweim/ubuntu:v2 创建的目标镜像名</span>
</span></span><span style=display:flex><span>sha256:93069e854b178767dfcd334c8ce99d29141fdc87719c2bb1251d9e16e255de73
</span></span></code></pre></div><blockquote><p>也就是我们在镜像中做了修改，随时更新保存为新的镜像即可</p></blockquote><h3 id=252-构建镜像>2.5.2 构建镜像</h3><h4 id=2521-dockerfile>2.5.2.1 Dockerfile</h4><p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的<a href=https://github.com/ruanyf/koa-demos/blob/master/.dockerignore>内容</a>。</p><pre tabindex=0><code>.git
node_modules
npm-debug.log
</code></pre><p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p><p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p><p>每一个指令都会在镜像上创建一个新的层，每一个指令的前缀都必须是大写的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ touch Dockerfile 
</span></span><span style=display:flex><span>$ gedit Dockerfile
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FROM node:8.4 <span style=color:#75715e>#该 image 文件继承官方的 node image，冒号表示标签，这里标签是8.4，即8.4版本的 node。</span>
</span></span><span style=display:flex><span>COPY . /app <span style=color:#75715e>#将当前目录下的所有文件（除了.dockerignore排除的路径），都拷贝进入 image 文件的/app目录。</span>
</span></span><span style=display:flex><span>WORKDIR /app <span style=color:#75715e>#指定接下来的工作路径为/app。</span>
</span></span><span style=display:flex><span>RUN npm install --registry<span style=color:#f92672>=</span>https://registry.npm.taobao.org <span style=color:#75715e>#在/app目录下，运行npm install命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</span>
</span></span><span style=display:flex><span>EXPOSE <span style=color:#ae81ff>3000</span> <span style=color:#75715e>#将容器 3000 端口暴露出来， 允许外部连接这个端口。</span>
</span></span><span style=display:flex><span>CMD node demos/01.js
</span></span></code></pre></div><blockquote><p>Ubuntu 我自己使用 touch Dockerfile, 然后 gedit Dockfile 去编辑</p></blockquote><h4 id=2522-docker-build>2.5.2.2 Docker build</h4><p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image build -t koa-demo .
</span></span><span style=display:flex><span><span style=color:#75715e># 或者</span>
</span></span><span style=display:flex><span>$ docker image build -t koa-demo:0.0.1 .
</span></span><span style=display:flex><span><span style=color:#75715e>#-t: IMAGE名字 .: Dockerfile 文件所在目录，可以指定 Dockerfile 的绝对路径</span>
</span></span></code></pre></div><p>使用 Dockerfile 文件，通过 docker build 命令来构建一个镜像。</p><p>在 Desktop 下可以跑</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker build -t runoob/centos:6.7 .
</span></span><span style=display:flex><span><span style=color:#75715e>#-t: 指定要创建的目标镜像名      .: Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</span>
</span></span></code></pre></div><blockquote><p>可以跑起来，不过太大了中途终止掉</p></blockquote><h3 id=253-设置镜像标签>2.5.3 设置镜像标签</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker tag IMAGEID runoob/centos:dev
</span></span></code></pre></div><h3 id=254-生成容器>2.5.4 生成容器</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run -p 8000:3000 -it koa-demo /bin/bash
</span></span><span style=display:flex><span><span style=color:#75715e># 或者</span>
</span></span><span style=display:flex><span>$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash
</span></span><span style=display:flex><span><span style=color:#75715e>#-p: 容器的 3000 端口映射到本机的 8000 端口</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#-it: 容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。也就是交互式</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#koa-demo: IMAGE名字，如果有标签，还需要提供标签，默认是 latest 标签</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#/bin/bash: 容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</span>
</span></span></code></pre></div><p>可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p><h3 id=255-cmd命令>2.5.5 CMD命令</h3><blockquote><p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p></blockquote><p><code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p><blockquote><p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p><p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1
</span></span></code></pre></div><h2 id=26-删除镜像>2.6 删除镜像</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ docker rmi IMAGE_ID
</span></span><span style=display:flex><span>$ docker rmi IMAGE_NAME:TAG
</span></span></code></pre></div><h1 id=3-实例hello-world>3. 实例：hello world</h1><p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image pull library/hello-world
</span></span></code></pre></div><p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p><p>由于 Docker 官方提供的 image 文件，都放在<a href=https://hub.docker.com/r/library/>library</a>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image pull hello-world
</span></span></code></pre></div><p>在本机看到这个 image 文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker image ls
</span></span></code></pre></div><p>运行这个 image 文件</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run hello-world
</span></span></code></pre></div><p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p><p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p><blockquote><p>如果运行成功，你会在屏幕上读到下面的输出。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run hello-world
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Hello from Docker!
</span></span><span style=display:flex><span>This message shows that your installation appears to be working correctly.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>... ...
</span></span></code></pre></div></blockquote><p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p><p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run -it ubuntu bash	<span style=color:#75715e>#-i交互式操作 -t 终端</span>
</span></span></code></pre></div></blockquote><p>对于那些不会自动终止的容器，必须使用<a href=https://docs.docker.com/engine/reference/commandline/container_kill/>docker container kill</a> 命令手动终止。</p><blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container kill <span style=color:#f92672>[</span>containID<span style=color:#f92672>]</span>
</span></span></code></pre></div></blockquote><h1 id=4-container>4. Container</h1><p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong> 也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#75715e># 列出本机正在运行的容器</span>
</span></span><span style=display:flex><span>$ docker container ls
</span></span><span style=display:flex><span>$ docker ps <span style=color:#75715e>#应该是一样的效果</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 列出本机所有容器，包括终止运行的容器</span>
</span></span><span style=display:flex><span>$ docker container ls --all
</span></span><span style=display:flex><span>$ docker ps -a
</span></span></code></pre></div><p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p><h2 id=41-删除容器>4.1 删除容器</h2><p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container rm <span style=color:#f92672>[</span>containerID<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>$ docker container prune <span style=color:#75715e>#清理所有处于终止状态的容器。</span>
</span></span></code></pre></div><p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p><h2 id=42-停止容器>4.2 停止容器</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker stop &lt;容器 ID&gt;
</span></span></code></pre></div><h2 id=43-启动已停止的容器>4.3 启动已停止的容器</h2><p>使用 docker start 启动一个已停止的容器</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker start b750bbbcfd88	<span style=color:#75715e>#ID</span>
</span></span></code></pre></div><h2 id=44-后台运行>4.4 后台运行</h2><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container run -itd --name ubuntu-test ubuntu /bin/bash
</span></span></code></pre></div><p>**注：**加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>（下面会介绍到）</p><p>NOTE: If you want to detach (push it to background) from the container without shutting it down, use <em>ctrl+p+q</em> Remember that <em>$ exit</em> would shutdown the container.</p><h3 id=441-进入容器>4.4.1 进入容器</h3><p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p><ul><li><strong>docker attach</strong></li><li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</li></ul><h4 id=4411-exec-命令>4.4.1.1 exec 命令</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker exec -it containerID /bin/bash
</span></span></code></pre></div><h2 id=45-导入导出容器>4.5 导入导出容器</h2><h3 id=451-导出容器>4.5.1 导出容器</h3><p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker export 1e560fca3906 &gt; ubuntu.tar
</span></span></code></pre></div><p>导出容器 1e560fca3906 快照到本地文件 ubuntu.tar</p><h3 id=452-导入容器快照>4.5.2 导入容器快照</h3><p>可以使用 docker import 从容器快照文件中再导入为镜像 (Image)，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ cat docker/ubuntu.tar | docker import - test/ubuntu:v1
</span></span></code></pre></div><p>此外，也可以通过指定 URL 或者某个目录来导入，例如</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker import http://example.com/exampleimage.tgz example/imagerepo
</span></span></code></pre></div><h2 id=46-拷贝容器文件到本机>4.6 拷贝容器文件到本机</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker container cp <span style=color:#f92672>[</span>containID<span style=color:#f92672>]</span>:<span style=color:#f92672>[</span>/path/to/file<span style=color:#f92672>]</span> .
</span></span></code></pre></div><h1 id=5-制作镜像文件>5. 制作镜像文件</h1><h2 id=51-保存迁移镜像>5.1 保存/迁移镜像</h2><p>把镜像保存为压缩包</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker save -o gpgpusim.tar huweim/gpgpu-sim:v2
</span></span></code></pre></div><h2 id=52-移动镜像文件>5.2 移动镜像文件</h2><p>现在镜像放在了 <code>gpgpusim.tar</code> 压缩包中，可以迁移到你打算使用的机器上</p><h2 id=53-导入镜像>5.3 导入镜像</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker load -i gpgpusim.tar
</span></span></code></pre></div><h2 id=54-总结-importsave-之间的差别>5.4 总结 import/save 之间的差别</h2><ul><li>import: Container -> .tar, export: .tar -> Image</li><li>save: Image -> .tar, load: .tar -> Image</li></ul><h1 id=6-挂载->6. 挂载 ⭐</h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>$ docker run -it -v /home/vsp/huweim/gpgpusim:/root/share ubuntu:20.04 /bin/bash
</span></span></code></pre></div><p>2022-05-30 10:52:45，使用这个选项时，会用 host 中的文件来覆盖 docker 容器中的文件</p><h2 id=61-补充>6.1 补充</h2><p>host 作为 user，没有 root 权限，此时运行 docker，docker 中的 user id 需要和 host user id 一致，才可以在 docker 中修改挂载目录。</p><h2 id=62-修改容器的挂载目录>6.2 修改容器的挂载目录</h2><p>方法1，停止 Docker 服务后，修改 docker 配置文件。但是在服务器上停止服务比较麻烦，采用方法2。</p><p>方法2，把容器提交为镜像，之后创建新的容器。</p><h2 id=63-直接修改-docker-中挂载目录>6.3 直接修改 docker 中挂载目录</h2><p>把 docker user id 修改为和 host 一样的 user id，查看主机 user id 为 <code>wmhu❌2039:2039::/home/wmhu:/usr/bin/zsh</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ vim /etc/passwd
</span></span></code></pre></div><h2 id=64-在服务器上使用-docker-以及挂载文件夹>6.4 在服务器上使用 Docker 以及挂载文件夹</h2><p>以 qz 服务器为例吧，2022-06-02 13:51:40，在 GPU74 结点上突然又可以用 docker 了。</p><h3 id=641-step1>6.4.1 Step1</h3><p>因为是在服务器上，所以要用 sudo</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ sudo docker pull a1245967/gpgpusim
</span></span><span style=display:flex><span>$ sudo docker run -it -v /nvme/wmhu/share_docker:/home/wmhu/share -v /home/wmhu/gpgpu-sim_distribution:/home/wmhu/gpgpu-sim_distribution --privileged<span style=color:#f92672>=</span>true -p 50002:22 a1245967/gpgpusim /bin/bash
</span></span></code></pre></div><p>至此已经创建了容器，以及相应的挂载文件夹。</p><h4 id=6411-插曲>6.4.1.1 插曲</h4><p>连接服务器，在 /home/user 目录下创建 .vscode 目录，此时可以用 vscode 连接，在 GPU68 结点下，将 /home/user 目录下的 .vscode 目录作为 GPU68:/nvme/wmhu 目录下的软链接。如果切换到 GPU74 结点，访问 /home/user 目录下的 .vscode 目录，实际访问的是 GPU68:/nvme/wmhu 目录，而 GPU74 结点是访问不到 GPU68 结点的这个目录，因此 vscode 会连接失败，而 ssh 直接连接是可以额。</p><p>解决：登录 GPU68 结点，删除 /home/user 目录下的 .vscode 软链接。然后用 GPU74 直接登录，会在 /home/user 目录下重新下载 .vscode，此时可以登录。</p><h3 id=642-step2>6.4.2 Step2</h3><p>此时进入了服务器的 Docker，在 Docker 中创建 user 并且修改 user id，和服务器上的 user id 一致</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ useradd wmhu 
</span></span><span style=display:flex><span>$ passwd wmhu <span style=color:#75715e>#设置密码，输入两次</span>
</span></span><span style=display:flex><span>$ id <span style=color:#75715e># 查看 user id，修改为和 host 一致的 id</span>
</span></span><span style=display:flex><span>uid<span style=color:#f92672>=</span>1129<span style=color:#f92672>(</span>zdli<span style=color:#f92672>)</span> gid<span style=color:#f92672>=</span>1118<span style=color:#f92672>(</span>group_ljw<span style=color:#f92672>)</span> groups<span style=color:#f92672>=</span>1118<span style=color:#f92672>(</span>group_ljw<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>$ usermod -u <span style=color:#ae81ff>1129</span> wmhu
</span></span><span style=display:flex><span><span style=color:#75715e># qz server 上的 group 是 group_ljw，所以要手动添加 group</span>
</span></span><span style=display:flex><span>$ groupadd -g <span style=color:#ae81ff>1118</span> group_ljw
</span></span><span style=display:flex><span>$ usermod -g group_ljw wmhu <span style=color:#75715e># 把 wmhu 添加到 group_ljw</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 接下来修改挂载目录的 user 和 group，原本是 root</span>
</span></span><span style=display:flex><span>$ chown -R wmhu:group_ljw *
</span></span><span style=display:flex><span>$ usermod -aG sudo wmhu <span style=color:#75715e># 给 sudo 权限</span>
</span></span></code></pre></div><h1 id=7-磁盘清理>7. 磁盘清理</h1><blockquote><p>2022-01-07 12:05:29，不过这次磁盘爆掉主要是因为在 Docker 中没有清理 gpgpusim log 文件</p></blockquote><p>对于 Contains，长期不关闭或者清理会导致占用的内存过大</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ docker system df <span style=color:#75715e>#查看 Docker 占用分布</span>
</span></span><span style=display:flex><span>$ docker system prune <span style=color:#75715e>#对空间自动清理</span>
</span></span></code></pre></div><p>自动清理范围</p><blockquote><p>已停止的容器
未被任何容器使用的卷
未被任何容器所关联的网络
所有悬空的镜像</p></blockquote><h1 id=8-镜像上传-push>8. 镜像上传 Push</h1><p>上传前需要先登录，这里默认已经登录了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ docker login
</span></span></code></pre></div><h2 id=81-改名>8.1 改名</h2><p>将名字带上 docker hub 的 ID，否则无法 push，我自己是 <code>ccoryhu</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ docker tag b356b84be90b ccoryhu/gpgpu4.0-init
</span></span><span style=display:flex><span>$ docker push ccoryhu/gpgpu4.0-init
</span></span></code></pre></div><h2 id=82-更改存储位置>8.2 更改存储位置</h2><p>为了防止占用太多硬盘空间，把镜像放到更大的磁盘 <code>/home/Data</code> 中，使用软链接的方法</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ sudo service docker stop
</span></span><span style=display:flex><span>$ mv /var/lib/docker /home/Data/docker
</span></span><span style=display:flex><span>$ sudo ln -s /home/Data/docker/docker /var/lib/docker <span style=color:#75715e>#建立软链接</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ ls /var/lib/docker <span style=color:#75715e>#确认一下类型</span>
</span></span><span style=display:flex><span>$ sudo service docker start <span style=color:#75715e>#开启服务</span>
</span></span><span style=display:flex><span>$ docker ps -a
</span></span><span style=display:flex><span>$ docker images <span style=color:#75715e>#确认能够读到容器和镜像</span>
</span></span></code></pre></div><h1 id=9-添加-docker-group>9. 添加 docker group</h1><p>Manage Docker as a non-root user:</p><blockquote><p>The Docker daemon binds to a Unix socket instead of a TCP port. By default that Unix socket is owned by the user root and other users can only access it using sudo. The Docker daemon always runs as the root user.</p><p>If you don’t want to preface the docker command with sudo, create a Unix group called docker and add users to it. When the Docker daemon starts, it creates a Unix socket accessible by members of the docker group.</p></blockquote><blockquote><p>Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。 默认情况下，Unix 套接字由用户 root 拥有，其他用户只能使用 sudo 访问它。 Docker 守护程序始终以 root 用户身份运行。</p><p>如果您不想在 docker 命令前面加上 sudo，请创建一个名为 docker 的 Unix 组并将用户添加到其中。 当 Docker 守护进程启动时，它会创建一个可供 docker 组成员访问的 Unix 套接字。</p></blockquote><h2 id=91-step>9.1 Step</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># Create the docker group.</span>
</span></span><span style=display:flex><span>$  sudo groupadd docker
</span></span><span style=display:flex><span><span style=color:#75715e># Add your user to the docker group.</span>
</span></span><span style=display:flex><span>$  sudo usermod -aG docker $USER
</span></span><span style=display:flex><span><span style=color:#75715e># Log out and log back in so that your group membership is re-evaluated.</span>
</span></span><span style=display:flex><span><span style=color:#75715e># Linux use the following command</span>
</span></span><span style=display:flex><span>$  newgrp docker 
</span></span><span style=display:flex><span><span style=color:#75715e># Verify that you can run docker commands without sudo.</span>
</span></span><span style=display:flex><span>$  docker run hello-world
</span></span></code></pre></div><h1 id=10-bug>10. BUG</h1><h2 id=101>10.1</h2><p>Job for docker.service failed because the control process exited with error code</p><p>启动时报错使用 <code>sudo dockerd --debug</code> 查看，发现错误是 <code>failed to start daemon: error initializing graphdriver: driver not supported</code></p><h2 id=102>10.2</h2><p>Error processing tar file(exit status 1): unexpected EOF</p><p>把 .tar 文件上传到服务器上时，没有 <code>chmod</code> 给权限，所以报错</p><h2 id=103>10.3</h2><p>Docker容器里没有权限执行命令，提示Permission denied</p><p>原因是 mkdir 执行的对象是 host 和 Docker 之间的共享文件夹，docker 可能对 host 文件夹没有操作的权限，所以 Permission denied。</p><p>方法1：<code>sudo docker exec -it -u wmhu 582c677c2c35 /bin/bash</code>；但是在交大服务器上没有 sudo 权限，所有尝试用方法2.</p><p>方法2：创建容器实例的时候，增加参数&ndash;privileged=true；同时，还需要指定 user id。</p><p>这两个方法也许可以解决问题，但自己没有测试，因为 mwhu 这个用户不在 docker group 里面。选择的处理方式是在 Docker 中不修改挂载目录，在 host 端修改和编译即可。</p><h1 id=reference>Reference</h1><p><a href=https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html>https://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html</a> Docker 入门教程</p><p><a href=https://www.runoob.com/docker/docker-container-connection.html>https://www.runoob.com/docker/docker-container-connection.html</a> <strong>Docker 教程</strong></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Cory</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2022-11-26</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://huweim.github.io/tags/docker/>Docker</a></div><nav class=post-nav><a class=prev href=/post/%E5%AE%9E%E9%AA%8C_%E6%90%AD%E5%BB%BAsim%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">搭建GPGPU-Sim实验环境</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/%E6%96%87%E6%A1%A3_simt_core/><span class="next-text nav-default">SIMT_Core</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:huwm1@shanghaitech.edu.cn rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=http://localhost:1313 rel="me noopener" class=iconfont title=linkedin target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="33" height="33"><path d="M872.405333 872.618667H720.768V635.008c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333.0-91.136 61.653333-91.136 125.397334v241.792H398.976V384H544.64v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667.0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667.0 01-88.021333-88.106666A88.064 88.064.0 11227.712 317.141333zm76.032 555.477334H151.68V384h152.064v488.618667zM948.266667.0h-872.704C33.792.0.0 33.024.0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667.0 948.138667.0h.128z"/></svg></a><a href=https://github.com/huweim rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://www.zhihu.com/people/hu-wei-ming-31-86 rel="me noopener" class=iconfont title=zhihu target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg></a><a href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2020 -
2023
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>Cory</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>