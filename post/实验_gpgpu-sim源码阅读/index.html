<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage data-theme=light><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>GPGPU-Sim源码阅读 - Weiming Hu
</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=color-scheme content="light dark"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=generator content="Hugo 0.140.2"><link rel=canonical href=https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/><meta name=author content="Cory"><meta name=description content="1. Shader.cc shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等
m_stats 也就是 shader_core_stats 类型的变量
num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量
"><meta name=keywords content><meta property="og:url" content="https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"><meta property="og:site_name" content="Weiming Hu"><meta property="og:title" content="GPGPU-Sim源码阅读"><meta property="og:description" content="1. Shader.cc shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等
m_stats 也就是 shader_core_stats 类型的变量
num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-09-28T15:51:46+08:00"><meta property="article:modified_time" content="2023-03-21T10:02:46+08:00"><meta property="article:tag" content="GPGPU-Sim"><meta itemprop=name content="GPGPU-Sim源码阅读"><meta itemprop=description content="1. Shader.cc shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等
m_stats 也就是 shader_core_stats 类型的变量
num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量"><meta itemprop=datePublished content="2021-09-28T15:51:46+08:00"><meta itemprop=dateModified content="2023-03-21T10:02:46+08:00"><meta itemprop=wordCount content="2610"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="GPGPU-Sim源码阅读"><meta name=twitter:description content="1. Shader.cc shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等
m_stats 也就是 shader_core_stats 类型的变量
num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量"><link rel=icon href=/favicon.ico><link rel=stylesheet href=/css/style.min.1acfe3c0bf85aa6c451ba764236bb3ab12c22cd38eee8ecc8fac33defcc7156d.css integrity="sha256-Gs/jwL+FqmxFG6dkI2uzqxLCLNOO7o7Mj6wz3vzHFW0=" media=screen crossorigin=anonymous><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script>(function(){var e=localStorage.getItem("theme")||"light";document.documentElement.setAttribute("data-theme",e)})()</script></head><body><div id=back-to-top></div><header class=site-header><div class=desktop-header><div class=desktop-header-logo><a href=/ class=logo>Weiming Hu</a></div><nav class=desktop-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li><li class=menu-item><a class="theme-toggle menu-item-link" href=javascript:void(0);><svg aria-hidden="true" class="lucide lucide-sun hi-svg-inline theme-icon-light" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg><svg aria-hidden="true" class="lucide lucide-moon hi-svg-inline theme-icon-dark" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline icon--rss" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav></div><div class=mobile-header><div id=mobile-navbar class=mobile-navbar><div id=mobile-navbar-icon class=mobile-navbar-icon><svg aria-hidden="true" class="lucide lucide-menu hi-svg-inline icon--menu" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></svg></div><div class=mobile-navbar-logo><a href=/ class=logo>Weiming Hu</a></div></div><div id=mobile-menu-close-modal class=mobile-menu-close-modal></div><nav id=mobile-menu class=mobile-menu><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li><li class=mobile-menu-item><a class="theme-toggle menu-item-link" href=javascript:void(0);><svg aria-hidden="true" class="lucide lucide-sun hi-svg-inline theme-icon-light" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg><svg aria-hidden="true" class="lucide lucide-moon hi-svg-inline theme-icon-dark" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M12 3a6 6 0 009 9 9 9 0 11-9-9z"/></svg></a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline icon--rss" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></li></ul></nav></div></header><main id=main class="main pico container"><div class=content-wrapper><aside class=sidebar></aside><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>GPGPU-Sim源码阅读</h1><div class=post-meta-list><div class="post-meta-item post-meta-author"><svg aria-hidden="true" class="lucide lucide-user-round-pen hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M2 21a8 8 0 0110.821-7.487"/><path d="M21.378 16.626a1 1 0 00-3.004-3.004l-4.01 4.012a2 2 0 00-.506.854l-.837 2.87a.5.5.0 00.62.62l2.87-.837a2 2 0 00.854-.506z"/><circle cx="10" cy="8" r="5"/></svg>
Cory</div><div class="post-meta-item post-meta-time"><svg aria-hidden="true" class="lucide lucide-calendar-days hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M8 2v4"/><path d="M16 2v4"/><rect width="18" height="18" x="3" y="4" rx="2"/><path d="M3 10h18"/><path d="M8 14h.01"/><path d="M12 14h.01"/><path d="M16 14h.01"/><path d="M8 18h.01"/><path d="M12 18h.01"/><path d="M16 18h.01"/></svg>
<time datetime=2021-09-28>2021-09-28
</time><span class="post-meta-item post-meta-lastmod">(LastMod:
2023-03-21)</span></div><div class=post-meta__right><span class=post-meta-more>2610 words -
6 min read</span><div class="post-meta-item post-meta-category"><a href=https://huweim.github.io/categories/%E7%BC%96%E7%A8%8B/>编程</a></div></div></div></header><div class=post-content><h1 id=1-shadercc>1. Shader.cc</h1><p>shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等</p><p>m_stats 也就是 shader_core_stats 类型的变量</p><p>num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量</p><p>tw_get_oracle_CPL_counter 计算 warp 的 CPL counter 值</p><h2 id=11-shader_core_ctxdecode-函数>1.1 shader_core_ctx::decode 函数</h2><p>检查 fetch buffer 中的指令是否有效，如有效则进入循环。获得当前指令的 pc，并取指令。</p><p>指令用变量 pI1 存储，调用函数 ibuffer_fill, 将 pI 装进对应 warp id 的 I-Buffer, 并将 valid bit 置为1</p><p>随后会取下一条指令，用变量 pI2 存储，注意下一条指令的 <code>pc = pc + pI1 -> isize</code>。也就是我们常说的 pc = pc + 1, 这里的1实际上是一条指令的长度</p><p>每个 warp 有两个 ibuffer slot, 也就是 ibuffer_fill 中的0和1</p><h3 id=111-ifetch_buffer_taddress_type-pc-unsigned-nbytes-unsigned-warp_id>1.1.1 ifetch_buffer_t(address_type pc, unsigned nbytes, unsigned warp_id)</h3><p>是一个结构体，包含 m_valid, m_pc, m_nbytes, m_warp_id</p><p>构造时 valid 直接置为1</p><p>其变量作为 fetch 和 decode stage 之间的 pipeline register</p><p>理解为用于使得 fetch and decode 可以流水线执行的一个结构体</p><h2 id=12-hader_core_ctxfetch-函数>1.2 hader_core_ctx::fetch 函数</h2><p>访问内存 (L1 Cache or memory)，获取指令的 pc, size, warp_id</p><p>如果 L1 Cache 的 access ready, 也就是已经可以内存访问（之前 Miss 的时候需要的 data 已经从内存中取到了）</p><p>如果没有 access ready, 就去找一个 active, 并且在 I-Buffer 中还有空间, 没有在等待 cache miss 的 warp，取其 next instruction from i-cache</p><blockquote><p>第3层中的第1个 if 语句检查 warp 是否已经完成执行，第3层中的第2个 if 语句检查当前 warp 对应的 entry 是否已经存储了有效的指令</p></blockquote><p><strong>2021-11-30 09:51:16</strong></p><p>Fetch 是轮询进行的，从上一次 fetch warp 开始，一个接一个往后询问，直到遇到一个warp</p><ul><li>单个 warp 未完成执行，<code>!m_warp[warp_id].functional_done()</code></li><li>没有处于 miss pending，<code>!m_warp[warp_id].imiss_pending()</code>，I-cache miss 时设置为 miss pending 状态</li><li>ibuffer 为空，<code>m_warp[warp_id].ibuffer_empty()</code></li></ul><p>那么就进行内存访问，<code>m_L1I->access</code></p><h3 id=121-issue_warp-函数>1.2.1 issue_warp 函数</h3><p>free 掉相应的 I-Buffer</p><h2 id=13-scheduler_unitcycle>1.3 scheduler_unit::cycle()</h2><p>In function <code>scheduler_unit::cycle()</code> , call <code>order_warps()</code> to sort warps according to their priority.</p><p>排序后的 warp 放在 vector <code>m_next_cycle_prioritized_warps</code> 中，对其进行遍历来处理这个 vector 中的 warp。</p><p>&#x2757; 值得注意的是在 order_warp() 后，for 循环会遍历 vector <code>m_next_cycle_prioritized_warps</code> 中的所有 warp。而不是发射一个 warp 就重新排序一次。</p><blockquote><p>这一点和自己的理解与猜想不太一样</p></blockquote><hr><p>进入 for 循环，拿到 warp id，判断</p><ul><li>I-Buffer 是否为空；是否处于 waiting 状态。如果都通过，进入一个 while 循环<ul><li>如果指令是有效的 <code>if(pI)</code><ul><li>如果出现分支 <code>if(pc != pI->pc)</code>，刷掉 I-Buffer</li><li>如果没有分支，此时 <code>valid=true</code>，指令是有效的。如果通过 scoreboard 检测，终于可以执行了。先读取 active mask 确定要执行哪些线程，然后判断 <code>pI->op</code> 是 内存操作 还是 运算操作。如果相应的寄存器可以使用 <code>has_free()</code>，则 call <code>issue_warp()</code> 将寄存器、指令、active mask、warp id、scheduler id 发送并执行。</li><li><code>warp_inst_issued = true; issued++; issued_inst = true</code></li></ul></li><li>else if 下一条指令是有效的<ul><li>&mldr;</li></ul></li><li>如果指令成功发射 <code>if (warp_inst_issued)</code>，执行了 issue_warp() 后会进入这个 if 语句，做一些 warp 发射后的统计信息等等<ul><li>call <code>do_on_warp_issued(warp_id, issued, iter);</code></li></ul></li><li>checked++</li></ul></li><li>从 while 循环出来，如果至少有一个 warp 被发射 <code>if(issued)</code>，遍历 <code>m_supervised_warps</code>，找到那个被发射的 warp，然后将其赋值给 <code>m_last_supervised_issued</code></li></ul><hr><h3 id=131-scheduler_size>1.3.1 scheduler_size()</h3><p>scheduler.size 就是2，代表一个 core 中 warp scheduler 的数量</p><h1 id=14-simt_core_clustercore_cycle>1.4 simt_core_cluster::core_cycle()</h1><p>m_core_sim_order 大小为1</p><p>m_shader_config->n_simt_clusters 大小为15</p><h1 id=2-关于类>2. 关于类</h1><p>阅读一个类，应该先观察他还包含哪些子类，继承自哪个类，从全局上把握他的作用</p><p>class opndcoll_rfu_t</p><ul><li>class op_t</li><li>class allocation_t</li><li>class arbiter_t</li><li>class input_port_t</li><li>class collector_unit_t</li><li>dispatch_unit_t</li></ul><h1 id=3-地址信息>3. 地址信息</h1><p>src/abstract_hardware_model.h</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>per_thread_info</span> {
</span></span><span style=display:flex><span>    per_thread_info() {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> MAX_ACCESSES_PER_INSN_PER_THREAD; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        memreqaddr[i] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    dram_callback_t callback;
</span></span><span style=display:flex><span>    new_addr_type
</span></span><span style=display:flex><span>        memreqaddr[MAX_ACCESSES_PER_INSN_PER_THREAD];  <span style=color:#75715e>// effective address,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                       <span style=color:#75715e>// upto 8 different
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                       <span style=color:#75715e>// requests (to support
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                       <span style=color:#75715e>// 32B access in 8 chunks
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                                                       <span style=color:#75715e>// of 4B each)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  };
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>per_thread_info<span style=color:#f92672>&gt;</span> m_per_scalar_thread;</span></span></code></pre></div></div><p>现在我们关注每个 kernel_launch_uid 中的访存信息和打印出来的访存次数是否匹配</p><ul><li>&#x2714;&#xfe0f; 匹配。前两个 kernel (都是 create matrix) <code>gpgpu_n_param_mem_insn + gpgpu_n_store_insn = number of memaddr</code></li><li>不过要注意 Memory Access Statistics 的信息应该是总和而非单一 kernel</li></ul><h1 id=4-tracing>4. Tracing</h1><h2 id=41-4个-cycle-函数调用关系>4.1 4个 Cycle() 函数调用关系</h2><p>4个 cycle() 函数</p><p>shader_core_ctx::cycle() 在 issue 中调用 scheduler_unit::cycle(), 这两个应该是负责 SIMT Front 部分，从指令 fetch, decode, 到准备好后的调度发射 (sheduling and issue).</p><p>ldst_unit::cycle() 负责各个 memory 的时钟建模，包括 shared memory, L1 latebcy queue, constant menory, texture memory</p><h3 id=411-shader_core_ctxcycle>4.1.1 shader_core_ctx::cycle()</h3><ul><li>SIMT Core Cluster clock domain = frequency of the pipeline stages in a core clock (i.e. the rate at which <code>simt_core_cluster::core_cycle()</code> is called)<ul><li><code>simt_core_cluster::core_cycle()</code> will call <code>shader_core_ctx::cycle()</code></li></ul></li></ul><ul><li>&#x2b50; <code>m_thread[tid]->ptx_exec_inst(inst, t);</code> 用于执行 ptx 指令的执行</li></ul><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>shader_core_ctx<span style=color:#f92672>::</span>cycle()
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span>	writeback();
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span>	execute();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> m_fu[n]<span style=color:#f92672>-&gt;</span>cycle(); <span style=color:#75715e>//m_fu[] contains ldst_unit, sfu_unit, sp_unit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#f92672>|--</span> ldst_unit<span style=color:#f92672>::</span>cycle();
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> writeback();
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> m_operand_collector<span style=color:#f92672>-&gt;</span>step();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> issue(register_set <span style=color:#f92672>&amp;</span>source_reg)
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span>	read_operands();
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span>	issue();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> scheduler_unit<span style=color:#f92672>::</span>cycle();
</span></span><span style=display:flex><span>        <span style=color:#f92672>|--</span> order_warps();
</span></span><span style=display:flex><span>		<span style=color:#f92672>|--</span> m_shader<span style=color:#f92672>-&gt;</span>get_pdom_stack_top_info(warp_id, pI, <span style=color:#f92672>&amp;</span>pc, <span style=color:#f92672>&amp;</span>rpc);
</span></span><span style=display:flex><span>		<span style=color:#f92672>|--</span> m_shader<span style=color:#f92672>-&gt;</span>issue_warp();
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> (<span style=color:#f92672>*</span>pipe_reg)<span style=color:#f92672>-&gt;</span>warp_inst_t<span style=color:#f92672>::</span>issue();
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> func_exec_inst(<span style=color:#f92672>**</span>pipe_reg);
</span></span><span style=display:flex><span>				<span style=color:#f92672>|--</span> execute_warp_inst_t(inst);
</span></span><span style=display:flex><span>					<span style=color:#f92672>|--</span> m_thread[tid]<span style=color:#f92672>-&gt;</span>ptx_exec_inst(inst, t);
</span></span><span style=display:flex><span>						<span style=color:#f92672>|--</span> insn_memaddr <span style=color:#f92672>=</span> last_eaddr();
</span></span><span style=display:flex><span>						<span style=color:#f92672>|--</span> inst.set_addr(lane_id, insn_memaddr); <span style=color:#75715e>//util this, we have 											//the address in the class warp_inst_t
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#f92672>|--</span> updateSIMTStack(warp_id, <span style=color:#f92672>*</span>pipe_reg);
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> reserveRegisters(<span style=color:#f92672>*</span>pipe_reg);
</span></span><span style=display:flex><span>  			<span style=color:#f92672>|--</span> set_next_pc(next_inst<span style=color:#f92672>-&gt;</span>pc <span style=color:#f92672>+</span> next_inst<span style=color:#f92672>-&gt;</span>isize);
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span> decode();
</span></span><span style=display:flex><span>    <span style=color:#f92672>|--</span> ibuffer_fill(<span style=color:#ae81ff>0</span>, pI1);
</span></span><span style=display:flex><span>    <span style=color:#f92672>|--</span> inc_inst_in_pipeline();
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span> fetch();</span></span></code></pre></div></div><h3 id=412-scheduler_unitcycle>4.1.2 scheduler_unit::cycle()</h3><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#f92672>|--</span> order_warps();
</span></span><span style=display:flex><span><span style=color:#75715e>//if warp is valid and not waiting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|--</span> <span style=color:#66d9ef>const</span> warp_inst_t <span style=color:#f92672>*</span>pI <span style=color:#f92672>=</span> warp(warp_id).ibuffer_next_inst();
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span> m_shader<span style=color:#f92672>-&gt;</span>get_pdom_stack_top_info(warp_id, pI, <span style=color:#f92672>&amp;</span>pc, <span style=color:#f92672>&amp;</span>rpc);
</span></span><span style=display:flex><span><span style=color:#75715e>//deal with the control hazard
</span></span></span><span style=display:flex><span><span style=color:#75715e>//pc is the PC in the top of SIMT stack, pI-&gt;pc is the PC in the I-Buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e>//not equal means jump or ohter control hazard
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span>{
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span>(pI){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pc <span style=color:#f92672>!=</span> pI<span style=color:#f92672>-&gt;</span>pc) {
</span></span><span style=display:flex><span>		<span style=color:#f92672>|--</span> warp(warp_id).set_next_pc(pc);
</span></span><span style=display:flex><span>		<span style=color:#f92672>|--</span> warp(warp_id).ibuffer_flush(); <span style=color:#75715e>//need to flush
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>else</span>{
</span></span><span style=display:flex><span>    	<span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>m_scoreboard<span style=color:#f92672>-&gt;</span>checkCollision(warp_id, pI)){
</span></span><span style=display:flex><span>       		<span style=color:#f92672>|--</span> m_shader<span style=color:#f92672>-&gt;</span>get_active_mask(warp_id, pI);
</span></span><span style=display:flex><span>        	<span style=color:#75715e>// need to check which pipieline to send, MEM, SP, SFU... 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        	<span style=color:#75715e>// the only different is the first parameter, register_set *m_XX_out
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        	<span style=color:#f92672>|--</span> m_shader<span style=color:#f92672>-&gt;</span>shader_core_ctx<span style=color:#f92672>::</span>issue_warp(<span style=color:#f92672>*</span>m_mem_out, pI, active_mask, warp_id, m_id);
</span></span><span style=display:flex><span>    	}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span>(valid){
</span></span><span style=display:flex><span>    <span style=color:#75715e>// this case can happen after a return instruction in diverged warp
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>|--</span> warp(warp_id).set_next_pc(pc);
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> warp(warp_id).ibuffer_flush(); <span style=color:#75715e>//need to flush
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>}<span style=color:#75715e>//while
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>...</span></span></code></pre></div></div><p>执行这个 issue_warp 的时候需要的源操作数的寄存器已经拿到了 (判断 has_free()才会进入这个条件语句)</p><h3 id=413-ldst_unitcycle>4.1.3 ldst_unit::cycle()</h3><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>ldst_unit<span style=color:#f92672>::</span>cycle()
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span> writeback();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> Scoreboard<span style=color:#f92672>::</span>releaseRegister();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> warp_inst_complete(m_next_wb);
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> clear();
</span></span><span style=display:flex><span><span style=color:#f92672>|--</span> m_operand_collector<span style=color:#f92672>-&gt;</span>step();
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> dispatch_ready_cu(); <span style=color:#75715e>//把 ready_cu 发射到执行单元
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#f92672>|--</span> cu<span style=color:#f92672>-&gt;</span>dispatch(); 
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> allocate_reads(); <span style=color:#75715e>// process read requests that do not have conflicts. Map bank 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>						  <span style=color:#75715e>// and collector unit, 连接了 bank 和 cu, 准确到 cu 的哪个操作数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span>()<span style=color:#f92672>|--</span> allocate_cu(p);
</span></span><span style=display:flex><span>			<span style=color:#f92672>|--</span> allocated <span style=color:#f92672>=</span> cu<span style=color:#f92672>-&gt;</span>allocate(inp.m_in[i], inp.m_out[i]);<span style=color:#75715e>//终于找到了
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>			<span style=color:#f92672>|--</span> m_arbiter.add_read_requests(cu); <span style=color:#75715e>//把 cu 对特定 bank 的读请求入队 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>												<span style=color:#75715e>//m_queue[bank].push_back(op);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>|--</span> process_banks(); <span style=color:#75715e>//reset allocation, free cu
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|--</span> move_warp(warp_inst_t <span style=color:#f92672>*&amp;</span>dst, warp_inst_t <span style=color:#f92672>*&amp;</span>src); <span style=color:#75715e>// move src to dst
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|--</span> m_L1T<span style=color:#f92672>/</span>m_L1C<span style=color:#f92672>/</span>m_L1D<span style=color:#f92672>-&gt;</span>fill(); <span style=color:#75715e>//deal with fill request
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>|--</span> m_L1T<span style=color:#f92672>/</span>m_L1C<span style=color:#f92672>/</span>m_L1D<span style=color:#f92672>-&gt;</span>cycle(); <span style=color:#75715e>//send next request to lower level of memory
</span></span></span></code></pre></div></div><p>在上述的 <code>allocated = cu->allocate(inp.m_in[i], inp.m_out[i])</code> 函数中<del>为寄存器赋值</del> 确定读哪个bank的哪个寄存器</p><p>m_src_op 中装的就是32个 源操作数寄存器，去哪个位置找 寄存器 的详细信息</p><p>dispatch() 后会 reset m_src_op,</p><h3 id=414-pipelined_simd_unitcycle>4.1.4 pipelined_simd_unit::cycle()</h3><p>用于模拟流水线，移动寄存器的 value..</p><div class=highlight-container><button class="copy-code-btn outline">Copy</button><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>m_pipeline_reg[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-&gt;</span>empty()) {
</span></span><span style=display:flex><span>	<span style=color:#f92672>|--</span> m_result_port<span style=color:#f92672>-&gt;</span>move_in(m_pipeline_reg[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>//move src to m_pipeline_reg[0]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    	<span style=color:#f92672>|--</span> warp_inst_t <span style=color:#f92672>**</span>free <span style=color:#f92672>=</span> get_free(); <span style=color:#75715e>//return a free register to variable **free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    	<span style=color:#f92672>|--</span> move_warp(<span style=color:#f92672>*</span>free, src); <span style=color:#75715e>//move src to *free
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    active_insts_in_pipeline<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (active_insts_in_pipeline) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>unsigned</span> stage <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; (stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;</span> m_pipeline_depth; stage<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>|--</span> move_warp(m_pipeline_reg[stage], m_pipeline_reg[stage <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>}</span></span></code></pre></div></div><h2 id=42-文档中-cycle-的介绍>4.2 文档中 Cycle() 的介绍</h2><h3 id=421-simt_core_clustercore_cycle>4.2.1 simt_core_cluster::core_cycle()</h3><p><code>simt_core_cluster::core_cycle()</code> 方法只是按顺序 循环调用 (cycles) 每个 SIMT core.</p><p><code>simt_core_cluster::icnt_cycle()</code> 方法将内存请求从 interconnection network push 到 SIMT Core Cluster&rsquo;s response FIFO. 它也将 FIFO 中的请求出队，送到合适的 core&rsquo;s instruction cache or LDST unit. 这些与前面描述的硬件块密切对应。</p><h3 id=422-shader_core_ctxcycle>4.2.2 shader_core_ctx::cycle()</h3><ul><li>每个 core cycle, 调用 <code>shader_core_ctx::cycle()</code> 来模拟 SIMT Core 的一个 cycle。</li><li>operand collector 被建模为主流水线中的一个 stage, 通过函数 <code>shader_core_ctx::cycle()</code> 执行</li></ul><h3 id=423-scheduler_unitcycle>4.2.3 scheduler_unit::cycle()</h3><ul><li>在 <code>scheduler_unit::cycle()</code> 中，函数 <code>shader_core_ctx::issue_warp()</code> 将指令发送到执行单元</li><li>调用 <code>func_exec_inst()</code> 执行指令</li><li>调用 <code>simt_stack::update()</code> 更新 SIMT Stack</li></ul><h3 id=424-ldst_unitcycle>4.2.4 ldst_unit::cycle()</h3><ul><li>·ldst_unit::cycle()· 处理来自 interconnect 的内存响应（存储在 m_response_fifo 中），填充 cache (<code>m_L1D->fill()</code>) 并将存储标记为完成。</li><li>该函数还 cycle caches，以便它们可以将 missed data 的请求发送到 interconnect</li><li>对每种类型的 L1 内存的 cache accesses 分别在 <code>shared cycle()</code>、<code>constant cycle()</code>、<code>texture cycle() </code>和 <code>memory cycle()</code> 中完成 (在 <code>ldst_unit::cycle()</code> 函数中调用)</li></ul><h3 id=425-gpgpu_simcycle>4.2.5 gpgpu_sim::cycle()</h3><ul><li><code>gpgpu sim::cycle()</code> 方法为 gpgpu - sim 中的所有架构组件的时钟，包括 Memory Partition 的队列，DRAM channel 和 L2 cache bank.</li><li>对 <code>memory_partition_unit::dram_cycle()</code> 的调用将内存请求从 L2->dram queue 移动到 dram channele，从 dram channel 移动到 dram->L2 queue，并 cycles 片外 GDDR3 dram 内存。</li><li>在这个函数中，调用<ul><li>icnt_cycle()</li><li>dram_cycle()</li><li>cache_cycle()</li><li>core_cycle()</li></ul></li></ul><p>所以可以看到，这个函数应该是调用了每个组件的 cycle(), 以此来建模整个 GPGPU-Sim cycle</p><h3 id=426-memory_partition_unitcache_cycle>4.2.6 memory_partition_unit::cache_cycle()</h3><ul><li>在 <code>memory_partition_unit::cache_cycle()</code> 中，调用 <code>mem_fetch *mf = m_L2cache->next_access();</code> 为在 filled MSHR entry 中等待的内存请求产生 replies.</li><li>L2 产生的由于 read miss 的 fill 请求将从 L2&rsquo;s miss queu 中弹出，并通过调用 <code>m_L2cache->cycle();</code> 将其push into L2->dram queue</li></ul><h3 id=427-dram_tcycle>4.2.7 dram_t::cycle()</h3><ul><li>The function <code>dram_t::cycle()</code> represents a DRAM cycle</li><li>每个周期，DRAM从请求队列中弹出一个请求，然后调用调度器函数，让调度器根据调度策略选择一个需要服务的请求。</li></ul></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Cory</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2023-03-21</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://huweim.github.io/tags/gpgpu-sim/>GPGPU-Sim</a></div><nav class=post-nav><a class=prev href=/post/blog_hugo_%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C/><i class=iconfont><svg aria-hidden="true" class="lucide lucide-chevron-left hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="m15 18-6-6 6-6"/></svg>
</i><span class="prev-text nav-default">Hugo 归档页面制作</span>
<span class="prev-text nav-mobile">Prev</span>
</a><a class=next href=/post/%E6%96%87%E6%A1%A3_gpgpu-sim---performance-simulation-engine/><span class="next-text nav-default">文档_GPGPU-sim - Performance Simulation Engine</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg aria-hidden="true" class="lucide lucide-chevron-right hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="m9 18 6-6-6-6"/></svg></i></a></nav></footer></article></div><nav class=toc id=toc><div class=toc-title>Table of Contents</div><div class="toc-content custom-scrollbar"><nav id=TableOfContents><ul><li><a href=#1-shadercc>1. Shader.cc</a><ul><li><a href=#11-shader_core_ctxdecode-函数>1.1 shader_core_ctx::decode 函数</a><ul><li><a href=#111-ifetch_buffer_taddress_type-pc-unsigned-nbytes-unsigned-warp_id>1.1.1 ifetch_buffer_t(address_type pc, unsigned nbytes, unsigned warp_id)</a></li></ul></li><li><a href=#12-hader_core_ctxfetch-函数>1.2 hader_core_ctx::fetch 函数</a><ul><li><a href=#121-issue_warp-函数>1.2.1 issue_warp 函数</a></li></ul></li><li><a href=#13-scheduler_unitcycle>1.3 scheduler_unit::cycle()</a><ul><li><a href=#131-scheduler_size>1.3.1 scheduler_size()</a></li></ul></li></ul></li><li><a href=#14-simt_core_clustercore_cycle>1.4 simt_core_cluster::core_cycle()</a></li><li><a href=#2-关于类>2. 关于类</a></li><li><a href=#3-地址信息>3. 地址信息</a></li><li><a href=#4-tracing>4. Tracing</a><ul><li><a href=#41-4个-cycle-函数调用关系>4.1 4个 Cycle() 函数调用关系</a><ul><li><a href=#411-shader_core_ctxcycle>4.1.1 shader_core_ctx::cycle()</a></li><li><a href=#412-scheduler_unitcycle>4.1.2 scheduler_unit::cycle()</a></li><li><a href=#413-ldst_unitcycle>4.1.3 ldst_unit::cycle()</a></li><li><a href=#414-pipelined_simd_unitcycle>4.1.4 pipelined_simd_unit::cycle()</a></li></ul></li><li><a href=#42-文档中-cycle-的介绍>4.2 文档中 Cycle() 的介绍</a><ul><li><a href=#421-simt_core_clustercore_cycle>4.2.1 simt_core_cluster::core_cycle()</a></li><li><a href=#422-shader_core_ctxcycle>4.2.2 shader_core_ctx::cycle()</a></li><li><a href=#423-scheduler_unitcycle>4.2.3 scheduler_unit::cycle()</a></li><li><a href=#424-ldst_unitcycle>4.2.4 ldst_unit::cycle()</a></li><li><a href=#425-gpgpu_simcycle>4.2.5 gpgpu_sim::cycle()</a></li><li><a href=#426-memory_partition_unitcache_cycle>4.2.6 memory_partition_unit::cache_cycle()</a></li><li><a href=#427-dram_tcycle>4.2.7 dram_t::cycle()</a></li></ul></li></ul></li></ul></nav></div></nav></div></main><footer id=footer class=site-footer><div class=social-icon-links><a href=mailto:huwm1@shanghaitech.edu.cn rel="me noopener" class=social-icon-link title=email><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1451 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg>
</a><a href=http://localhost:1313 rel="me noopener" class=social-icon-link title=linkedin target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M872.405333 872.618667H720.768V635.008c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333.0-91.136 61.653333-91.136 125.397334v241.792H398.976V384H544.64v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667.0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667.0 01-88.021333-88.106666A88.064 88.064.0 11227.712 317.141333zm76.032 555.477334H151.68V384h152.064v488.618667zM948.266667.0h-872.704C33.792.0.0 33.024.0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667.0 948.138667.0h.128z"/></svg>
</a><a href=https://github.com/huweim rel="me noopener" class=social-icon-link title=github target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg>
</a><a href=https://www.zhihu.com/people/hu-wei-ming-31-86 rel="me noopener" class=social-icon-link title=zhihu target=_blank><svg aria-hidden="true" class="icon hi-svg-inline" fill="currentcolor" height="1em" viewBox="0 0 1024 1024" width="1em" xlink="http://www.w3.org/1999/xlink"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg>
</a><a href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=social-icon-link title=rss target=_blank><svg aria-hidden="true" class="lucide lucide-rss hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a>
</span><span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a>
</span><span class=copyright-year>&copy;
2020 -
2025
<span class=heart><i class=iconfont><svg aria-hidden="true" class="lucide lucide-heart hi-svg-inline" fill="none" height="1em" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="1em"><path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5.0 0016.5 3c-1.76.0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5.0 002 8.5c0 2.3 1.5 4.05 3 5.5l7 7z"/></svg>
</i></span><span class=author>Weiming Hu</span></span></div></footer><script type=text/javascript src=/js/main.eb94e793601239645bc98e36c443aef1b210646ccb43e2217ea949a0212e0ed1.js integrity="sha256-65Tnk2ASOWRbyY42xEOu8bIQZGzLQ+IhfqlJoCEuDtE=" crossorigin=anonymous></script><script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script><script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>