<!doctype html><html lang=en itemscope itemtype=http://schema.org/WebPage><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>LeetCode刷题记录 - Cory Code</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,user-scalable=yes"><meta name=MobileOptimized content="width"><meta name=HandheldFriendly content="true"><meta name=applicable-device content="pc,mobile"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=mobile-web-app-capable content="yes"><meta name=author content="Cory"><meta name=description content="关键字检索 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有"><meta name=keywords content="Hugo,theme,jane"><meta name=generator content="Hugo 0.97.3"><link rel=canonical href=https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/><link rel=icon href=/favicon.ico><link rel=stylesheet href=/sass/jane.min.b3a8813c06e6d785beba22bf8264e174fa2cb3a396b22f9ba24e2c00c18aaf7f.css integrity="sha256-s6iBPAbm14W+uiK/gmThdPoss6OWsi+bok4sAMGKr38=" media=screen crossorigin=anonymous><meta property="og:title" content="LeetCode刷题记录"><meta property="og:description" content="关键字检索 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有"><meta property="og:type" content="article"><meta property="og:url" content="https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-03-16T08:59:50+08:00"><meta property="article:modified_time" content="2022-04-19T09:01:09+00:00"><meta itemprop=name content="LeetCode刷题记录"><meta itemprop=description content="关键字检索 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有"><meta itemprop=datePublished content="2022-03-16T08:59:50+08:00"><meta itemprop=dateModified content="2022-04-19T09:01:09+00:00"><meta itemprop=wordCount content="11928"><meta itemprop=keywords content="LeetCode,"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode刷题记录"><meta name=twitter:description content="关键字检索 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script>
<script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>Cory Code</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=mobile-menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li></ul></nav><link rel=stylesheet href=/lib/photoswipe/photoswipe.min.css><link rel=stylesheet href=/lib/photoswipe/default-skin/default-skin.min.css><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><header id=header class="header container"><div class=logo-wrapper><a href=/ class=logo>Cory Code</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/>Home</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/post>All posts</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/categories/>Categories</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/archives>Archives</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/tags>Tags</a></li><li class=menu-item><a class=menu-item-link href=https://huweim.github.io/about/>About</a></li></ul></nav></header><div id=mobile-panel><main id=main class="main bg-llight"><div class=content-wrapper><div id=content class="content container"><article class="post bg-white"><header class=post-header><h1 class=post-title>LeetCode刷题记录</h1><div class=post-meta><time datetime=2022-03-16 class=post-time>2022-03-16</time><div class=post-category><a href=https://huweim.github.io/categories/%E6%80%BB%E7%BB%93/>总结</a></div><span class=more-meta>11928 words</span>
<span class=more-meta>24 min read</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>Table of Contents</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><ul><li></li><li><a href=#常见-bug>常见 BUG</a></li><li><a href=#311>3.11</a></li><li><a href=#311-1>3.11</a></li><li><a href=#313>3.13</a></li><li><a href=#314>3.14</a></li><li><a href=#316>3.16</a></li></ul></li></ul></nav></div></div><div class=post-content><h4 id=关键字检索>关键字检索</h4><ul><li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。</li><li>知识点：题目所涉及到的大概知识点。</li><li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针</li><li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。</li></ul><h4 id=短板总结>短板总结</h4><ul><li>短板：二叉树，矩阵，DFS，BFS</li></ul><p>2022-04-15 17:28:42，BFS，DFS，二叉树 稍微熟练了一些；目前的短板</p><ul><li>DP，堆，矩阵</li></ul><h3 id=常见-bug>常见 BUG</h3><h5 id=1-itoa>1. itoa</h5><p>gcc error : undefined reference to `itoa'</p><p>原因：itoa is a non-standard function which is supported by some compilers. Going by the error, it&rsquo;s not supported by your compiler. Your best bet is to use snprintf() instead.</p><h3 id=311>3.11</h3><h4 id=查缺补漏>查缺补漏</h4><ul><li>二叉树建树</li><li>二叉树后序遍历</li></ul><h3 id=311-1>3.11</h3><h5 id=jz03>JZ.03</h5><p>3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；</p><p>第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)</p><p>第三种原地Hash，鸽巢原理。源于一个条件 <code>element value &lt; nums.size()</code>，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)</p><p><strong>知识点</strong></p><ul><li>vector 可以用下标索引</li><li>标签：hash，排序，数组</li></ul><h5 id=jz04-二维数组中的查找->JZ.04 二维数组中的查找 ❌</h5><p>感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)</p><p>并非 DP，没有秒这题；主要是思路上的解法而非常规算法</p><blockquote><p>从右上角开始比较，比它大就往下数一行，比它小就往左数一列</p><p>二分查找也是解法之一</p></blockquote><p><strong>知识点</strong></p><ul><li>二维 vector 能否用下标索引？<ul><li>可以</li></ul></li><li>标签：数组，二分查找，分治，矩阵</li></ul><h5 id=jz05-替换空格>JZ.05 替换空格</h5><p>简单的字符串替换，被 string 和 char，"" 和 &rsquo;&rsquo; 的一些知识卡了一会儿。</p><p><strong>知识点</strong></p><ul><li>字符串裁剪 <code>str.substr(pos, len)</code>，</li><li>⚠️ 字符串比较；string 可以直接用 <code>==</code>，但是注意 s[0] 是 char 型；所以 <code>s[0] == " "</code> 会报错，应该是 <code>s[0] == ' '</code>；或者 <code>strcmp(s[0], ' ');</code></li><li>注意 "" 和 ''</li><li>❗ 为什么不能用 strcmp？<ul><li>用 <code>strcmp(string , string)</code> 会就报错；使用 <code>strcmp(char [], char[])</code> 就可以了；有什么区别？</li><li>string 是一个 managed type，不用担心有多长；char[] 分配的长度固定</li></ul></li></ul><h5 id=jz06-反转链表><strong>JZ.06 反转链表</strong></h5><p>从尾到头打印链表，单链表</p><p>自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$</p><p>也可以使用 递归</p><p>⚠️ 注意边界条件，基本每次 case 都会有</p><p><strong>知识点</strong></p><ul><li>单向链表；指针；vector</li><li>标签：栈，链表，递归，双指针</li></ul><h3 id=313>3.13</h3><h5 id=jz07-重建二叉树->JZ.07 重建二叉树 ❌</h5><p>二叉树和链表的数据结构要记住。</p><p>如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解</p><p>In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。</p><p>❌ 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。</p><p>pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size</p><p><strong>知识点</strong></p><ul><li>前序遍历列表：第一个元素永远是 【根节点 (root)】</li><li>中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】</li><li>做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end</li><li>标签：数组，hash，分治，二叉树</li></ul><h5 id=jz09-用两个栈实现队列>JZ.09 用两个栈实现队列</h5><p>自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。</p><p>更好的思路：其实不用再把 stack_2 中全部倒回 stack_1</p><p><strong>知识点</strong></p><ul><li>栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？<code>stack&lt;int> stk; queue&lt;int> q;</code></li><li>两个栈实现队列</li><li>标签：栈，队列</li></ul><h5 id=jz10-斐波那契数列-dp>JZ.10 斐波那契数列 DP</h5><p>自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归</p><p>更好的思路：这题可以用 DP，没有想到。</p><p>现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；</p><p>转移方程：$dp[i+1] = dp[i] + dp[i-1]$</p><p>初始状态：$dp[0] = 0; dp[1] = 1$</p><p>返回值：$dp[n]$</p><p><strong>知识点</strong></p><ul><li>查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路</li><li>标签：DP</li></ul><h5 id=jz11-青蛙跳台阶>JZ.11 青蛙跳台阶</h5><p>自己的思路：hash 递归；DP</p><p>和上一题很类似，写的是优化空间后的 DP，</p><p>✔️ 要求自己写一个常规的 DP 加深理解</p><p><strong>知识点</strong></p><ul><li>DP</li></ul><h5 id=jz11-旋转数组的最小数字->JZ.11 旋转数组的最小数字 ❌</h5><blockquote><p>这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的</p></blockquote><p>确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。</p><p><strong>知识点</strong></p><ul><li>标签：二分查找，数组</li><li>查缺补漏：二分查找熟练度不够</li></ul><h3 id=314>3.14</h3><h5 id=jz12-矩阵中的路径->JZ.12 矩阵中的路径 ❌</h5><p>自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$</p><p>题解 DFS，DFS 已经非常生疏了</p><p>看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。</p><p><strong>知识点</strong></p><ul><li>典型的矩阵搜索问题</li></ul><h5 id=jz13-机器人运动范围>JZ.13 机器人运动范围</h5><p>这个也是算法设计课程中出现的考试题目。</p><p>自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。</p><p>写错了一句 <code>tag[i][j] == -1;</code>，报错居然是 <code>stackoverflow</code>，要注意尽量一次写出 bug-free code。</p><p>题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵</p><p><strong>知识点</strong></p><ul><li>和上一题类似，也是矩阵，DFS还是可以用。</li><li>标签：<strong>DP</strong>，BFS，DFS；DP 体现在哪？了解 DP 的解法</li></ul><h5 id=jz14-i-剪绳子->JZ.14-I 剪绳子 ❌</h5><p>自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$</p><p>更好的思路：</p><p><strong>DP</strong></p><ul><li>求长度为 n 的绳子剪掉后的乘积，从 &lt;n 的绳子转移而来</li><li><code>dp数组</code> 记录 <code>0到n</code> 的绳子的最大乘积，初始化 <code>dp[2] = 1</code></li><li>剪掉第一段，长度为 j，j > 1</li><li>剪了第一段，剩下长度为 <code>(i - j)</code> 可以剪或者不剪。不剪的话 <code>length = j * (i - j)</code>；剪了的话 <code>length = j * dp[i - j]</code>；<code>max(j * (i - j), j * dp[i - j])</code></li><li>遍历 j，$j \in [2, i)$，取最大值。</li></ul><p>难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。</p><p><strong>2022-03-16 10:38:06</strong>，尝试写一下 DP 解法 ✔️。DP 和自己的思路性能差不多。</p><p><strong>贪心</strong></p><ul><li>均值不等式思想；n > 4 时，尽可能把绳子分为长度为 3 的小段，进行乘加。</li></ul><h3 id=316>3.16</h3><h5 id=jz14-ii-剪绳子>JZ.14-II 剪绳子</h5><p>在 I 的基础上加了一个答案取模，取模对于加法没有影响，~~但是会影响乘法的计算结果。~~并没有，那么这题在考察什么？</p><p>这个题目就是考察贪心的解法，如果继续用 DP，应该会超时</p><h5 id=jz15-二进制中1的个数>JZ.15 二进制中1的个数</h5><p>考察位运算。</p><p>自己的思路：比较基础的 $/2%2$ 进行二进制化，时间复杂度 $O(logn)$，可以AC。bitset</p><p>更好的思路：$n&(n-1)$，$n-1:$ 二进制数字 $n$ 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1；$n&(n - 1):$ 二进制数字 $n$ 最右边的 1 变成 0 ，其余不变。时间复杂度 $O(M)$，M 为 1 的数量</p><p><strong>知识点</strong></p><ul><li>标签：位运算</li></ul><h5 id=jz16-数值的整数次方->JZ.16 数值的整数次方 ❌</h5><p>自己的思路：计算 $pow(x, n)$，naive 直接乘 $n$ 次，时间复杂度 $O(n)$，会超时，因此需要的不是 $O(n)$ 的解法。好像和复杂度没有关系，注意 $n$ 的范围，涉及越界的问题。</p><blockquote><p><del>我认为这个应该就是考察 INT 型表示范围的细节，尤其是 $n = 0 - n$ 这种写法会越界</del>。看来并非如此</p></blockquote><p>处理了越界仍然会超时，用 $x$ 的范围去换 $n$ 的范围。这样并没有降低时间复杂度的数量级，304 case 全过但是仍然超时。因此猜测 $O(n)$​ 的解法 A 不了。加了一个判断 <code>if(x &lt; 0.000005) return x * init_x;</code> 后 AC 了，因为输出只保留到小数点后 5 位，有点取巧，虽然 AC 但是可能没有满足这道题的考察意图。⚠️ 这个取巧做法不能算真正的 AC。</p><p><strong>更好的解法</strong>：确实有 $O(logn)$ 的解法，<strong>快速幂</strong>。快速幂也就是在循环中递归地使用你只用了一次的降幂操作，每次可以降幂的时候，$x *= x, n &#187;= 1$，这样将复杂度降至 $O(logn)$</p><p><strong>知识点</strong></p><ul><li>$(-3) % 2$，余数是 1 还是 -1？答案：余数是 -1</li><li>标签：递归，数学</li></ul><h5 id=jz17-打印从1到最大的n位数>JZ.17 打印从1到最大的n位数</h5><p>自己的思路：遍历，时间复杂度 $O(10^n)$，直接 A，意义在哪？评论区有人说原题目是要考虑大数越界问题的。因此，这道题的本意应该是考察字符串和整型数字的转换。</p><p>先放一下</p><blockquote><p>若不考虑大数问题，则十分简单一个从1到最大数的循环即可。 若考虑大数问题，则首先需要将数字转成字符串避免溢出，然后全排列字符串的第0位到第n-1位。 存储结果时需去掉字符串前几位的0(0099没有意义，应为99)再放入结果。</p></blockquote><p><strong>知识点</strong></p><ul><li>标签：数组（越界，大数），字符串</li></ul><h5 id=jz18-删除链表的节点>JZ.18 删除链表的节点</h5><p>自己的思路：最简单的单链表删除，时间复杂度 $O(n)$，AC。</p><p><strong>知识点</strong></p><ul><li>标签：链表</li></ul><h5 id=jz20-表示数值的字符串>JZ.20 表示数值的字符串</h5><p>这个题是有实用性的，也许在某些爬虫提取数据的时候会用到。</p><p>自己的思路：就是用条件判断筛选出不合规的情况 <code>return false</code>，第一次以为空格直接删除就行，提交后发现空格不能出现在有效符号的中间。</p><p>提交 23 次 AC，基本就是看着 case 补条件，完全没有周全考虑，没有使用正则表达式思想。</p><p><strong>知识点</strong></p><ul><li>标签：字符串，有限状态机</li></ul><h5 id=jz21-调整数组顺序使奇数位于偶数前面>JZ.21 调整数组顺序使奇数位于偶数前面</h5><p>自己的思路：两次遍历，$O(n)$，AC，有没有复杂度更低的解法？</p><p>题解的思路：也是 $O(n)$ 复杂度，但只用遍历一次，双指针，类似快排的思路。分别从左右开始遍历，然后交换。稍快一点。</p><p><strong>知识点</strong></p><ul><li>标签：数组，双指针，排序</li></ul><h5 id=jz22-链表中倒数第k个节点>JZ.22 链表中倒数第k个节点</h5><p>自己的思路：打印倒数的节点，所以遍历两次，第一次确定链表长度 L，L - k 次 next 就可以找到目标结果，然后返回，AC，时间复杂度 $O(n)$</p><p>更好的解法：双指针，无需统计链表的长度。前指针先走 $k$ 步，然后共同移动，前指针到终点时返回后指针即可，时间复杂度 $O(n)$</p><p><strong>知识点</strong></p><ul><li>标签：链表，双指针</li></ul><h5 id=jz24-反转链表>JZ.24 反转链表</h5><p>自己的思路：一次遍历，forward 指针在前，head 自己在后，一遍遍历一边调整，AC，时间复杂度 O(n)。</p><p>❌ 注意边界条件，注意条件判断时写了 <code>if(head->next == NULL || head == NULL)</code>，报错。因为当 head==NULL，是找不到 head->next，自己写代码不要忽略边界和细节。</p><p>题解：除双指针，还有递归的解法，时间空间都是 $O(n)$</p><p><strong>知识点</strong></p><ul><li>标签：递归，链表</li><li>关于递归，心中要有明确的终止条件的概念。</li></ul><h5 id=jz25-合并两个递增排序的链表>JZ.25 合并两个递增排序的链表</h5><p>自己的思路：非常基础的算法题，一次遍历，其中一个链表完成遍历后直接接过去。最初出现错误的原因：遍历的时候 <code>l2 = l2->next</code>，忘记保存头结点。</p><p>一开始的合并写法没有 AC，逻辑有点混乱了，后来直接换了一种写法，新建了一个链表，比较耗费空间，时间复杂度 $O(m+n)$，空间复杂度 $O(m+n)$。</p><p><strong>知识点</strong></p><ul><li>标签：递归，链表</li><li>引入 <strong>伪头结点</strong> 合并链表是本题的最优解</li></ul><h4 id=317>3.17</h4><h5 id=jz26-树的子结构->JZ.26 树的子结构 ❌</h5><p>又到了短板，二叉树相关的题目。</p><p>自己的思路：是否会有一段完全相同的中序遍历？中序遍历能否唯一确定？手写中序遍历 DFS，大概的还记得，有些地方比如 visied，还有判断条件（only care left）疏忽了，但是很快能想起来。Value 还存在负数，那么只能前序也 check 一次了。</p><p>check 了一次前序一次中序，但是还是 AC 不了，说明一开始的思路可能有点问题。写出了前序和中序，但是没法 AC，思路是错的。</p><p>更好的解法：遍历 A 树中的每个节点 $n_A$，判断以 $n_A$ 为根节点的字数是否包含 B。状态一般，没有自己手写题解，之后再熟悉一遍。</p><p><strong>知识点</strong></p><ul><li>标签：树，DFS</li></ul><h5 id=jz27-二叉树的镜像>JZ.27 二叉树的镜像</h5><p>自己的思路：简单递归。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，由递归栈的深度决定.</p><h5 id=jz28-对称的二叉树->JZ.28 对称的二叉树 ⚠️</h5><p>自己的思路：一开始直接指针指向 root，翻转二叉树，比较，忽略了只是指针指向了 root，没有保留翻转前的树。后来分别使用递归建树、翻转、比较，AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p>更好的思路：一次递归，无需求镜像。递归地比较左右子树是否相等即可</p><p><strong>知识点</strong></p><ul><li>这个题用到和复习的知识点比较多，包括建树。翻转二叉树，比较</li><li>标签：二叉树，BFS，DFS</li></ul><h5 id=jz29-顺时针打印矩阵>JZ.29 顺时针打印矩阵</h5><p>自己的思路：没考虑算法，用循环每次 push 边界上的几组数，然后不断地更新边界条件，直到所有数都 push 进去。注意边界条件。AC，时间复杂度 $o(mn)$，空间复杂度 $O(mn)$。</p><p>题解：和 K 神题解的思想差不多。</p><p><strong>知识点</strong></p><ul><li>数组，矩阵，模拟</li></ul><h5 id=jz30-包含-min-的栈>JZ.30 包含 min 的栈</h5><p>自己的思路：用 vector 实现，push 的时候对比一下记录 min 即可，关于 vector 的指定 index 删除有点忘记了。<code>v.erase(pos)</code>。噢，不过突然想起 stack 是先进后出，那么直接 <code>v.pop_back()</code> 删掉最后一个即可。不过为了更加造轮子，还是不用 STL 了吧，用数组好了。</p><p>还有一个细节，还需要额外保存一个次小值，当 min pop 时需要用次小值顶上。次小值还不够，应该用一个数组记录不同 stack size 时的 min，空间换时间。</p><p>❗ 细节：栈空时要重置 min。</p><p>题解：很多题解都是用辅助栈，不过这题个人主要是尝试用数组求解。</p><p><strong>知识点</strong></p><ul><li>关于 vector 的指定 index 删除。<code>v.erase(pos)</code>。</li></ul><h5 id=jz31-栈的-push-pop-顺序>JZ.31 栈的 push, pop 顺序</h5><p>也是经典的算法考题，给一个 push 顺序和 pop 顺序，判断 pop 顺序是否有可能是该 push 顺序下的一个 pop 结果。</p><p>自己的思路：插 pop，给出所有可能性然后对比，这样复杂度有点太夸张了。加一点数学思路来优化，假设 push 序列是顺序的，如果 4 pop，那么 4 之后 &lt;4 的元素出栈时一定不可能是升序，比如 1，2，3；推理到元素 i 出栈，之后 $&lt;i$ 的元素出栈序列一定是降序排列。</p><p>不一定是顺序输入，所以可能需要用 hash 转换一下。hash 转换得费点脑子，找找经典的理解方法。注意细节，mmax 更换时 slide_min 便作废了。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，用了额外的 hash 空间排序。</p><p>题解：这个题其实蛮有意思，题解完全是另一种做法，自己是利用一些数学/算法上的特征解的。根据 push 序列模拟入栈操作，当栈顶元素 <code>top() == popped[i]</code> 时出栈元素，i++，push 操作完成观察栈是否空即可。</p><p><strong>知识点</strong></p><ul><li>标签：栈，数组，模拟</li><li>自己使用到了 hash 思想；栈的基本知识；栈空时调用 s.top() 会报错</li></ul><h5 id=jz32-ii-从上到下打印二叉树>JZ.32-II 从上到下打印二叉树</h5><p>自己的思路：线序遍历，根据 height 来决定 push 到哪一行。其中遇到了 vector 初始化的问题，不初始化没办法直接 <code>v[height].push_back(root->val)</code>，先根据上限 <code>v.resize(1000)</code>，遍历结束后根据深度 <code>v.resize(height+1);</code> 即可。时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p><strong>知识点</strong></p><ul><li>二维 vector 初始化<ul><li><code>v.resize(4); v[0].resize(4);</code></li><li><code>vector&lt;vecotr&lt;int>> v(m, vector&lt;int>(n, 0))</code>; m 行 n 列全部初始化为0</li></ul></li></ul><h5 id=jz32-iii-从上到下打印二叉树>JZ.32-III 从上到下打印二叉树</h5><p>和上题区别在于，第一层从左到右打印，第二层从右到左打印，没法先序遍历直接解。</p><p>自己的思路：vector 是否自带 reverse？正好复习一下，<code>reverse(v.begin(), v.end());</code>，AC。</p><p>不过有评论说这是经典面试0分方法 😓，那认真学习下题解思路。</p><p><strong>知识点</strong></p><ul><li>标签：树，BFS</li><li>reverse()</li></ul><h4 id=318>3.18</h4><p>2022-03-17 22:45:21，先把两道树的题方法搞了。贪心和 DP 是薄弱点，后期要加强。</p><h4 id=319>3.19</h4><h5 id=606-construct-string-from-binary-tree-每日一题>606. Construct String from Binary Tree 每日一题</h5><p>这道题中文描述简直是 bullshit，还没给范围，之后直接看英文好了。这道题应该是简单吗？虽然确实不太难但是东西还蛮多，涉及先序遍历，数字转字符串等等。</p><p>自己的思路：先序遍历，数字转字符串，可以省略空子树的括号，省略右子树为空仅有左子树时的括号。时间复杂度 $O(n)$</p><p><strong>彩蛋</strong>：2020.04.02 AC过，当时直接用的 <code>to_string()</code>，记一下这个函数。不知道当时是不是看的题解，那个时候写的解法更好一点~</p><p><strong>知识点</strong></p><ul><li>树，DFS，字符串</li></ul><h4 id=320>3.20</h4><h5 id=jz33-二叉搜索树的后序遍历->JZ.33 二叉搜索树的后序遍历 ❌</h5><p>一开始看题目描述蒙了，没有理解其意思。原来是忽略了二叉搜索树这个条件，太久没有接触到所以生疏了，也就是左孩子 value 小于当前节点，右孩子 value 大于当前节点。</p><p>自己的思路：后序遍历建树，后序遍历不能唯一确定，不过二叉搜索树好像是完全二叉树？这点得确认一下，先按照这个假设。然后判断建好的树是否满足搜索树的概念。</p><p>注意：循环中，<code>it</code> 不能回到 begin，因为 begin 位置上可能还有之前跳过的数字，留在当前位置即可。出现了意料之外的 case，所以搜索树不一定是完全二叉树？确实如此。</p><p>题解思路：遍历顺序 左右根。这个思路之前有想过。后续遍历区间$[i,j]$，遍历划分左右子树区间，找到第一个大于 root 的元素 index $m$，左子树区间 $[i, m-1]$，右子树区间 $[m,j-1]$，递归判断子树的合法性即可。</p><p><strong>知识点</strong></p><ul><li>vector：可以使用迭代器作为 <code>v.erase(pos)</code> 中的 pos 进行删除；删除后 <code>v.size()</code> 会发生变化.</li><li>二叉搜索树的概念，正是因为记错了所以思路出现了问题。</li><li>后续遍历的性质，左右根，左右子树的区间</li><li>标签：栈，树，二叉搜索树，递归，单调栈</li></ul><h4 id=326>3.26</h4><h5 id=jz-19-正则表达式匹配->JZ. 19 正则表达式匹配 ❌</h5><p>自己的思路：考虑所有情况，硬配。写了一个多小时还是考虑不全所有情况，这是一种冗余分类的思路，还没有概括完所有情况。遂看题解，发现原来这也能DP。</p><p>题解的思路：拆分子问题</p><ul><li>B 的最后一个字符为正常字符串， 比较 $A_{n-1}$ 和 $B_{m-1}$，如果相等则继续比较 $A_{0..n-2}$ 和 $B_{0..m-2}$，不相等则返回 false</li><li>如果 B 的最后一个字符串为 <code>.</code>，则比较 $A_{0..n-2}$ 和 $B_{0..m-2}$</li><li>如果 B 的最后一个字符串为 <code>*</code>，则 $B_{m-2} = c$ 可以重复0次或多次<ul><li>case 1：$A_{n-1}$ 是0个c，舍弃 B 中的 <code>c*</code>，比较 $A_{0..n-1}$ 和 $B_{0..m-3}$</li><li>case 2：$A_{n-1}$ 是多个c中的最后一个，比较 $A_{0..n-2}$ 和 $B_{0..m-1}$</li></ul></li></ul><p><strong>转移方程</strong></p><p>$f[i][j]$ 代表 A 的前 $i$ 个和 B 的前 $j$ 个能否匹配</p><ul><li>对于前两种情况可以进行合并，$f[i][j] = f[i-1][j-1]$<ul><li>第三种情况，$f[i][j] = f[i][j-2]$，case 2: $f[i][j] = f[i-1][j]$</li></ul></li></ul><p><strong>初始条件</strong></p><ul><li>空串和空正则可以匹配，$f[0][0] = true$</li><li>空串和非空正则，需要判断</li><li>非空串和空正则，不匹配，$f[1][0]&mldr;f[n-1][0]=false$</li><li>非空串和非空正则，需要判断</li></ul><p>看题解后自己写：没有正确理解，不是倒着来的，本质上还是正常动态规划的求解过程。用的是</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;</span> n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不需要双指针同步推进</p><p>2022-03-27 10:22:03，有点绕，之后再来一遍，看懂了再自己写</p><h5 id=jz-35-复杂链表的复制>JZ. 35 复杂链表的复制</h5><p>自己的思路：先通过<del>递归遍历原链表</del>，修改了一下，实际无需递归，直接遍历即可。此时 random 指针还没有赋值。第二次遍历复制链表，用 traver_cpoy 指针一一为每个节点找 random 指针应该指向的节点。怎么找？双指针一同遍历 init 链表和 copy 链表，当 init 链表到达当前节点的 random 后停止，copy 指针也跟着停止，此时 copy 指针的位置就是 traver_copy 指针节点的 random 节点。AC，时间复杂度 $O(n^2)$。</p><p>更好的思路：hash map 映射，这个能够加深对于 hash 的应用上的理解。第一次遍历构造新节点时，以 hash 的形式存下 init 和 copy 对应节点的指针 <code>map&lt;*Node, *Node> hash_m</code>，第二次遍历构造 copy 链表的 random，init 指向 <code>head->random</code>，通过 <code>head->random</code> 以及 hash，可以查找到 copy random <code>hash_m[head->random]</code>，<code>copy->random = hash_m[head->random]</code>。时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p><strong>知识点</strong></p><ul><li>注意复制链表需要新建节点，<code>Node* tmp = new Node(val);</code>，不然指针连接到之前的链表上，就违背了复制的意图。</li><li>原来这个就是<strong>深拷贝</strong>的一个例子</li><li>标签：hash，链表</li></ul><h5 id=jz-36-二叉搜索树与双向链表>JZ. 36 二叉搜索树与双向链表</h5><p>自己的思路：刚学的 hash 的思想似乎可以用上。中序遍历把节点的指针存入数组 <code>vector&lt;Node*> ans</code>，此时 ans 中的指针是有序的。遍历 ans 数组，重新调整节点 <code>left</code> 和 <code>right</code> 指针的指向即可。AC。</p><p>和题解思路一致</p><p><strong>知识点</strong></p><ul><li>栈，DFS，二叉树，双向链表</li><li>主要是利用了 二叉搜索树 中序遍历后有序的性质</li></ul><h5 id=jz37-序列化二叉树>JZ.37 序列化二叉树</h5><p>序列化函数：也就是将二叉树以 string 的形式存起来。反序列化函数：将 string 构造为二叉树</p><p>自己的思路：想到的还是 hash 的形式，把节点的指针存下来。得到了中序和前序遍历的序列，然后就是根据中序和前序遍历建树</p><p>2022-03-31 22:13:41 的思路：有什么东西不重复呢？一开始想到了随机数，但是其实还有有风险，地址应该是不重复的。注意索引越界的问题</p><p>建树：注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。忘了加参数 inorder_left 和 inorder_right</p><p><strong>知识点</strong></p><ul><li>整型转字符串：<code>itoa(int num, char* str, int radix)</code></li><li>字符串，<code>char str = 'a'; str += 1</code>，可以直接加整型，此时 <code>str = 'b';</code></li><li>map 如何通过 value 查找 key</li></ul><h4 id=331>3.31</h4><h5 id=728-自除数-每日一题>728. 自除数 每日一题</h5><p>每日打卡，简单题，没什么亮点。</p><h4 id=43>4.3</h4><h5 id=每日一题>每日一题</h5><h5 id=jz38-字符串的排序->JZ.38 字符串的排序 ❌</h5><p>自己的思路：双重循环，swap，set来去重。时间复杂度 $O(n^2)$。❌这种方法覆盖不了所有情况。20分钟没有思路</p><p>题解的思路：递归回溯填空位的思想。递归回去时，使用过的字符串标记也会回溯。</p><p><strong>知识点</strong></p><ul><li>❗ 本以为把 visit 数组当做参数传进去，return 的时候自动回溯，没想到也需要手动回溯。</li><li>突然想起来，要用引用传参。也不全是，只是突然想起来引用传参这个知识点。</li></ul><h5 id=jz39-数组中出现次数超过一半的数字>JZ.39 数组中出现次数超过一半的数字</h5><p>自己的思路：这个题之前应该是遇到过。最直接的方法就是遍历然后填充 hash 表，之后简单地判断，时间复杂度 $O(n)$，空间复杂度 $O(n)$。印象中有时间复杂度更低的解法，分治的思想之类的。想起来是排序之后找中间那个元素，<del>时间复杂度 $O(logn)$</del>,oh，原来排序的时间复杂度是 $O(nlogn)$</p><h5 id=jz40-最小的k个数->JZ.40 最小的k个数 ❌</h5><p>自己的思路：排序后遍历，这样做没有意义，直接看题解。</p><p>题解：基于快排的特点。快排时每次都能把 pivot 放在他最终的位置。当结束一次快排，pivot 正好在 $index_k$ 时，返回数组的前 $k$ 个数即可。</p><p>对快排特点的应用。</p><p>❌ 忘记了快排的写法，这个题卡了1个小时的原因，在于你完全不会手写快排。如同上次蔚来面试答不出快排一样。</p><p><strong>知识点</strong></p><ul><li>看了题解之后还是折腾了1个小时；完全是因为快排写错了。</li></ul><h4 id=44>4.4</h4><h5 id=307->307 ❌</h5><p>线段树、树状数组踩坑，明天来学习</p><p>自己的思路：用一个 hash，<code>hash[i]</code> 存的是数组前 <code>i+1</code> 个元素之和，查找时复杂度为 $O(1)$，update 时复杂度为 $O(n)$，这个级别的复杂度达不到要求，需要更好的方法。遂看题解。</p><p>题解思路：分块处理，把时间复杂度优化到 $O(\sqrt{n})$；线段树，其实就是把一个完整的区间划分，左右子树分别是根节点的子区间。树节点保存的值为区间内的元素和，线段树看下图会很清晰。首先根据区间建树，用堆来存储更好。递归回退的时候计算每个节点的 val（也就是区间和），这个思路值得学习。</p><p>2022-04-05 14:17:41，做得一团 bullshit，又浪费了一个小时，坑还是剩下，不要抄代码强行提交，先去写论文了。</p><p><strong>知识点</strong></p><ul><li>vector 还可以不使用 push，直接 index 吗？</li></ul><h4 id=45>4.5</h4><h5 id=762>762</h5><p>自己的思路：判断质数函数一个，对于整数<code>num</code>，从 2 遍历到 <code>num/2</code>，没有整除就是质数，时间复杂度 $O(n)$；统计 bit 为1数量的函数，移位并计数，时间复杂度 $O（logn）$。AC</p><h5 id=5-最长回文子串>5. 最长回文子串</h5><p>经典DP</p><p>自己的思路：秒不了，想不出DP，直接题解。</p><p>题解：中心扩散法，这个比较好理解，主要是来学习DP。</p><blockquote><p>动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。</p></blockquote><h5 id=每日-310-最小高度树>每日 310. 最小高度树</h5><p>自己的思路：就是找一个节点，遍历所有节点的深度最小。建表之后dfs，写出了dfs解法，超时，需要优化。还是超时，遂先放弃。</p><h4 id=415>4.15</h4><h5 id=jz41-数据流中的中位数>JZ.41 数据流中的中位数</h5><p>自己的思路：这道题的瓶颈在于排序，无论是插入时排序，还是找中位数时排序，如果每次 call 都进行一次排序，一定会超时。也许需要一颗平衡二叉排序树，把插入时排序的开销降低到 $O(logn)$。</p><p>以为需要建堆，看题解之后AC。但是直接用的现成的优先队列，并且是看的题解，这道题几乎没有自己想的部分。</p><p>题解：大顶堆，小顶堆。小顶堆 A 保存较大的一半数据（size = m），大顶堆 B 保存较小的一般数据（size = n）。插入时优先插入到 A，即：</p><p>m = n，把新元素加到 A：把新元素 num 插入 B，再将 B 的堆顶插入 A。查找：返回 A 和 B 的堆顶之和 / 2</p><p>m != n，把新元素加到 B：把新元素 num 插入 A，再将 A 的堆顶插入 B。返回 A 的堆顶</p><p>为什么用优先队列实现大顶堆？什么事优先队列？优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。</p><p><strong>知识点</strong></p><p>C++中的优先队列实现。不过要注意，直接用现成的轮子，建堆的过程其实还是不会的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>priority_queue<span style=color:#f92672>&lt;</span>Type, Container, Functional<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//升序队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>priority_queue <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>,greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span><span style=color:#75715e>//降序队列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>priority_queue <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>,vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>,less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span>q;
</span></span></code></pre></div><ul><li>堆（优先队列），数据流，排序，双指针</li></ul><h5 id=jz42-连续子数组的最大和>JZ.42 连续子数组的最大和</h5><p>自己的思路：经典的DP来了，练习DP的机会来了。这个似乎就是那位同学说的商汤2面的编程题。dp[i] 存放以 index i 为右边界的数组的最大和。</p><p>2022-04-15 18:03:47，果然没有想出来，和我自己想的不太一样。写 dp 方程的时候没考虑到需要连续这一特性。要接受自己的愚蠢，看答案。</p><p>思路绕进去了，一直在想 dp[i] 小于0不一定不能加；实际上自己想的是 nums[i] 小于0不一定不能加。而 dp[i] 如果小于0，说明以 i 为右边界的数组的连续子数组最大和为负数，故可以直接舍弃。</p><p><strong>知识点</strong></p><ul><li>数组，分治，DP</li></ul><h5 id=jz43-1n-整数中-1-出现的次数>JZ.43 1～n 整数中 1 出现的次数</h5><p>自己的思路：首先尝试暴力的方法，遍历，把int转为char，统计1的数量。itoa 还是用不了，找到了替代，sprintf。暴力法必然超时，打表应该是通过的方法之一，这样需要预处理。没有使用打表的方式，以10000为步长来计算。一次AC，nice（2022-04-15 20:44:01），虽然这道题可能算不上困难。</p><ul><li>递归，数学规律，DP</li></ul><h5 id=jz44-数字序列中某一位的数字->JZ.44 数字序列中某一位的数字 ❌</h5><p>自己的思路：实际上就是构造这个序列化字符串。这个字符串长度大于n时跳出即可。承接上一题，还是继续使用 sprintf。atoi 格式忘记了。</p><p>2022-04-16 19:50:05，先放一放，往后做</p><h4 id=416>4.16</h4><h5 id=jz45-把数组排成最小的数->JZ.45 把数组排成最小的数 ❌</h5><p>自己的思路：排序后遍历，因为数字都是100以内，先拼接小的即可，拼接22之前先拼接2，拼接33之前先拼接3。晕，看错条件了，说的是 nums 长度小于 100。</p><p>没有A，看题解了。这道题也是有一些数学的规律，自定义字符串的排序规则。字符串排序规则，若 $x + y > y + x$，说明 y 应该放在左边。</p><p>除了 sprinft，还可以用 to_string(INT);</p><h4 id=417>4.17</h4><h5 id=jz46-数字翻译成字符串>JZ.46 数字翻译成字符串</h5><p>自己的思路：感觉是一个标准的 DP 问题。判断两数是否能组合时，要注意一些边界条件上的细节。时间复杂度 $O(n)$。实际上就是青蛙跳台阶的思路。</p><p>2022-04-17 22:10:46，成功AC。这个是刷 LeetCode DP 问题的一个里程碑。标志着你也许能够独立做出一些 DP 问题了。</p><p>初始状态：以 0 结尾的字符串，有1种翻译</p><p>状态：以 i 结尾的字符串，有多少种翻译；~$dp[i] = dp[i-1] + 1（单加一个） + if_combined$~ （i 和 i - 1 是否能够组合在一起）。
应该没有这个 +1，并非叠加，$dp[i] = dp[i-1] + if_combined$</p><p><strong>知识点</strong></p><ul><li>个人认为关于 DP，有个很关键的地方是，从初始态出发必须能够到达当前状态，他们是有桥梁的，因为每一步都伴随着信息的更新。</li></ul><h5 id=jz47-礼物的最大价值>JZ.47 礼物的最大价值</h5><p>自己的思路：感觉是一个和棋盘/二维数组相关的 DP 问题。边界问题补一层 padding，因为 value 非负，直接初始化为0即可。AC，比较简单的 DP 问题。</p><p><strong>知识点</strong></p><ul><li>数组，DP，矩阵</li></ul><h5 id=jz48-最长不含重复字符的子字符串>JZ.48 最长不含重复字符的子字符串</h5><p>自己的思路：最自然的是暴力法，遍历字符串，往后找其第一个重复的串，记录长度，时间复杂度 $O(n^2$。第一个思路有问题，这个思路不太行。明天来做，2022-04-17 23:39:50。</p><p>2022-04-18 11:51:19，AC，做了比较久，做了接近一个小时。总算绕通了其中的逻辑。自己用的应该是双指针遍历的方法，用 hash_map 存出现过的字符串，遇到重复时更新左边的指针，以及舍弃掉此重复字符串左边的字符串。</p><p><strong>知识点</strong></p><ul><li>标签：滑动窗口，字符串，hash</li></ul><h5 id=每日一题-819-最常见的单词>每日一题 819. 最常见的单词</h5><p>自己的思路：没什么思路，直接遍历，hash 表存出现的次数，大写转小写。我记得是有大小写转换的函数的，不过忘记了，手动转一下吧。ASCII 差值搞忘了，好像是32？可以建个表。确实是32，还算记得，不用建表了。AC，逻辑有点不清晰，花了大概30分钟。20年4月做过这道题。</p><h4 id=418>4.18</h4><h5 id=每日一题-386-lexicographical-numbers->每日一题 386. Lexicographical Numbers ❌</h5><p>自己的思路：要求时间复杂度 $O(n)$，也就是一次遍历。n &lt; 10 时直接返回 1-n，否则标记 1-9，后续遇到 1 开头的数就插入到 1 后面，然后标记，遇到 2 开头的数就插入到 2 后面，然后标记。不过 vector 插入的时间复杂度好像是 $O(n)$，这样的话整体就是 $O(n^2)$ 了。</p><p>15分钟没有思路，上题解。看了一部分评论之后有一个思路，应该将其转换为字符串，这样就无需考虑整数的顺序问题。</p><p>题解：迭代 DFS 的思想。对于数 number，加入数组，判断 $10*number \leq n$ 是否成立，如果成立则加入数组，并继续搜索（DFS）；如果不成立，判断 $number + 1$ 的情况，如果 number 的个位数为9（number 个位数1-9已经全部搜索过了）或者 number + 1 > n（DFS返回条件），则回退到上一层（number /= 10）</p><p><strong>知识点</strong></p><p>标签：DFS，前缀树</p><h5 id=jz49-丑数->JZ.49 丑数 ❌</h5><p>自己的思路：已知是一道DP。看题解</p><p>题解：核心思想是后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。在这个基础上可以使用最小堆，每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x2x,3x,5x 也是丑数，因此将 2x, 3x, 5x2x,3x,5x 加入堆，然后去重。</p><p>方法二：DP 三指针。令 $\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)$，被使用到的对应指针++。</p><p><code>dp[i] = min(min(n2, n3), n5);</code> 学到了</p><h4 id=419>4.19</h4><h5 id=每日一题-821字符的最短距离>每日一题 821.字符的最短距离</h5><p>自己的思路：第一次遍历记录字符的所有下标，第二次遍历找出当前字符 - 下标集合的最小值。时间复杂度最坏 $O(n^2)$。AC</p><p>更好的思路：两次遍历。从左往右，一边遍历一遍更新字符idx；从右往左再来一次。</p><p><strong>知识点</strong></p><ul><li><p><code>int ans[] = new int(len);</code> 写法有问题，注意是：<code>int *ans = new int[len]{0};</code>，一定是指针形式</p></li><li><p>vector 初始化：<code>vector&lt;int> ans(len);</code> 以及 <code>vector&lt;int> ans; ans.resize(len);</code></p></li></ul><h5 id=jz50-第一个只出现一次的字符>JZ.50 第一个只出现一次的字符</h5><p>自己的思路：hash，两次遍历。</p><p><strong>知识点</strong></p><ul><li>这道题有一个比较好奇的地方，map 中元素顺序是否是按加入的顺序；噢，map 似乎是自动排序的，根据 first 排序</li></ul><h5 id=jz51--数组中的逆序对->JZ.51 数组中的逆序对 ❌</h5><p>自己的思路：这是一个 hard 题，最自然的想法是暴力法，$o(n^2)$，很自然地，超时。换一种思路，DP，dp[i] 代表位置 i 之前有 dp[i] 个大于 nums[i] 的数。看题解</p><p>题解：归并排序和逆序对息息相关，归并排序体现了分治的思想。归并的同时顺便统计信息。</p><p>PS：着题解代码写得</p><p><strong>知识点</strong></p><ul><li>二分查找，归并排序，分治，树状数组，线段树</li></ul><h5 id=jz50-两个链表的第一个公共节点>JZ.50 两个链表的第一个公共节点</h5><p>自己的思路：题目要求尽量用时间复杂度 $O(n)$，空间复杂度 $O(1)$，</p></div><div class=post-copyright><p class=copyright-item><span class=item-title>Author</span>
<span class=item-content>Cory</span></p><p class=copyright-item><span class=item-title>LastMod</span>
<span class=item-content>2022-04-19</span></p><p class=copyright-item><span class=item-title>License</span>
<span class=item-content><a rel="license noopener" href=https://creativecommons.org/licenses/by-nc-nd/4.0/ target=_blank>CC BY-NC-ND 4.0</a></span></p></div><footer class=post-footer><div class=post-tags><a href=https://huweim.github.io/tags/leetcode/>LeetCode</a></div><nav class=post-nav><a class=prev href=/post/blog_hugo_%E6%96%87%E7%AB%A0%E6%89%89%E9%A1%B5%E8%AE%BE%E7%BD%AE/><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417l277.93508-310.326815c11.338233-12.190647 11.035334-32.285311-.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"/></svg></i><span class="prev-text nav-default">Hugo 文章扉页设置</span>
<span class="prev-text nav-mobile">Prev</span></a>
<a class=next href=/post/%E5%B7%A5%E5%85%B7_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/><span class="next-text nav-default">tmux: Linux 下终端复用</span>
<span class="prev-text nav-mobile">Next</span>
<i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="18" height="18"><path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697c-11.777231-11.500939-30.216186-10.304694-41.178865 2.712784z"/></svg></i></a></nav></footer></article></div></div></main><footer id=footer class=footer><div class=icon-links><a href=mailto:huwm1@shanghaitech.edu.cn rel="me noopener" class=iconfont title=email><svg class="icon" viewBox="0 0 1451 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M664.781909 681.472759.0 97.881301C0 3.997201 71.046997.0 71.046997.0H474.477909 961.649408h399.992405s71.046998 3.997201 71.046998 97.881301L771.345323 681.472759S764.482731 685.154773 753.594283 688.65053V688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858V688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759zm53.281707 130.131124C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633.0 212.052267.0 212.052267V942.809523S0 1024 83.726336 1024H682.532949 753.579947h595.368192C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523V212.052267S893.138176 701.759633 817.019477 767.734955c-39.771477 34.470494-74.671786 43.295855-98.955861 43.868928z"/></svg></a><a href=http://localhost:1313 rel="me noopener" class=iconfont title=linkedin target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="33" height="33"><path d="M872.405333 872.618667H720.768V635.008c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333.0-91.136 61.653333-91.136 125.397334v241.792H398.976V384H544.64v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667.0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667.0 01-88.021333-88.106666A88.064 88.064.0 11227.712 317.141333zm76.032 555.477334H151.68V384h152.064v488.618667zM948.266667.0h-872.704C33.792.0.0 33.024.0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667.0 948.138667.0h.128z"/></svg></a><a href=https://github.com/huweim rel="me noopener" class=iconfont title=github target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M512 12.672c-282.88.0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667.0-12.16-.426667-44.373333-.64-87.04C242.005334 929.664 211.968 830.08 211.968 830.08 188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333.0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333.0.0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667.0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72.0 68.522667-.64 123.562667-.64 140.202666.0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"/></svg></a><a href=https://www.zhihu.com/people/hu-wei-ming-31-86 rel="me noopener" class=iconfont title=zhihu target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36" height="36"><path d="M351.791182 562.469462h192.945407c0-45.367257-21.3871-71.939449-21.3871-71.939449L355.897709 490.530013c3.977591-82.182744 7.541767-187.659007 8.816806-226.835262h159.282726s-.86367-67.402109-18.578124-67.402109-279.979646.0-279.979646.0 16.850783-88.141456 39.318494-127.053698c0 0-83.60514-4.510734-112.121614 106.962104S81.344656 355.077018 76.80834 367.390461s24.62791 5.832845 36.941354.0c12.313443-5.832845 68.050885-25.924439 84.252893-103.69571h86.570681c1.165546 49.28652 4.596691 200.335724 3.515057 226.835262H109.86113c-25.275663 18.147312-33.701566 71.939449-33.701566 71.939449H279.868105c-8.497535 56.255235-23.417339 128.763642-44.275389 167.210279-33.05279 60.921511-50.55235 116.65793-169.802314 212.576513.0.0-19.442818 14.257725 40.829917 9.073656 60.273758-5.185093 117.305683-20.739347 156.840094-99.807147 20.553105-41.107233 41.805128-93.250824 58.386782-146.138358l-.055259.185218 167.855986 193.263655s22.035876-51.847855 5.832845-108.880803L371.045711 650.610918l-42.1244 31.157627-.045025.151449c11.69946-41.020252 20.11206-81.5749 22.726607-116.858498C351.665315 564.212152 351.72876 563.345412 351.791182 562.469462z"/><path d="M584.918753 182.033893v668.840094h70.318532l28.807093 80.512708 121.875768-80.512708h153.600307L959.520453 182.033893h-374.6017zM887.150192 778.934538h-79.837326l-99.578949 65.782216-23.537066-65.782216h-24.855084L659.341766 256.673847h227.807403V778.934538z"/></svg></a><a href=https://huweim.github.io/index.xml rel="noopener alternate" type=application/rss+xml class=iconfont title=rss target=_blank><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="30" height="30"><path d="M819.157333 1024C819.157333 574.592 449.408 204.8.0 204.8V0c561.706667.0 1024 462.293333 1024 1024H819.157333zM140.416 743.04a140.8 140.8.0 01140.501333 140.586667A140.928 140.928.0 01140.074667 1024C62.72 1024 0 961.109333.0 883.626667S62.933333 743.082667 140.416 743.04zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667v-199.04c372.352.0 678.784 306.517333 678.784 678.826667z"/></svg></a></div><div class=copyright><span class=power-by>Powered by <a class=hexo-link href=https://gohugo.io>Hugo</a></span>
<span class=division>|</span>
<span class=theme-info>Theme - <a class=theme-link href=https://github.com/xianmin/hugo-theme-jane>Jane</a></span>
<span class=copyright-year>&copy;
2020 -
2022
<span class=heart><i class=iconfont><svg class="icon" viewBox="0 0 1025 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="14" height="14"><path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7.0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1.0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2.0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3.1-42.5-8-83.6-24-122.2z" fill="#8a8a8a"/></svg></i></span><span class=author>Cory</span></span></div></footer><div class=back-to-top id=back-to-top><i class=iconfont><svg class="icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="35" height="35"><path d="M510.866688 227.694839 95.449397 629.218702h235.761562L329.15309 958.01517h362.40389L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777h894.052392v131.813095H63.840492V63.962777zm0 0"/></svg></i></div></div><script type=text/javascript src=/lib/jquery/jquery-3.2.1.min.js></script>
<script type=text/javascript src=/lib/slideout/slideout-1.0.1.min.js></script>
<script type=text/javascript src=/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin=anonymous></script>
<script type=text/javascript src=/js/load-photoswipe.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe.min.js></script>
<script type=text/javascript src=/lib/photoswipe/photoswipe-ui-default.min.js></script></body></html>