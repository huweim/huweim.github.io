<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>搭建GPGPU-Sim实验环境 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="搭建GPGPU-Sim实验环境">
<meta itemprop=description content="0. 前言 第一个思路是
 服务器OS->Docker Container->Ubuntu中运行GPGPU-Sim。 Docker Container update Docker Image->Docker Image->XXX.tar->复制到你的电脑Windows->复制到你的虚拟机Ubuntu->XXX.tar->Docker Image->Docker Container->Ubuntu中运行GPGPU-Sim->修改GPGPU-Sim 然后同样使用上述过程移植到服务器，运行  这样是有问题的。首先这个过程没有意义，如果这样在你自己的虚拟机里面运行Docker, 那么仍然是命令行界面，和在服务器上运行的区别在哪？
这样实现了Docker的其中一个作用
 我在服务器上能跑，在我自己的虚拟机上也能跑。实现了在不同的环境下运行，而且无需安装多余的依赖。因为本质上我用的是 Docker 中的 Ubuntu 14 但我没有实现自己的目的  我的目的是什么？
  在自己的Ubuntu上使用VScode修改模拟器，简单地编译测试性能。修改后需要跑大量benchmark, 这个时候我不能用自己的电脑跑了，我需要移植了。
  把跑benchmark需要用到的东西放在服务器上，用服务器的计算资源运行。需要用到的东西是什么？
  benchmark: 一般是一些 .cu/.cl 代码编译后生成的可执行文件
   编译成功gpgpusim以后，实际上主要是生成了一个libcudart.so。
 那么就需要这个 libcudart.so
    所以理论上来说如果我使用一台固定的服务器，好像不需要一直更新Docker?无需安装 gcc4.5.1, cuda4.2。每次把这几个文件拷贝过去即可。
  0.1 测试 在 gpgpu-sim_distribution 目录下只放置 lib 文件夹 也是可以 Run 的，说明程序运行时只会 call libcudart.so 这个文件"><meta itemprop=datePublished content="2021-09-27T22:54:06+08:00">
<meta itemprop=dateModified content="2021-09-27T22:54:06+08:00">
<meta itemprop=wordCount content="207">
<meta itemprop=keywords content="GPGPU-Sim,环境搭建,"><meta property="og:title" content="搭建GPGPU-Sim实验环境">
<meta property="og:description" content="0. 前言 第一个思路是
 服务器OS->Docker Container->Ubuntu中运行GPGPU-Sim。 Docker Container update Docker Image->Docker Image->XXX.tar->复制到你的电脑Windows->复制到你的虚拟机Ubuntu->XXX.tar->Docker Image->Docker Container->Ubuntu中运行GPGPU-Sim->修改GPGPU-Sim 然后同样使用上述过程移植到服务器，运行  这样是有问题的。首先这个过程没有意义，如果这样在你自己的虚拟机里面运行Docker, 那么仍然是命令行界面，和在服务器上运行的区别在哪？
这样实现了Docker的其中一个作用
 我在服务器上能跑，在我自己的虚拟机上也能跑。实现了在不同的环境下运行，而且无需安装多余的依赖。因为本质上我用的是 Docker 中的 Ubuntu 14 但我没有实现自己的目的  我的目的是什么？
  在自己的Ubuntu上使用VScode修改模拟器，简单地编译测试性能。修改后需要跑大量benchmark, 这个时候我不能用自己的电脑跑了，我需要移植了。
  把跑benchmark需要用到的东西放在服务器上，用服务器的计算资源运行。需要用到的东西是什么？
  benchmark: 一般是一些 .cu/.cl 代码编译后生成的可执行文件
   编译成功gpgpusim以后，实际上主要是生成了一个libcudart.so。
 那么就需要这个 libcudart.so
    所以理论上来说如果我使用一台固定的服务器，好像不需要一直更新Docker?无需安装 gcc4.5.1, cuda4.2。每次把这几个文件拷贝过去即可。
  0.1 测试 在 gpgpu-sim_distribution 目录下只放置 lib 文件夹 也是可以 Run 的，说明程序运行时只会 call libcudart.so 这个文件">
<meta property="og:type" content="article">
<meta property="og:url" content="https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_%E6%90%AD%E5%BB%BAgpgpu-sim%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-27T22:54:06+08:00">
<meta property="article:modified_time" content="2021-09-27T22:54:06+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="搭建GPGPU-Sim实验环境">
<meta name=twitter:description content="0. 前言 第一个思路是
 服务器OS->Docker Container->Ubuntu中运行GPGPU-Sim。 Docker Container update Docker Image->Docker Image->XXX.tar->复制到你的电脑Windows->复制到你的虚拟机Ubuntu->XXX.tar->Docker Image->Docker Container->Ubuntu中运行GPGPU-Sim->修改GPGPU-Sim 然后同样使用上述过程移植到服务器，运行  这样是有问题的。首先这个过程没有意义，如果这样在你自己的虚拟机里面运行Docker, 那么仍然是命令行界面，和在服务器上运行的区别在哪？
这样实现了Docker的其中一个作用
 我在服务器上能跑，在我自己的虚拟机上也能跑。实现了在不同的环境下运行，而且无需安装多余的依赖。因为本质上我用的是 Docker 中的 Ubuntu 14 但我没有实现自己的目的  我的目的是什么？
  在自己的Ubuntu上使用VScode修改模拟器，简单地编译测试性能。修改后需要跑大量benchmark, 这个时候我不能用自己的电脑跑了，我需要移植了。
  把跑benchmark需要用到的东西放在服务器上，用服务器的计算资源运行。需要用到的东西是什么？
  benchmark: 一般是一些 .cu/.cl 代码编译后生成的可执行文件
   编译成功gpgpusim以后，实际上主要是生成了一个libcudart.so。
 那么就需要这个 libcudart.so
    所以理论上来说如果我使用一台固定的服务器，好像不需要一直更新Docker?无需安装 gcc4.5.1, cuda4.2。每次把这几个文件拷贝过去即可。
  0.1 测试 在 gpgpu-sim_distribution 目录下只放置 lib 文件夹 也是可以 Run 的，说明程序运行时只会 call libcudart.so 这个文件">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css>
<script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1>
<div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social">
<ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/posts>All posts</a>
</li>
<li>
<a href=/categories/>Categories</a>
</li>
<li>
<a href=/archives>Archives</a>
</li>
<li>
<a href=/tags>Tags</a>
</li>
<li>
<a href=/about/>About</a>
</li>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>27</span>
<span class=rest>Sep 2021</span>
</div>
</div>
<div class=matter>
<h1 class=title>搭建GPGPU-Sim实验环境</h1>
</div>
</div>
<div class=markdown>
<h1 id=0-前言>0. 前言</h1>
<p>第一个思路是</p>
<ul>
<li>服务器OS->Docker Container->Ubuntu中运行GPGPU-Sim。</li>
<li>Docker Container update Docker Image->Docker Image->XXX.tar->复制到你的电脑Windows->复制到你的虚拟机Ubuntu->XXX.tar->Docker Image->Docker Container->Ubuntu中运行GPGPU-Sim->修改GPGPU-Sim</li>
<li>然后同样使用上述过程移植到服务器，运行</li>
</ul>
<p>这样是有问题的。首先这个过程没有意义，如果这样在你自己的虚拟机里面运行Docker, 那么仍然是命令行界面，和在服务器上运行的区别在哪？</p>
<p>这样实现了Docker的其中一个作用</p>
<ul>
<li>我在服务器上能跑，在我自己的虚拟机上也能跑。实现了在不同的环境下运行，而且无需安装多余的依赖。因为本质上我用的是 Docker 中的 Ubuntu 14</li>
<li>但我没有实现自己的目的</li>
</ul>
<p>我的目的是什么？</p>
<ul>
<li>
<p>在自己的Ubuntu上使用VScode修改模拟器，简单地编译测试性能。修改后需要跑大量benchmark, 这个时候我不能用自己的电脑跑了，我需要移植了。</p>
</li>
<li>
<p>把跑benchmark需要用到的东西放在服务器上，用服务器的计算资源运行。需要用到的东西是什么？</p>
<ul>
<li>
<p>benchmark: 一般是一些 .cu/.cl 代码编译后生成的可执行文件</p>
</li>
<li>
<blockquote>
<p>编译成功gpgpusim以后，实际上主要是生成了一个<code>libcudart.so</code>。</p>
</blockquote>
<p>那么就需要这个 libcudart.so</p>
</li>
</ul>
</li>
<li>
<p>所以理论上来说如果我使用一台固定的服务器，好像不需要一直更新Docker?无需安装 gcc4.5.1, cuda4.2。每次把这几个文件拷贝过去即可。</p>
</li>
</ul>
<h1 id=01-测试>0.1 测试</h1>
<h5 id=在-gpgpu-sim_distribution-目录下只放置-lib-文件夹>在 gpgpu-sim_distribution 目录下只放置 lib 文件夹</h5>
<p>也是可以 Run 的，说明程序运行时只会 call libcudart.so 这个文件</p>
<p>修改 gpgpu-sim_distribution 文件夹的名字之后，ISPASS 中的 benchmark application 就还走不到 libcudart.so 文件了，这个应该和脚本写的文件路径有关</p>
<h1 id=1-虚拟机--windows>1. 虚拟机&ndash;Windows</h1>
<p>都在脚本 <code>d/gpgpusim/script/host2vbox.sh</code> 中</p>
<h2 id=11-从windows到虚拟机>1.1 从Windows到虚拟机</h2>
<p>如果有这个必要的话，当然最好还是就在虚拟机里面直接编程。就是 VB 的虚拟机环境实在太慢了，后期思考一下解决方法</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>mv gpgpu-sim_distribution backup_gpgpu-sim_distribution
cp shared/gpgpu-sim_distribution ~/gpgpu-sim_distribution
<span class=nb>cd</span> ~/gpgpu-sim_distribution
<span class=nb>source</span> setup_environment release
make
make docs
</code></pre></div><h2 id=11-从虚拟机到windows>1.1 从虚拟机到Windows</h2>
<p>使用 Windows 和 VirtualBox 之间的共享文件夹，Win的共享文件夹放在 <code>d/gpgpusim/pchsare</code>.</p>
<p>将vbox虚拟机里编译好的<code>/home/gpgpu-sim/gpgpu-sim_distribution/lib/gcc-4.6.4/cuda-4020/release/libcudart.so</code>及其软链接 (这里是 libcudart.so2/3/4) 拷贝到 <code>/home/shared/libsim</code>, 将 <code>/home/gpgpu-sim/cuda/toolkit/4.2/cuda/bin</code>文件夹拷贝到 <code>/home/shared/cuda</code>, i.e. <code>/home/shared/cuda/</code>里只有一个bin文件夹</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>cp gpgpu-sim_distribution/lib/gcc-4.6.4/cuda-4020/release/* ~/shared/libsim/
</code></pre></div><h1 id=2-从-windows-到服务器>2. 从 Windows 到服务器</h1>
<p>此时 Win <code>d/gpgpusim/pchsare</code> 中已经有了 <code>libsim</code>, <code>cuda</code> 两个文件夹，直接通过 mobaxterm 拖拽上传到服务器 <code>~/huweim/gpgpusim</code> 目录下即可</p>
<h1 id=3-从服务器到-docker>3. 从服务器到 Docker</h1>
<h2 id=31-挂载文件夹>3.1 挂载文件夹</h2>
<p>已经在服务器上配置了可以运行GPGPU-Sim的Docker容器，且环境和编译GPGPU-Sim的虚拟机环境一致。把服务器上的外部文件夹挂载到Docker里面，</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ docker run --name gpgpusim -it -v /home/vsp/huweim/gpgpusim:/root/sim/ huweim/gpgpu-sim:v2 /bin/bash
<span class=c1>#--name 给容器命名</span>
<span class=c1>#/home/huweim/gpgpusim:/home/sim/ 本地的绝对路径:容器的绝对路径</span>
<span class=c1>#huweim/gpgpu-sim:v2  镜像名:Tag 不指定Tag会尝试从Reposity pull latest, 因为是本地镜像没有远程reposity, 会报错，因此加上tag</span>
</code></pre></div><h2 id=32-在服务器上跑起来>3.2 在服务器上跑起来</h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash>$ cp ~/sim/libsim/* ~/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-4020/release/
$ <span class=nb>cd</span> ~/test
$ ~/ispass2009-benchmarks/bin/release/LPS <span class=p>|</span> tee ~/output/LPS.log
$ ~/ispass2009-benchmarks/bin/release/RAY <span class=m>4</span> <span class=m>4</span> <span class=p>|</span> tee ~/output/RAY.log
</code></pre></div><h1 id=4-压榨性能>4. 压榨性能</h1>
<h2 id=41-shell-并发>4.1 Shell 并发</h2>
<p>wait 相当于 syncthread()</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=c1># !/bin/bash</span>
<span class=k>for</span> i in <span class=sb>`</span>seq <span class=m>1</span> 10<span class=sb>`</span> 
<span class=k>do</span>
    <span class=nb>echo</span> <span class=nv>$i</span> <span class=p>&amp;</span>
<span class=k>done</span>

<span class=nb>wait</span>
<span class=nb>echo</span> <span class=s2>&#34;----end----&#34;</span>
</code></pre></div><h2 id=42-减少输出的屏幕>4.2 减少输出的屏幕</h2>
<p>减少在屏幕上的输出是否能有优化呢？做一个时间测试</p>
<blockquote>
<p>非引用，自己猜想。有一种把输出重定向到垃圾池 > /dev/null 的操作，是否可以看做为了减少输出到终端的开销而采取的方式。那么是不是可以说明输出到终端会造成开销。</p>
</blockquote>
<p>改用重定向的方式而非 <code>tee</code>, 观察能够加速多少。测试总共6个比较快的benchmark</p>
<ul>
<li>tee: 180s</li>
<li><code>></code> : 不到1s</li>
</ul>
<p>看来终端打印的确开销很大啊</p>
</div>
<div class=tags>
<ul class=flat>
<li><a href=/tags/gpgpu-sim>GPGPU-Sim</a></li>
<li><a href=/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA>环境搭建</a></li>
</ul>
</div></div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2021 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script>feather.replace()</script>
</body>
</html>