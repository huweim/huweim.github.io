<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>LeetCode刷题记录 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="LeetCode刷题记录"><meta itemprop=description content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><meta itemprop=datePublished content="2022-03-16T08:59:50+08:00"><meta itemprop=dateModified content="2022-03-16T09:01:09+00:00"><meta itemprop=wordCount content="807"><meta itemprop=keywords content="LeetCode,"><meta property="og:title" content="LeetCode刷题记录"><meta property="og:description" content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><meta property="og:type" content="article"><meta property="og:url" content="https://huweim.github.io/posts/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-16T08:59:50+08:00"><meta property="article:modified_time" content="2022-03-16T09:01:09+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode刷题记录"><meta name=twitter:description content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css><script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1><div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social"><ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>16</span>
<span class=rest>Mar 2022</span></div></div><div class=matter><h1 class=title>LeetCode刷题记录</h1></div></div><div class=markdown><h4 id=关键字检索>关键字检索</h4><ul><li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。</li><li>知识点：题目所涉及到的大概知识点。</li><li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针</li><li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。</li></ul><h4 id=总结>总结</h4><ul><li>短板：二叉树，矩阵，DFS，BFS</li></ul><h3 id=311>3.11</h3><h4 id=查缺补漏>查缺补漏</h4><ul><li>二叉树建树</li><li>二叉树后序遍历</li></ul><h3 id=311-1>3.11</h3><h5 id=jz03>JZ.03</h5><p>3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；</p><p>第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)</p><p>第三种原地Hash，鸽巢原理。源于一个条件 <code>element value &lt; nums.size()</code>，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)</p><p><strong>知识点</strong></p><ul><li>vector 可以用下标索引</li><li>标签：hash，排序，数组</li></ul><h5 id=jz04-二维数组中的查找-x>JZ.04 二维数组中的查找 :x:</h5><p>感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)</p><p>并非 DP，没有秒这题；主要是思路上的解法而非常规算法</p><blockquote><p>从右上角开始比较，比它大就往下数一行，比它小就往左数一列</p><p>二分查找也是解法之一</p></blockquote><p><strong>知识点</strong></p><ul><li>二维 vector 能否用下标索引？<ul><li>可以</li></ul></li><li>标签：数组，二分查找，分治，矩阵</li></ul><h5 id=jz05-替换空格>JZ.05 替换空格</h5><p>简单的字符串替换，被 string 和 char，"" 和 &rsquo;&rsquo; 的一些知识卡了一会儿。</p><p><strong>知识点</strong></p><ul><li>字符串裁剪 <code>str.substr(pos, len)</code>，</li><li>:warning: 字符串比较；string 可以直接用 <code>==</code>，但是注意 s[0] 是 char 型；所以 <code>s[0] == " "</code> 会报错，应该是 <code>s[0] == ' '</code>；或者 <code>strcmp(s[0], ' ');</code></li><li>注意 "" 和 ''</li><li>:exclamation: 为什么不能用 strcmp？<ul><li>用 <code>strcmp(string , string)</code> 会就报错；使用 <code>strcmp(char [], char[])</code> 就可以了；有什么区别？</li><li>string 是一个 managed type，不用担心有多长；char[] 分配的长度固定</li></ul></li></ul><h5 id=jz06-反转链表><strong>JZ.06 反转链表</strong></h5><p>从尾到头打印链表，单链表</p><p>自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$</p><p>也可以使用 递归</p><p>:warning: 注意边界条件，基本每次 case 都会有</p><p><strong>知识点</strong></p><ul><li>单向链表；指针；vector</li><li>标签：栈，链表，递归，双指针</li></ul><h3 id=313>3.13</h3><h5 id=jz07-重建二叉树-x>JZ.07 重建二叉树 :x:</h5><p>二叉树和链表的数据结构要记住。</p><p>如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解</p><p>In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。</p><p>:x: 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。</p><p>pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size</p><p><strong>知识点</strong></p><ul><li>前序遍历列表：第一个元素永远是 【根节点 (root)】</li><li>中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】</li><li>做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end</li><li>标签：数组，hash，分治，二叉树</li></ul><h5 id=jz09-用两个栈实现队列>JZ.09 用两个栈实现队列</h5><p>自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。</p><p>更好的思路：其实不用再把 stack_2 中全部倒回 stack_1</p><p><strong>知识点</strong></p><ul><li>栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？<code>stack&lt;int> stk; queue&lt;int> q;</code></li><li>两个栈实现队列</li><li>标签：栈，队列</li></ul><h5 id=jz10-斐波那契数列-dp>JZ.10 斐波那契数列 DP</h5><p>自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归</p><p>更好的思路：这题可以用 DP，没有想到。</p><p>现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；</p><p>转移方程：$dp[i+1] = dp[i] + dp[i-1]$</p><p>初始状态：$dp[0] = 0; dp[1] = 1$</p><p>返回值：$dp[n]$</p><p><strong>知识点</strong></p><ul><li>查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路</li><li>标签：DP</li></ul><h5 id=jz11-青蛙跳台阶>JZ.11 青蛙跳台阶</h5><p>自己的思路：hash 递归；DP</p><p>和上一题很类似，写的是优化空间后的 DP，</p><p>:heavy_check_mark: 要求自己写一个常规的 DP 加深理解</p><p><strong>知识点</strong></p><ul><li>DP</li></ul><h5 id=jz11-旋转数组的最小数字-x>JZ.11 旋转数组的最小数字 :x:</h5><blockquote><p>这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的</p></blockquote><p>确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。</p><p><strong>知识点</strong></p><ul><li>标签：二分查找，数组</li><li>查缺补漏：二分查找熟练度不够</li></ul><h3 id=314>3.14</h3><h5 id=jz12-矩阵中的路径-x>JZ.12 矩阵中的路径 :x:</h5><p>自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$</p><p>题解 DFS，DFS 已经非常生疏了</p><p>看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。</p><p><strong>知识点</strong></p><ul><li>典型的矩阵搜索问题</li></ul><h5 id=jz13-机器人运动范围>JZ.13 机器人运动范围</h5><p>这个也是算法设计课程中出现的考试题目。</p><p>自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。</p><p>写错了一句 <code>tag[i][j] == -1;</code>，报错居然是 <code>stackoverflow</code>，要注意尽量一次写出 bug-free code。</p><p>题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵</p><p><strong>知识点</strong></p><ul><li>和上一题类似，也是矩阵，DFS还是可以用。</li><li>标签：<strong>DP</strong>，BFS，DFS；DP 体现在哪？了解 DP 的解法</li></ul><h5 id=jz14-i-剪绳子-x>JZ.14-I 剪绳子 :x:</h5><p>自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$</p><p>更好的思路：</p><p><strong>DP</strong></p><ul><li>求长度为 n 的绳子剪掉后的乘积，从 &lt;n 的绳子转移而来</li><li><code>dp数组</code> 记录 <code>0到n</code> 的绳子的最大乘积，初始化 <code>dp[2] = 1</code></li><li>剪掉第一段，长度为 j，j > 1</li><li>剪了第一段，剩下长度为 <code>(i - j)</code> 可以剪或者不剪。不剪的话 <code>length = j * (i - j)</code>；剪了的话 <code>length = j * dp[i - j]</code>；<code>max(j * (i - j), j * dp[i - j])</code></li><li>遍历 j，$j \in [2, i)$，取最大值。</li></ul><p>难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。</p><p><strong>2022-03-16 10:38:06</strong>，尝试写一下 DP 解法 :heavy_check_mark:。DP 和自己的思路性能差不多。</p><p><strong>贪心</strong></p><ul><li>均值不等式思想；n > 4 时，尽可能把绳子分为长度为 3 的小段，进行乘加。</li></ul><h3 id=316>3.16</h3><h5 id=jz14-ii-剪绳子>JZ.14-II 剪绳子</h5><p>在 I 的基础上加了一个答案取模，取模对于加法没有影响，~~但是会影响乘法的计算结果。~~并没有，那么这题在考察什么？</p><p>这个题目就是考察贪心的解法，如果继续用 DP，应该会超时</p><h5 id=jz15-二进制中1的个数>JZ.15 二进制中1的个数</h5><p>考察位运算。</p><p>自己的思路：比较基础的 $/2%2$ 进行二进制化，时间复杂度 $O(logn)$，可以AC。bitset</p><p>更好的思路：$n&(n-1)$，$n-1:$ 二进制数字 $n$ 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1；$n&(n - 1):$ 二进制数字 $n$ 最右边的 1 变成 0 ，其余不变。时间复杂度 $O(M)$，M 为 1 的数量</p><p><strong>知识点</strong></p><ul><li>标签：位运算</li></ul><h5 id=jz16-数值的整数次方-x>JZ.16 数值的整数次方 :x:</h5><p>自己的思路：计算 $pow(x, n)$，naive 直接乘 $n$ 次，时间复杂度 $O(n)$，会超时，因此需要的不是 $O(n)$ 的解法。好像和复杂度没有关系，注意 $n$ 的范围，涉及越界的问题。</p><blockquote><p><del>我认为这个应该就是考察 INT 型表示范围的细节，尤其是 $n = 0 - n$ 这种写法会越界</del>。看来并非如此</p></blockquote><p>处理了越界仍然会超时，用 $x$ 的范围去换 $n$ 的范围。这样并没有降低时间复杂度的数量级，304 case 全过但是仍然超时。因此猜测 $O(n)$​ 的解法 A 不了。加了一个判断 <code>if(x &lt; 0.000005) return x * init_x;</code> 后 AC 了，因为输出只保留到小数点后 5 位，有点取巧，虽然 AC 但是可能没有满足这道题的考察意图。:warning: 这个取巧做法不能算真正的 AC。</p><p><strong>更好的解法</strong>：确实有 $O(logn)$ 的解法，<strong>快速幂</strong>。快速幂也就是在循环中递归地使用你只用了一次的降幂操作，每次可以降幂的时候，$x *= x, n &#187;= 1$，这样将复杂度降至 $O(logn)$</p><p><strong>知识点</strong></p><ul><li>$(-3) % 2$，余数是 1 还是 -1？答案：余数是 -1</li><li>标签：递归，数学</li></ul><h5 id=jz17-打印从1到最大的n位数>JZ.17 打印从1到最大的n位数</h5><p>自己的思路：遍历，时间复杂度 $O(10^n)$，直接 A，意义在哪？评论区有人说原题目是要考虑大数越界问题的。因此，这道题的本意应该是考察字符串和整型数字的转换。</p><p>先放一下</p><blockquote><p>若不考虑大数问题，则十分简单一个从1到最大数的循环即可。 若考虑大数问题，则首先需要将数字转成字符串避免溢出，然后全排列字符串的第0位到第n-1位。 存储结果时需去掉字符串前几位的0(0099没有意义，应为99)再放入结果。</p></blockquote><p><strong>知识点</strong></p><ul><li>标签：数组（越界，大数），字符串</li></ul><h5 id=jz18-删除链表的节点>JZ.18 删除链表的节点</h5><p>自己的思路：最简单的单链表删除，时间复杂度 $O(n)$，AC。</p><p><strong>知识点</strong></p><ul><li>标签：链表</li></ul><h5 id=jz20-表示数值的字符串>JZ.20 表示数值的字符串</h5><p>这个题是有实用性的，也许在某些爬虫提取数据的时候会用到。</p><p>自己的思路：就是用条件判断筛选出不合规的情况 <code>return false</code>，第一次以为空格直接删除就行，提交后发现空格不能出现在有效符号的中间。</p><p>提交 23 次 AC，基本就是看着 case 补条件，完全没有周全考虑，没有使用正则表达式思想。</p><p><strong>知识点</strong></p><ul><li>标签：字符串，有限状态机</li></ul><h5 id=jz21-调整数组顺序使奇数位于偶数前面>JZ.21 调整数组顺序使奇数位于偶数前面</h5><p>自己的思路：两次遍历，$O(n)$，AC，有没有复杂度更低的解法？</p><p>题解的思路：也是 $O(n)$ 复杂度，但只用遍历一次，双指针，类似快排的思路。分别从左右开始遍历，然后交换。稍快一点。</p><p><strong>知识点</strong></p><ul><li>标签：数组，双指针，排序</li></ul><h5 id=jz22-链表中倒数第k个节点>JZ.22 链表中倒数第k个节点</h5><p>自己的思路：打印倒数的节点，所以遍历两次，第一次确定链表长度 L，L - k 次 next 就可以找到目标结果，然后返回，AC，时间复杂度 $O(n)$</p><p>更好的解法：双指针，无需统计链表的长度。前指针先走 $k$ 步，然后共同移动，前指针到终点时返回后指针即可，时间复杂度 $O(n)$</p><p><strong>知识点</strong></p><ul><li>标签：链表，双指针</li></ul><h5 id=jz24-反转链表>JZ.24 反转链表</h5><p>自己的思路：一次遍历，forward 指针在前，head 自己在后，一遍遍历一边调整，AC，时间复杂度 O(n)。</p><p>:x: 注意边界条件，注意条件判断时写了 <code>if(head->next == NULL || head == NULL)</code>，报错。因为当 head==NULL，是找不到 head->next，自己写代码不要忽略边界和细节。</p><p>题解：除双指针，还有递归的解法，时间空间都是 $O(n)$</p><p><strong>知识点</strong></p><ul><li>标签：递归，链表</li><li>关于递归，心中要有明确的终止条件的概念。</li></ul><h5 id=jz25-合并两个递增排序的链表>JZ.25 合并两个递增排序的链表</h5><p>自己的思路：非常基础的算法题，一次遍历，其中一个链表完成遍历后直接接过去。最初出现错误的原因：遍历的时候 <code>l2 = l2->next</code>，忘记保存头结点。</p><p>一开始的合并写法没有 AC，逻辑有点混乱了，后来直接换了一种写法，新建了一个链表，比较耗费空间，时间复杂度 $O(m+n)$，空间复杂度 $O(m+n)$。</p><p><strong>知识点</strong></p><ul><li>标签：递归，链表</li><li>引入 <strong>伪头结点</strong> 合并链表是本题的最优解</li></ul><h4 id=317>3.17</h4><h5 id=jz26-树的子结构-x>JZ.26 树的子结构 :x:</h5><p>又到了短板，二叉树相关的题目。</p><p>自己的思路：是否会有一段完全相同的中序遍历？中序遍历能否唯一确定？手写中序遍历 DFS，大概的还记得，有些地方比如 visied，还有判断条件（only care left）疏忽了，但是很快能想起来。Value 还存在负数，那么只能前序也 check 一次了。</p><p>check 了一次前序一次中序，但是还是 AC 不了，说明一开始的思路可能有点问题。写出了前序和中序，但是没法 AC，思路是错的。</p><p>更好的解法：遍历 A 树中的每个节点 $n_A$，判断以 $n_A$ 为根节点的字数是否包含 B。状态一般，没有自己手写题解，之后再熟悉一遍。</p><p><strong>知识点</strong></p><ul><li>标签：树，DFS</li></ul><h5 id=jz27-二叉树的镜像>JZ.27 二叉树的镜像</h5><p>自己的思路：简单递归。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，由递归栈的深度决定.</p><h5 id=jz28-对称的二叉树-warning>JZ.28 对称的二叉树 :warning:</h5><p>自己的思路：一开始直接指针指向 root，翻转二叉树，比较，忽略了只是指针指向了 root，没有保留翻转前的树。后来分别使用递归建树、翻转、比较，AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p>更好的思路：一次递归，无需求镜像。递归地比较左右子树是否相等即可</p><p><strong>知识点</strong></p><ul><li>这个题用到和复习的知识点比较多，包括建树。翻转二叉树，比较</li><li>标签：二叉树，BFS，DFS</li></ul><h5 id=jz29-顺时针打印矩阵>JZ.29 顺时针打印矩阵</h5><p>自己的思路：没考虑算法，用循环每次 push 边界上的几组数，然后不断地更新边界条件，直到所有数都 push 进去。注意边界条件。AC，时间复杂度 $o(mn)$，空间复杂度 $O(mn)$。</p><p>题解：和 K 神题解的思想差不多。</p><p><strong>知识点</strong></p><ul><li>数组，矩阵，模拟</li></ul><h5 id=jz30-包含-min-的栈>JZ.30 包含 min 的栈</h5><p>自己的思路：用 vector 实现，push 的时候对比一下记录 min 即可，关于 vector 的指定 index 删除有点忘记了。<code>v.erase(pos)</code>。噢，不过突然想起 stack 是先进后出，那么直接 <code>v.pop_back()</code> 删掉最后一个即可。不过为了更加造轮子，还是不用 STL 了吧，用数组好了。</p><p>还有一个细节，还需要额外保存一个次小值，当 min pop 时需要用次小值顶上。次小值还不够，应该用一个数组记录不同 stack size 时的 min，空间换时间。</p><p>:exclamation: 细节：栈空时要重置 min。</p><p>题解：很多题解都是用辅助栈，不过这题个人主要是尝试用数组求解。</p><p><strong>知识点</strong></p><ul><li>关于 vector 的指定 index 删除。<code>v.erase(pos)</code>。</li></ul><h5 id=jz31-栈的-push-pop-顺序>JZ.31 栈的 push, pop 顺序</h5><p>也是经典的算法考题，给一个 push 顺序和 pop 顺序，判断 pop 顺序是否有可能是该 push 顺序下的一个 pop 结果。</p><p>自己的思路：插 pop，给出所有可能性然后对比，这样复杂度有点太夸张了。加一点数学思路来优化，假设 push 序列是顺序的，如果 4 pop，那么 4 之后 &lt;4 的元素出栈时一定不可能是升序，比如 1，2，3；推理到元素 i 出栈，之后 $&lt;i$ 的元素出栈序列一定是降序排列。</p><p>不一定是顺序输入，所以可能需要用 hash 转换一下。hash 转换得费点脑子，找找经典的理解方法。注意细节，mmax 更换时 slide_min 便作废了。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，用了额外的 hash 空间排序。</p><p>题解：这个题其实蛮有意思，题解完全是另一种做法，自己是利用一些数学/算法上的特征解的。根据 push 序列模拟入栈操作，当栈顶元素 <code>top() == popped[i]</code> 时出栈元素，i++，push 操作完成观察栈是否空即可。</p><p><strong>知识点</strong></p><ul><li>标签：栈，数组，模拟</li><li>自己使用到了 hash 思想；栈的基本知识；栈空时调用 s.top() 会报错</li></ul><h5 id=jz32-ii-从上到下打印二叉树>JZ.32-II 从上到下打印二叉树</h5><p>自己的思路：线序遍历，根据 height 来决定 push 到哪一行。其中遇到了 vector 初始化的问题，不初始化没办法直接 <code>v[height].push_back(root->val)</code>，先根据上限 <code>v.resize(1000)</code>，遍历结束后根据深度 <code>v.resize(height+1);</code> 即可。时间复杂度 $O(n)$，空间复杂度 $O(n)$。</p><p><strong>知识点</strong></p><ul><li>二维 vector 初始化<ul><li><code>v.resize(4); v[0].resize(4);</code></li><li><code>vector&lt;vecotr&lt;int>> v(m, vector&lt;int>(n, 0))</code>; m 行 n 列全部初始化为0</li></ul></li></ul><h5 id=jz32-iii-从上到下打印二叉树>JZ.32-III 从上到下打印二叉树</h5><p>和上题区别在于，第一层从左到右打印，第二层从右到左打印，没法先序遍历直接解。</p><p>自己的思路：vector 是否自带 reverse？正好复习一下，<code>reverse(v.begin(), v.end());</code>，AC。</p><p>不过有评论说这是经典面试0分方法 :sweat:，那认真学习下题解思路。</p><p><strong>知识点</strong></p><ul><li>标签：树，BFS</li><li>reverse()</li></ul><h4 id=318>3.18</h4><p>2022-03-17 22:45:21，先把两道树的题方法搞了。贪心和 DP 是薄弱点，后期要加强。</p><h4 id=319>3.19</h4><h5 id=606-construct-string-from-binary-tree-每日一题>606. Construct String from Binary Tree 每日一题</h5><p>这道题中文描述简直是 bullshit，还没给范围，之后直接看英文好了。这道题应该是简单吗？虽然确实不太难但是东西还蛮多，涉及先序遍历，数字转字符串等等。</p><p>自己的思路：先序遍历，数字转字符串，可以省略空子树的括号，省略右子树为空仅有左子树时的括号。时间复杂度 $O(n)$</p><p><strong>彩蛋</strong>：2020.04.02 AC过，当时直接用的 <code>to_string()</code>，记一下这个函数。不知道当时是不是看的题解，那个时候写的解法更好一点~</p><p><strong>知识点</strong></p><ul><li>树，DFS，字符串</li></ul><h4 id=320>3.20</h4><h5 id=jz33-二叉搜索树的后序遍历-x>JZ.33 二叉搜索树的后序遍历 :x:</h5><p>一开始看题目描述蒙了，没有理解其意思。原来是忽略了二叉搜索树这个条件，太久没有接触到所以生疏了，也就是左孩子 value 小于当前节点，右孩子 value 大于当前节点。</p><p>自己的思路：后序遍历建树，后序遍历不能唯一确定，不过二叉搜索树好像是完全二叉树？这点得确认一下，先按照这个假设。然后判断建好的树是否满足搜索树的概念。</p><p>注意：循环中，<code>it</code> 不能回到 begin，因为 begin 位置上可能还有之前跳过的数字，留在当前位置即可。出现了意料之外的 case，所以搜索树不一定是完全二叉树？确实如此。</p><p>题解思路：遍历顺序 左右根。这个思路之前有想过。后续遍历区间$[i,j]$，遍历划分左右子树区间，找到第一个大于 root 的元素 index $m$，左子树区间 $[i, m-1]$，右子树区间 $[m,j-1]$，递归判断子树的合法性即可。</p><p><strong>知识点</strong></p><ul><li>vector：可以使用迭代器作为 <code>v.erase(pos)</code> 中的 pos 进行删除；删除后 <code>v.size()</code> 会发生变化.</li><li>二叉搜索树的概念，正是因为记错了所以思路出现了问题。</li><li>后续遍历的性质，左右根，左右子树的区间</li><li>标签：栈，树，二叉搜索树，递归，单调栈</li></ul></div><div class=tags><ul class=flat><li><a href=/tags/leetcode>LeetCode</a></li></ul></div></div></div><div class="footer wrapper"><nav class=nav><div>2022 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>