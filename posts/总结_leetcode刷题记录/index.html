<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>LeetCode刷题记录 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="LeetCode刷题记录"><meta itemprop=description content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><meta itemprop=datePublished content="2022-03-16T08:59:50+08:00"><meta itemprop=dateModified content="2022-03-16T09:01:09+00:00"><meta itemprop=wordCount content="339"><meta itemprop=keywords content="LeetCode,"><meta property="og:title" content="LeetCode刷题记录"><meta property="og:description" content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><meta property="og:type" content="article"><meta property="og:url" content="https://huweim.github.io/posts/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-03-16T08:59:50+08:00"><meta property="article:modified_time" content="2022-03-16T09:01:09+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="LeetCode刷题记录"><meta name=twitter:description content="关键字检索  查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。 知识点：题目所涉及到的大概知识点。 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。  总结  短板：二叉树，矩阵，DFS，BFS  3.11 查缺补漏  二叉树建树 二叉树后序遍历  3.11 JZ.03 3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；
第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)
第三种原地Hash，鸽巢原理。源于一个条件 element value < nums.size()，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)
知识点
 vector 可以用下标索引 标签：hash，排序，数组  JZ.04 二维数组中的查找 :x: 感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)
并非 DP，没有秒这题；主要是思路上的解法而非常规算法
 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
二分查找也是解法之一
 知识点
 二维 vector 能否用下标索引？  可以   标签：数组，二分查找，分治，矩阵  JZ.05 替换空格 简单的字符串替换，被 string 和 char，&#34;&#34; 和 &rsquo;&rsquo; 的一些知识卡了一会儿。"><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css><script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1><div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social"><ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>16</span>
<span class=rest>Mar 2022</span></div></div><div class=matter><h1 class=title>LeetCode刷题记录</h1></div></div><div class=markdown><h4 id=关键字检索>关键字检索</h4><ul><li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。</li><li>知识点：题目所涉及到的大概知识点。</li><li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针</li><li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。</li></ul><h4 id=总结>总结</h4><ul><li>短板：二叉树，矩阵，DFS，BFS</li></ul><h3 id=311>3.11</h3><h4 id=查缺补漏>查缺补漏</h4><ul><li>二叉树建树</li><li>二叉树后序遍历</li></ul><h3 id=311-1>3.11</h3><h5 id=jz03>JZ.03</h5><p>3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；</p><p>第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)</p><p>第三种原地Hash，鸽巢原理。源于一个条件 <code>element value &lt; nums.size()</code>，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)</p><p><strong>知识点</strong></p><ul><li>vector 可以用下标索引</li><li>标签：hash，排序，数组</li></ul><h5 id=jz04-二维数组中的查找-x>JZ.04 二维数组中的查找 :x:</h5><p>感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)</p><p>并非 DP，没有秒这题；主要是思路上的解法而非常规算法</p><blockquote><p>从右上角开始比较，比它大就往下数一行，比它小就往左数一列</p><p>二分查找也是解法之一</p></blockquote><p><strong>知识点</strong></p><ul><li>二维 vector 能否用下标索引？<ul><li>可以</li></ul></li><li>标签：数组，二分查找，分治，矩阵</li></ul><h5 id=jz05-替换空格>JZ.05 替换空格</h5><p>简单的字符串替换，被 string 和 char，"" 和 &rsquo;&rsquo; 的一些知识卡了一会儿。</p><p><strong>知识点</strong></p><ul><li>字符串裁剪 <code>str.substr(pos, len)</code>，</li><li>:warning: 字符串比较；string 可以直接用 <code>==</code>，但是注意 s[0] 是 char 型；所以 <code>s[0] == " "</code> 会报错，应该是 <code>s[0] == ' '</code>；或者 <code>strcmp(s[0], ' ');</code></li><li>注意 "" 和 ''</li><li>:exclamation: 为什么不能用 strcmp？<ul><li>用 <code>strcmp(string , string)</code> 会就报错；使用 <code>strcmp(char [], char[])</code> 就可以了；有什么区别？</li><li>string 是一个 managed type，不用担心有多长；char[] 分配的长度固定</li></ul></li></ul><h5 id=jz06-反转链表><strong>JZ.06 反转链表</strong></h5><p>从尾到头打印链表，单链表</p><p>自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$</p><p>也可以使用 递归</p><p>:warning: 注意边界条件，基本每次 case 都会有</p><p><strong>知识点</strong></p><ul><li>单向链表；指针；vector</li><li>标签：栈，链表，递归，双指针</li></ul><h3 id=313>3.13</h3><h5 id=jz07-重建二叉树-x>JZ.07 重建二叉树 :x:</h5><p>二叉树和链表的数据结构要记住。</p><p>如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解</p><p>In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。</p><p>:x: 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。</p><p>pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size</p><p><strong>知识点</strong></p><ul><li>前序遍历列表：第一个元素永远是 【根节点 (root)】</li><li>中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】</li><li>做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end</li><li>标签：数组，hash，分治，二叉树</li></ul><h5 id=jz09-用两个栈实现队列>JZ.09 用两个栈实现队列</h5><p>自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。</p><p>更好的思路：其实不用再把 stack_2 中全部倒回 stack_1</p><p><strong>知识点</strong></p><ul><li>栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？<code>stack&lt;int> stk; queue&lt;int> q;</code></li><li>两个栈实现队列</li><li>标签：栈，队列</li></ul><h5 id=jz10-斐波那契数列-dp>JZ.10 斐波那契数列 DP</h5><p>自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归</p><p>更好的思路：这题可以用 DP，没有想到。</p><p>现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；</p><p>转移方程：$dp[i+1] = dp[i] + dp[i-1]$</p><p>初始状态：$dp[0] = 0; dp[1] = 1$</p><p>返回值：$dp[n]$</p><p><strong>知识点</strong></p><ul><li>查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路</li><li>标签：DP</li></ul><h5 id=jz11-青蛙跳台阶>JZ.11 青蛙跳台阶</h5><p>自己的思路：hash 递归；DP</p><p>和上一题很类似，写的是优化空间后的 DP，</p><p>:heavy_check_mark: 要求自己写一个常规的 DP 加深理解</p><p><strong>知识点</strong></p><ul><li>DP</li></ul><h5 id=jz11-旋转数组的最小数字-x>JZ.11 旋转数组的最小数字 :x:</h5><blockquote><p>这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的</p></blockquote><p>确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。</p><p><strong>知识点</strong></p><ul><li>标签：二分查找，数组</li><li>查缺补漏：二分查找熟练度不够</li></ul><h3 id=314>3.14</h3><h5 id=jz12-矩阵中的路径-x>JZ.12 矩阵中的路径 :x:</h5><p>自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$</p><p>题解 DFS，DFS 已经非常生疏了</p><p>看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。</p><p><strong>知识点</strong></p><ul><li>典型的矩阵搜索问题</li></ul><h5 id=jz13-机器人运动范围>JZ.13 机器人运动范围</h5><p>这个也是算法设计课程中出现的考试题目。</p><p>自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。</p><p>写错了一句 <code>tag[i][j] == -1;</code>，报错居然是 <code>stackoverflow</code>，要注意尽量一次写出 bug-free code。</p><p>题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵</p><p><strong>知识点</strong></p><ul><li>和上一题类似，也是矩阵，DFS还是可以用。</li><li>标签：<strong>DP</strong>，BFS，DFS；DP 体现在哪？了解 DP 的解法</li></ul><h5 id=jz14-i-剪绳子-x>JZ.14-I 剪绳子 :x:</h5><p>自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$</p><p>更好的思路：</p><p><strong>DP</strong></p><ul><li>求长度为 n 的绳子剪掉后的乘积，从 &lt;n 的绳子转移而来</li><li><code>dp数组</code> 记录 <code>0到n</code> 的绳子的最大乘积，初始化 <code>dp[2] = 1</code></li><li>剪掉第一段，长度为 j，j > 1</li><li>剪了第一段，剩下长度为 <code>(i - j)</code> 可以剪或者不剪。不剪的话 <code>length = j * (i - j)</code>；剪了的话 <code>length = j * dp[i - j]</code>；<code>max(j * (i - j), j * dp[i - j])</code></li><li>遍历 j，$j \in [2, i)$，取最大值。</li></ul><p>难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。</p></div><div class=tags><ul class=flat><li><a href=/tags/leetcode>LeetCode</a></li></ul></div></div></div><div class="footer wrapper"><nav class=nav><div>2022 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>