<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Python处理输出log信息并绘图 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Python处理输出log信息并绘图">
<meta itemprop=description content="0. 前言 修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。
需要两个绘图工具
 对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等 对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等  1. 正则表达式 1.1 实例 def read_string(file,metrics): output={} for it_metrics in metrics: if(it_metrics==&#34;gpu_ipc&#34;): pattern=re.compile(it_metrics+&#34; =(\s+)(\d+\.\d+)&#34;) elif(it_metrics==&#34;Stall&#34;): pattern=re.compile(it_metrics+&#34;:(\d+)&#34;) else: pattern=re.compile(it_metrics+&#34; = (\d+)&#34;) output_sum=0 for i,line in enumerate(open(get_file_path()+file)): for match in re.finditer(pattern, line): if(it_metrics==&#34;gpu_ipc&#34;): output_part=list(match.group(2)) else: output_part=list(match.group(1)) output_part=float(''.join(output_part)) output_sum+=output_part output[it_metrics]=output_sum return output 其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。
for i,line in enumerate(open(file)) 遍历 log 的每一行，一定要加上 i 否则会报错。"><meta itemprop=datePublished content="2021-12-08T09:05:41+08:00">
<meta itemprop=dateModified content="2021-12-08T09:06:13+00:00">
<meta itemprop=wordCount content="238">
<meta itemprop=keywords content="Python,可视化,"><meta property="og:title" content="Python处理输出log信息并绘图">
<meta property="og:description" content="0. 前言 修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。
需要两个绘图工具
 对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等 对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等  1. 正则表达式 1.1 实例 def read_string(file,metrics): output={} for it_metrics in metrics: if(it_metrics==&#34;gpu_ipc&#34;): pattern=re.compile(it_metrics+&#34; =(\s+)(\d+\.\d+)&#34;) elif(it_metrics==&#34;Stall&#34;): pattern=re.compile(it_metrics+&#34;:(\d+)&#34;) else: pattern=re.compile(it_metrics+&#34; = (\d+)&#34;) output_sum=0 for i,line in enumerate(open(get_file_path()+file)): for match in re.finditer(pattern, line): if(it_metrics==&#34;gpu_ipc&#34;): output_part=list(match.group(2)) else: output_part=list(match.group(1)) output_part=float(''.join(output_part)) output_sum+=output_part output[it_metrics]=output_sum return output 其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。
for i,line in enumerate(open(file)) 遍历 log 的每一行，一定要加上 i 否则会报错。">
<meta property="og:type" content="article">
<meta property="og:url" content="https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-12-08T09:05:41+08:00">
<meta property="article:modified_time" content="2021-12-08T09:06:13+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Python处理输出log信息并绘图">
<meta name=twitter:description content="0. 前言 修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。
需要两个绘图工具
 对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等 对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等  1. 正则表达式 1.1 实例 def read_string(file,metrics): output={} for it_metrics in metrics: if(it_metrics==&#34;gpu_ipc&#34;): pattern=re.compile(it_metrics+&#34; =(\s+)(\d+\.\d+)&#34;) elif(it_metrics==&#34;Stall&#34;): pattern=re.compile(it_metrics+&#34;:(\d+)&#34;) else: pattern=re.compile(it_metrics+&#34; = (\d+)&#34;) output_sum=0 for i,line in enumerate(open(get_file_path()+file)): for match in re.finditer(pattern, line): if(it_metrics==&#34;gpu_ipc&#34;): output_part=list(match.group(2)) else: output_part=list(match.group(1)) output_part=float(''.join(output_part)) output_sum+=output_part output[it_metrics]=output_sum return output 其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。
for i,line in enumerate(open(file)) 遍历 log 的每一行，一定要加上 i 否则会报错。">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css>
<script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1>
<div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social">
<ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/posts>All posts</a>
</li>
<li>
<a href=/categories/>Categories</a>
</li>
<li>
<a href=/archives>Archives</a>
</li>
<li>
<a href=/tags>Tags</a>
</li>
<li>
<a href=/about/>About</a>
</li>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>08</span>
<span class=rest>Dec 2021</span>
</div>
</div>
<div class=matter>
<h1 class=title>Python处理输出log信息并绘图</h1>
</div>
</div>
<div class=markdown>
<h1 id=0-前言>0. 前言</h1>
<p>修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。</p>
<p>需要两个绘图工具</p>
<ul>
<li>对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等</li>
<li>对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等</li>
</ul>
<h1 id=1-正则表达式>1. 正则表达式</h1>
<h2 id=11-实例>1.1 实例</h2>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=k>def</span> <span class=nf>read_string</span><span class=p>(</span><span class=n>file</span><span class=p>,</span><span class=n>metrics</span><span class=p>):</span>
    
    <span class=n>output</span><span class=o>=</span><span class=p>{}</span>
    <span class=k>for</span> <span class=n>it_metrics</span> <span class=ow>in</span> <span class=n>metrics</span><span class=p>:</span>
        <span class=k>if</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>==</span><span class=s2>&#34;gpu_ipc&#34;</span><span class=p>):</span>
            <span class=n>pattern</span><span class=o>=</span><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>+</span><span class=s2>&#34; =(\s+)(\d+\.\d+)&#34;</span><span class=p>)</span>
        <span class=k>elif</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>==</span><span class=s2>&#34;Stall&#34;</span><span class=p>):</span>
            <span class=n>pattern</span><span class=o>=</span><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>+</span><span class=s2>&#34;:(\d+)&#34;</span><span class=p>)</span>
        <span class=k>else</span><span class=p>:</span>
            <span class=n>pattern</span><span class=o>=</span><span class=n>re</span><span class=o>.</span><span class=n>compile</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>+</span><span class=s2>&#34; = (\d+)&#34;</span><span class=p>)</span>
        <span class=n>output_sum</span><span class=o>=</span><span class=mi>0</span>
        <span class=k>for</span> <span class=n>i</span><span class=p>,</span><span class=n>line</span> <span class=ow>in</span> <span class=nb>enumerate</span><span class=p>(</span><span class=nb>open</span><span class=p>(</span><span class=n>get_file_path</span><span class=p>()</span><span class=o>+</span><span class=n>file</span><span class=p>)):</span>
            <span class=k>for</span> <span class=n>match</span> <span class=ow>in</span> <span class=n>re</span><span class=o>.</span><span class=n>finditer</span><span class=p>(</span><span class=n>pattern</span><span class=p>,</span> <span class=n>line</span><span class=p>):</span>
                <span class=k>if</span><span class=p>(</span><span class=n>it_metrics</span><span class=o>==</span><span class=s2>&#34;gpu_ipc&#34;</span><span class=p>):</span>
                    <span class=n>output_part</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>match</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>2</span><span class=p>))</span>
                <span class=k>else</span><span class=p>:</span>
                    <span class=n>output_part</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>match</span><span class=o>.</span><span class=n>group</span><span class=p>(</span><span class=mi>1</span><span class=p>))</span>
                <span class=n>output_part</span><span class=o>=</span><span class=nb>float</span><span class=p>(</span><span class=s1>&#39;&#39;</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=n>output_part</span><span class=p>))</span>
                <span class=n>output_sum</span><span class=o>+=</span><span class=n>output_part</span>
        <span class=n>output</span><span class=p>[</span><span class=n>it_metrics</span><span class=p>]</span><span class=o>=</span><span class=n>output_sum</span>
    <span class=k>return</span> <span class=n>output</span>
</code></pre></div><p>其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。</p>
<p><code>for i,line in enumerate(open(file))</code> 遍历 log 的每一行，一定要加上 <code>i</code> 否则会报错。</p>
<p><code>match.group(1)</code> 每次会返回一个整数，这个时候整数是元组的形式，所以需要先转化为 list，然后转化为 float 类型，这个时候便可以用于算术运算。</p>
<h3 id=111-group>1.1.1 group</h3>
<ul>
<li>似乎有点理解这个匹配了，对于 <code>gpu_ipc</code>，\s+ 匹配的是至少一个空格，实际匹配的是多个空格，如果使用 group(1) 就会返回这个元组</li>
<li>我们想要的是 \d+，所以返回第二个元组，再将其转化为 float 即可</li>
<li>2021-10-28 20:11:01：搞定，小数部分也能保留</li>
</ul>
<h2 id=12-字符串开头结尾匹配>1.2 字符串开头/结尾匹配</h2>
<p>检查字符串开头或结尾的一个简单方法是使用 <code>str.startswith()</code> 或者是 <code>str.endswith()</code> 方法。</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=n>filename</span> <span class=o>=</span> <span class=s1>&#39;spam.txt&#39;</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>filename</span><span class=o>.</span><span class=n>endswith</span><span class=p>(</span><span class=s1>&#39;.txt&#39;</span><span class=p>)</span>
<span class=kc>True</span>
</code></pre></div><h1 id=2-文件操作>2. 文件操作</h1>
<h2 id=21-python-os-文件目录方法>2.1 Python OS 文件/目录方法</h2>
<p><strong>os</strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示</p>
<p><code>os.listdir(path)</code>，返回path指定的文件夹包含的文件或文件夹的名字的列表。</p>
<h1 id=3-绘图>3. 绘图</h1>
<h2 id=31-并列柱状图>3.1 并列柱状图</h2>
<p>绘制并列柱状图与堆叠柱状图类似，都是绘制多组柱体，只需要控制好每组柱体的位置和大小即可。例如：</p>
<p>:exclamation: 注意设置柱状图宽度不可忽略，否则无法正常显示</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
<span class=kn>import</span> <span class=nn>matplotlib.pyplot</span> <span class=k>as</span> <span class=nn>plt</span>

<span class=n>size</span> <span class=o>=</span> <span class=mi>5</span>
<span class=n>x</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>arange</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
<span class=n>a</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
<span class=n>b</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>
<span class=n>c</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>random</span><span class=p>(</span><span class=n>size</span><span class=p>)</span>

<span class=n>total_width</span><span class=p>,</span> <span class=n>n</span> <span class=o>=</span> <span class=mf>0.8</span><span class=p>,</span> <span class=mi>3</span>
<span class=n>width</span> <span class=o>=</span> <span class=n>total_width</span> <span class=o>/</span> <span class=n>n</span>
<span class=n>x</span> <span class=o>=</span> <span class=n>x</span> <span class=o>-</span> <span class=p>(</span><span class=n>total_width</span> <span class=o>-</span> <span class=n>width</span><span class=p>)</span> <span class=o>/</span> <span class=mi>2</span>

<span class=n>plt</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span>  <span class=n>width</span><span class=o>=</span><span class=n>width</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;a&#39;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=n>width</span><span class=p>,</span> <span class=n>b</span><span class=p>,</span> <span class=n>width</span><span class=o>=</span><span class=n>width</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;b&#39;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>bar</span><span class=p>(</span><span class=n>x</span> <span class=o>+</span> <span class=mi>2</span> <span class=o>*</span> <span class=n>width</span><span class=p>,</span> <span class=n>c</span><span class=p>,</span> <span class=n>width</span><span class=o>=</span><span class=n>width</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s1>&#39;c&#39;</span><span class=p>)</span>
<span class=n>plt</span><span class=o>.</span><span class=n>legend</span><span class=p>()</span>
<span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div>
<h1 id=4-调试>4. 调试</h1>
<h2 id=41-调试时需要输入>4.1 调试时需要输入</h2>
<h1 id=5-->5. (), [],</h1>
<h2 id=51--元组>5.1 () 元组</h2>
<p>代表tuple元祖数据类型，元祖是一种不可变序列。创建方法很简单，大多数时候都是小括号括起来的。</p>
<h2 id=52--列表>5.2 [] 列表</h2>
<p>代表list列表数据类型，列表是一种可变序列。创建方法既简单又特别。</p>
<h2 id=53--字典>5.3 {} 字典</h2>
<p>代表dict字典数据类型，字典是Python中唯一内建的映射类型。字典中的值没有特殊的顺序，但都是存储在一个特定的键（key）下。键可以是数字、字符串甚至是元祖。</p>
<h3 id=531-字典>5.3.1 字典</h3>
<p>字典的每个键值 <strong>key=>value</strong> 对用冒号 <strong>:</strong> 分割，每个键值对之间用逗号 <strong>,</strong> 分割，整个字典包括在花括号 <strong>{}</strong> 中 ,格式如下所示：</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=n>d</span> <span class=o>=</span> <span class=p>{</span><span class=n>key1</span> <span class=p>:</span> <span class=n>value1</span><span class=p>,</span> <span class=n>key2</span> <span class=p>:</span> <span class=n>value2</span> <span class=p>}</span>
</code></pre></div><p>相当于是键值对索引，key 只能是 <code>字符串，数字或元组</code></p>
<ul>
<li>python 中单引号和双引号字符串没有区别</li>
</ul>
<h3 id=532-用到了字典排序字典转化为-list>5.3.2 用到了字典排序、字典转化为 list</h3>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python>    <span class=c1>#按键(key)排序:</span>
    <span class=nb>sorted</span><span class=p>(</span><span class=n>y_lrr_dict</span><span class=p>)</span>
    <span class=nb>sorted</span><span class=p>(</span><span class=n>y_gto_dict</span><span class=p>)</span>
    <span class=nb>sorted</span><span class=p>(</span><span class=n>y_cory_dict</span><span class=p>)</span>
    <span class=n>y_lrr</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>y_lrr_dict</span><span class=p>)</span>
    <span class=n>y_gto</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>y_gto_dict</span><span class=p>)</span>
    <span class=n>y_cory</span><span class=o>=</span><span class=nb>list</span><span class=p>(</span><span class=n>y_cory_dict</span><span class=p>)</span>
</code></pre></div>
</div>
<div class=tags>
<ul class=flat>
<li><a href=/tags/python>Python</a></li>
<li><a href=/tags/%E5%8F%AF%E8%A7%86%E5%8C%96>可视化</a></li>
</ul>
</div></div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2021 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script>feather.replace()</script>
</body>
</html>