<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Ca2_lab1 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Ca2_lab1">
<meta itemprop=description content="0. 前言 很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。
1. Goal 主要是由两个目标
 实现 Cache Replacement Policy 中的 OPT 算法，也就是假设已经得知了对 cache line 的访问序列，每次都 evict 最久之后访问的那个 cache line 将 Sniper 中的 inclusive policy 改为 non-inclusive policy  通过这个 lab 更深刻地理解了一些 cache replacement, 模拟器中访问 cache 和内存的 flow, cache 的地址映射方式等等
2. 思路和 Report Optimal算法  首先，每一条指令的access操作都会经过函数 AccessSingleLine，在这个地方执行文件 IO 操作。  第一遍执行程序的时候进行文件写入（假设两次执行程序的指令序列是完全一样的），将指令的 set_index 和 tag 写入future_list.txt文件（预先将指令序列写入文件） 第二遍指令的时候，相当于我们是已知未来序列的，在第一次调用 AccessSingleLine 的时候，将文件读入一个二维数组future_list，存放所有指令的 set_index 和 tag。后续调用 AccessSingleLine 的时候不再进行文件 IO 操作（写一个条件判断，只执行一次文件 IO 操作）。 二维数组 future_list 中存放了指令 access 序列，将其在 class Cache 中定义，定义为 long long int 型的静态变量，并且有足够大的空间。   根据对 sniper 代码的阅读，此模拟器执行的是 LRU 替换算法，为了不大量修改一些函数接口和逻辑（比如当 cache 为空时的替换和替换算法的选择），我选择直接在 cache_set_lru."><meta itemprop=datePublished content="2021-07-28T16:09:45+08:00">
<meta itemprop=dateModified content="2021-07-28T16:09:45+08:00">
<meta itemprop=wordCount content="293">
<meta itemprop=keywords content="CA2,lab,"><meta property="og:title" content="Ca2_lab1">
<meta property="og:description" content="0. 前言 很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。
1. Goal 主要是由两个目标
 实现 Cache Replacement Policy 中的 OPT 算法，也就是假设已经得知了对 cache line 的访问序列，每次都 evict 最久之后访问的那个 cache line 将 Sniper 中的 inclusive policy 改为 non-inclusive policy  通过这个 lab 更深刻地理解了一些 cache replacement, 模拟器中访问 cache 和内存的 flow, cache 的地址映射方式等等
2. 思路和 Report Optimal算法  首先，每一条指令的access操作都会经过函数 AccessSingleLine，在这个地方执行文件 IO 操作。  第一遍执行程序的时候进行文件写入（假设两次执行程序的指令序列是完全一样的），将指令的 set_index 和 tag 写入future_list.txt文件（预先将指令序列写入文件） 第二遍指令的时候，相当于我们是已知未来序列的，在第一次调用 AccessSingleLine 的时候，将文件读入一个二维数组future_list，存放所有指令的 set_index 和 tag。后续调用 AccessSingleLine 的时候不再进行文件 IO 操作（写一个条件判断，只执行一次文件 IO 操作）。 二维数组 future_list 中存放了指令 access 序列，将其在 class Cache 中定义，定义为 long long int 型的静态变量，并且有足够大的空间。   根据对 sniper 代码的阅读，此模拟器执行的是 LRU 替换算法，为了不大量修改一些函数接口和逻辑（比如当 cache 为空时的替换和替换算法的选择），我选择直接在 cache_set_lru.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://huweim.github.io/posts/ca2_lab1/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-07-28T16:09:45+08:00">
<meta property="article:modified_time" content="2021-07-28T16:09:45+08:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Ca2_lab1">
<meta name=twitter:description content="0. 前言 很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。
1. Goal 主要是由两个目标
 实现 Cache Replacement Policy 中的 OPT 算法，也就是假设已经得知了对 cache line 的访问序列，每次都 evict 最久之后访问的那个 cache line 将 Sniper 中的 inclusive policy 改为 non-inclusive policy  通过这个 lab 更深刻地理解了一些 cache replacement, 模拟器中访问 cache 和内存的 flow, cache 的地址映射方式等等
2. 思路和 Report Optimal算法  首先，每一条指令的access操作都会经过函数 AccessSingleLine，在这个地方执行文件 IO 操作。  第一遍执行程序的时候进行文件写入（假设两次执行程序的指令序列是完全一样的），将指令的 set_index 和 tag 写入future_list.txt文件（预先将指令序列写入文件） 第二遍指令的时候，相当于我们是已知未来序列的，在第一次调用 AccessSingleLine 的时候，将文件读入一个二维数组future_list，存放所有指令的 set_index 和 tag。后续调用 AccessSingleLine 的时候不再进行文件 IO 操作（写一个条件判断，只执行一次文件 IO 操作）。 二维数组 future_list 中存放了指令 access 序列，将其在 class Cache 中定义，定义为 long long int 型的静态变量，并且有足够大的空间。   根据对 sniper 代码的阅读，此模拟器执行的是 LRU 替换算法，为了不大量修改一些函数接口和逻辑（比如当 cache 为空时的替换和替换算法的选择），我选择直接在 cache_set_lru.">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css>
<script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1>
<div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social">
<ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
<li>
<a href=/>Home</a>
</li>
<li>
<a href=/posts>All posts</a>
</li>
<li>
<a href=/categories/>Categories</a>
</li>
<li>
<a href=/archives>Archives</a>
</li>
<li>
<a href=/tags>Tags</a>
</li>
<li>
<a href=/about/>About</a>
</li>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>28</span>
<span class=rest>Jul 2021</span>
</div>
</div>
<div class=matter>
<h1 class=title>Ca2_lab1</h1>
</div>
</div>
<div class=markdown>
<h1 id=0-前言>0. 前言</h1>
<p>很久之前就想总结一下 Computer Architecture II (CA2) 这门课上学得一些东西了，尤其是关于这几个 lab。当时无论是在 Linux, C++, 还是体系结构方面，都帮助我加深了理解。现在试着整理也是复习一下，把他放在博客的文章中。</p>
<h1 id=1-goal>1. Goal</h1>
<p>主要是由两个目标</p>
<ul>
<li>实现 Cache Replacement Policy 中的 OPT 算法，也就是假设已经得知了对 cache line 的访问序列，每次都 evict 最久之后访问的那个 cache line</li>
<li>将 Sniper 中的 inclusive policy 改为 non-inclusive policy</li>
</ul>
<p>通过这个 lab 更深刻地理解了一些 cache replacement, 模拟器中访问 cache 和内存的 flow, cache 的地址映射方式等等</p>
<h1 id=2-思路和-report>2. 思路和 Report</h1>
<h2 id=optimal算法>Optimal算法</h2>
<ul>
<li>首先，每一条指令的access操作都会经过函数 AccessSingleLine，在这个地方执行文件 IO 操作。
<ul>
<li>第一遍执行程序的时候进行文件写入（假设两次执行程序的指令序列是完全一样的），将指令的 set_index 和 tag 写入future_list.txt文件（预先将指令序列写入文件）</li>
<li>第二遍指令的时候，相当于我们是<strong>已知未来序列</strong>的，在第一次调用 AccessSingleLine 的时候，将文件读入一个二维数组future_list，存放所有指令的 set_index 和 tag。后续调用 AccessSingleLine 的时候不再进行文件 IO 操作（写一个条件判断，只执行一次文件 IO 操作）。</li>
<li>二维数组 future_list 中存放了指令 access 序列，将其在 class Cache 中定义，定义为 long long int 型的静态变量，并且有足够大的空间。</li>
</ul>
</li>
<li>根据对 sniper 代码的阅读，此模拟器执行的是 LRU 替换算法，为了不大量修改一些函数接口和逻辑（比如当 cache 为空时的替换和替换算法的选择），我选择直接在 cache_set_lru.cc 中进行 optimal 算法的 coding，把 lru 思想换成 optimal 算法。
<ul>
<li>这样可以直接使用 isValid() 或者 isValidReplacement() 等函数</li>
</ul>
</li>
<li>关于 Optimal 算法的实现 getReplacementIndex
<ul>
<li>在 sniper 模拟器的 cache_set_lru.cc 中直接进行修改，设置一个全局变量 counter_getrep 用于记录当前处理的 access 指令是第几条。</li>
<li>getReplacementIndex 中第一个 for 循环可以直接用，首先是去找一个空的块，有空的块就可以直接用，但是刚插进来的 block需要调用 FindtheNextAccess（寻找下一次使用的位置，返回一个步长存入m_lru_bits[]）</li>
<li>之后的逻辑，如果这个 for 循环没有找到一个可以 return 的 index，那么就要用一个 for 循环，找到 set 中 next（m_lru_bits[i]）最大的 block 进行替换。用 index 记录这个最大的 next 的行号</li>
<li>找到了最大的这个即将被替换的 block，仍然需要先找到当前 access（即将被插入的 block）的 next，所以需要执行FindtheNextAccess（类似于 LRU 中的 movetoMRU），找到当前 access 指令的 next 后，存入 m_lru_bits[i]。</li>
</ul>
</li>
</ul>
<h2 id=inclusive-to-non-inclusive>Inclusive to Non-inclusive</h2>
<p>​ There must be an interface related to inclusive policy in the replacement algorithm. So focus on the parameters <strong>qbs_reject</strong> and <strong>attempt</strong>. The processing of inclusive policy may be included in <strong>isInLowerLevelCache</strong>. Therefore, the solution I chose is to set <strong>qbs_reject</strong> to false, that is, not to follow the conditional branch of if execution. After comparing the cache miss data before and after performing this operation, I found that this operation hardly affects the miss rate of L1 and L2 Cache. Therefore, the judgment about the interface of the inclusive policy must be in the replacement policy is not necessarily correct.</p>
<p>​ Inclusive to Non-inclusive 的修改没有成功</p>
<h1 id=3-result>3. Result</h1>
<p>实际上这个 lab 做的不算成功，我自己的 OPT 算法和原始的 LRU 相比，减少了 L2 TLB 的 miss rate，而 L1-I Cache 和 L1-D Cache 的表现反而更差了。</p>
<p>.</p>
<p>​ miss rate of LRU(left) miss rate of OPT(right)</p>
</div>
<div class=tags>
<ul class=flat>
<li><a href=/tags/ca2>CA2</a></li>
<li><a href=/tags/lab>lab</a></li>
</ul>
</div></div>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2021 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script>feather.replace()</script>
</body>
</html>