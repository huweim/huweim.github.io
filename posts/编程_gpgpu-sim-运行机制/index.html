<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>GPGPU-Sim 运行机制 - Cory Code</title><meta name=viewport content="width=device-width,initial-scale=1"><meta itemprop=name content="GPGPU-Sim 运行机制"><meta itemprop=description content="0. 前言 在 GPGPU-Sim 跑一些比较大的 benchmark, 或者想要同时跑很多组 benchmark 的时候，在自己的电脑上跑，或者在虚拟机上运行的话速度肯定达不到要求，会成为工作中瓶颈。因此了解一下如何在服务器上跑 simulation, 以及如何提高运行 benchmark 的速度。
1. GPGPU-Sim 运行机制 首先要理解 application 是如何运行在 real machine 以及 GPGPU-Sim 上的，他们的区别在哪里？这里以 CUDA 代码为例。
GPGPU-Sim_vs_Real_Machine
1.1 Real Machine CUDA application 分为 host code and device code, 使用 nvcc 编译 .cu 代码时, 会将 host code 和 device code 分开。device code 被编译为 .ptx 文件，再通过 ptxas 编译为 cubin.bin 文件。host code, libcuda.a, cubin.bin 文件由 C/C++编译器编译了解生成可执行文件。
如何运行 CUDA application? 调用 libcuda 内的接口以在 GPU 上运行 device code."><meta itemprop=datePublished content="2021-09-28T13:39:14+08:00"><meta itemprop=dateModified content="2021-09-28T13:39:14+08:00"><meta itemprop=wordCount content="109"><meta itemprop=keywords content="GPGPU-Sim,"><meta property="og:title" content="GPGPU-Sim 运行机制"><meta property="og:description" content="0. 前言 在 GPGPU-Sim 跑一些比较大的 benchmark, 或者想要同时跑很多组 benchmark 的时候，在自己的电脑上跑，或者在虚拟机上运行的话速度肯定达不到要求，会成为工作中瓶颈。因此了解一下如何在服务器上跑 simulation, 以及如何提高运行 benchmark 的速度。
1. GPGPU-Sim 运行机制 首先要理解 application 是如何运行在 real machine 以及 GPGPU-Sim 上的，他们的区别在哪里？这里以 CUDA 代码为例。
GPGPU-Sim_vs_Real_Machine
1.1 Real Machine CUDA application 分为 host code and device code, 使用 nvcc 编译 .cu 代码时, 会将 host code 和 device code 分开。device code 被编译为 .ptx 文件，再通过 ptxas 编译为 cubin.bin 文件。host code, libcuda.a, cubin.bin 文件由 C/C++编译器编译了解生成可执行文件。
如何运行 CUDA application? 调用 libcuda 内的接口以在 GPU 上运行 device code."><meta property="og:type" content="article"><meta property="og:url" content="https://huweim.github.io/posts/%E7%BC%96%E7%A8%8B_gpgpu-sim-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-28T13:39:14+08:00"><meta property="article:modified_time" content="2021-09-28T13:39:14+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="GPGPU-Sim 运行机制"><meta name=twitter:description content="0. 前言 在 GPGPU-Sim 跑一些比较大的 benchmark, 或者想要同时跑很多组 benchmark 的时候，在自己的电脑上跑，或者在虚拟机上运行的话速度肯定达不到要求，会成为工作中瓶颈。因此了解一下如何在服务器上跑 simulation, 以及如何提高运行 benchmark 的速度。
1. GPGPU-Sim 运行机制 首先要理解 application 是如何运行在 real machine 以及 GPGPU-Sim 上的，他们的区别在哪里？这里以 CUDA 代码为例。
GPGPU-Sim_vs_Real_Machine
1.1 Real Machine CUDA application 分为 host code and device code, 使用 nvcc 编译 .cu 代码时, 会将 host code 和 device code 分开。device code 被编译为 .ptx 文件，再通过 ptxas 编译为 cubin.bin 文件。host code, libcuda.a, cubin.bin 文件由 C/C++编译器编译了解生成可执行文件。
如何运行 CUDA application? 调用 libcuda 内的接口以在 GPU 上运行 device code."><link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://huweim.github.io/css/main.css><link id=dark-scheme rel=stylesheet type=text/css href=https://huweim.github.io/css/dark.css><script src=https://huweim.github.io/js/feather.min.js></script>
<script src=https://huweim.github.io/js/main.js></script></head><body><div class="container wrapper"><div class=header><h1 class=site-title><a href=https://huweim.github.io/>Cory Code</a></h1><div class=site-description><p>Minimal and Clean <a href=https://github.com/athul/hugo-ink>blog theme for Hugo</a></p><nav class="nav social"><ul class=flat><li><a href=https://github.com/huweim title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/athulcajay/ title=Twitter><i data-feather=twitter></i></a></li><li><a href=https://gitlab.com/athul/ title=GitLab><i data-feather=gitlab></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul></nav></div><nav class=nav><ul class=flat><li><a href=/>Home</a></li><li><a href=/posts>All posts</a></li><li><a href=/categories/>Categories</a></li><li><a href=/archives>Archives</a></li><li><a href=/tags>Tags</a></li><li><a href=/about/>About</a></li></ul></nav></div><div class=post><div class=post-header><div class=meta><div class=date><span class=day>28</span>
<span class=rest>Sep 2021</span></div></div><div class=matter><h1 class=title>GPGPU-Sim 运行机制</h1></div></div><div class=markdown><h1 id=0-前言>0. 前言</h1><p>在 GPGPU-Sim 跑一些比较大的 benchmark, 或者想要同时跑很多组 benchmark 的时候，在自己的电脑上跑，或者在虚拟机上运行的话速度肯定达不到要求，会成为工作中瓶颈。因此了解一下如何在服务器上跑 simulation, 以及如何提高运行 benchmark 的速度。</p><h1 id=1-gpgpu-sim-运行机制>1. GPGPU-Sim 运行机制</h1><p>首先要理解 application 是如何运行在 real machine 以及 GPGPU-Sim 上的，他们的区别在哪里？这里以 CUDA 代码为例。</p><p>GPGPU-Sim_vs_Real_Machine</p><h2 id=11-real-machine>1.1 Real Machine</h2><p>CUDA application 分为 host code and device code, 使用 nvcc 编译 .cu 代码时, 会将 host code 和 device code 分开。device code 被编译为 .ptx 文件，再通过 ptxas 编译为 cubin.bin 文件。host code, libcuda.a, cubin.bin 文件由 C/C++编译器编译了解生成可执行文件。</p><p>如何运行 CUDA application? 调用 libcuda 内的<strong>接口</strong>以在 GPU 上运行 device code.</p><h2 id=12-gpgpu-sim>1.2 GPGPU-Sim</h2><p>编译 GPGPU-Sim 会生成自己的 libcuda.so 库文件，通过 <code>ldd Your_application</code> 可以看到 libcudart.so.4.2 链接到模拟器的这个库文件。该库文件实现了 CUDA Runtime 函数库内大部分函数的重定义。</p><p>如何运行 CUDA application? 通过 libcuda 调用 GPGPU-Sim 内的<strong>模拟接口</strong>，实现在 GPGPU-Sim 上运行 CUDA appliaction.</p><h2 id=13-主要区别>1.3 主要区别</h2><h1 id=reference>Reference</h1><p><a href=https://blog.csdn.net/litdaguang/article/details/50002325>https://blog.csdn.net/litdaguang/article/details/50002325</a> GPGPU-Sim（番外）-如何加快GPGPU-Sim的运行速度</p><p><a href=https://blog.csdn.net/litdaguang/article/details/50012775>https://blog.csdn.net/litdaguang/article/details/50012775</a> GPGPU-Sim（番外）-GPGPU-Sim的模拟机制</p><p><a href=https://www.findhao.net/easycoding/2404>https://www.findhao.net/easycoding/2404</a> 在docker里跑gpgpusim</p></div><div class=tags><ul class=flat><li><a href=/tags/gpgpu-sim>GPGPU-Sim</a></li></ul></div></div></div><div class="footer wrapper"><nav class=nav><div>2022 © Athul | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div></nav></div><script>feather.replace()</script></body></html>