<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>GPGPU-Sim on Weiming Hu</title><link>https://huweim.github.io/tags/gpgpu-sim/</link><description>Recent content in GPGPU-Sim on Weiming Hu</description><generator>Hugo</generator><language>en</language><lastBuildDate>Sun, 05 Jan 2025 07:37:26 +0000</lastBuildDate><atom:link href="https://huweim.github.io/tags/gpgpu-sim/index.xml" rel="self" type="application/rss+xml"/><item><title>编译运行ISPASS2009、Rodinia、Parboil</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</link><pubDate>Wed, 08 Dec 2021 09:45:02 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</guid><description>&lt;h1 id="ispass">ISPASS&lt;/h1>
&lt;p>Ubuntu20.04下使用GPGPU-Sim运行ISPASS2009benchmark&lt;/p>
&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>之前介绍了安装，现在就尝试跑一下 ISPASS'09 的那篇经典 paper，Analyzing CUDA workloads using a detailed GPU simulator 上的几个 benchamrk. 这篇文章1.现在已经870次引用了，很多工作都使用了其中的 benchmark&lt;/p></description></item><item><title>GPGPU-Sim中的CTA &amp; warp scheduling</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_gpgpu-sim%E4%B8%AD%E7%9A%84cta--warp-scheduling/</link><pubDate>Sun, 14 Nov 2021 20:42:52 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_gpgpu-sim%E4%B8%AD%E7%9A%84cta--warp-scheduling/</guid><description>&lt;h1 id="cta-scheduling">CTA Scheduling&lt;/h1>
&lt;p>CTA/Thread Block/Work Group&lt;/p>
&lt;p>调度发生在 &lt;code>shader_core_ctx::issue_block2core(...)&lt;/code>，&lt;code>shader_core_config::max_cta(...)&lt;/code> 计算 core 中能容纳的 max CTA。这个取决于各硬件资源的短板，在报告中能看到是被什么限制了。&lt;/p></description></item><item><title>Software Design of GPGPU-Sim</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</link><pubDate>Sun, 14 Nov 2021 20:35:44 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</guid><description>&lt;p>4 Software Design of GPGPU-Sim&lt;/p>
&lt;p>所有标题都可以升一级，整个文档全是 manual 的第 4 章&lt;/p>
&lt;h1 id="1-file-list-and-brief-description">1. File list and brief description&lt;/h1>
&lt;ul>
&lt;li>cuda-sim - The functional simulator that executes PTX kernels generated by NVCC or OpenCL compiler&lt;/li>
&lt;li>gpgpu-sim - The performance simulator that simulates the timing behavior of a GPU (or other many core accelerator architectures)&lt;/li>
&lt;li>intersim - The interconnection network simulator adopted from Bill Dally&amp;rsquo;s BookSim&lt;/li>
&lt;/ul>
&lt;h2 id="11-overallutilities">1.1 Overall/Utilities&lt;/h2>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>abstract_hardware_model.h abstract_hardware_model.cc&lt;/th>
 &lt;th>Provide a set of classes that interface between functional and timing simulator.&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>shader.h &lt;!-- raw HTML omitted -->shader.cc&lt;/td>
 &lt;td>SIMT core timing model. It calls cudu-sim for functional simulation of a particular thread and cuda-sim would return with performance-sensitive information for the thread.&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>visualizer.h &lt;!-- raw HTML omitted -->visualizer.cc&lt;/td>
 &lt;td>Output dynamic statistics for the visualizer&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="13-gpgpu-sim">1.3 gpgpu-sim&lt;/h2>
&lt;p>几个需要注意的列出来，gluing 时钟频率，注意有单独的 gpu-cache.cc 和 l2cache.cc&lt;/p></description></item><item><title>GPU_benchmark说明（转）</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</link><pubDate>Sun, 14 Nov 2021 20:34:48 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>本文内容主要系摘录翻译自&lt;a href="http://parse.ele.tue.nl/ali">Ang Li&lt;/a>的博士毕业论文。&lt;/p>
&lt;h1 id="1perfect">1.Perfect&lt;/h1>
&lt;p>Power Efficiency Revolution for Embedded Computing&lt;/p>
&lt;p>&lt;a href="http://hpc.pnl.gov/PERFECT/">http://hpc.pnl.gov/PERFECT/&lt;/a>&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th style="text-align: left">&lt;strong>Application Domains&lt;/strong>&lt;/th>
 &lt;th style="text-align: left">&lt;strong>Kernels&lt;/strong>&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td style="text-align: left">PERFECT Application 1&lt;/td>
 &lt;td style="text-align: left">Discrete Wavelet Transform&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">2D Convolution&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Histogram Equalization&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Space Time Adaptive Processing&lt;/td>
 &lt;td style="text-align: left">System Solver&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Inner Product&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Outer Product&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Synthetic Aperture Radar&lt;/td>
 &lt;td style="text-align: left">Interpolation 1&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Interpolation 2&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Back Projection (Non-Fourier SAR)&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Wide Area Motion Imaging&lt;/td>
 &lt;td style="text-align: left">Debayer&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Image Registration&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">Change Detection&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">Required Kernels&lt;/td>
 &lt;td style="text-align: left">Sort&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">FFT 1D&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td style="text-align: left">&lt;/td>
 &lt;td style="text-align: left">FFT 2D&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h1 id="2-axbench">2. AxBench&lt;/h1>
&lt;p>A Multiplatform Benchmark Suite for Approximate Computing&lt;/p></description></item><item><title>GPGPU-Sim源码阅读</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Tue, 28 Sep 2021 15:51:46 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>&lt;h1 id="1-shadercc">1. Shader.cc&lt;/h1>
&lt;p>shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等&lt;/p>
&lt;p>m_stats 也就是 shader_core_stats 类型的变量&lt;/p>
&lt;p>num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量&lt;/p></description></item><item><title>文档_GPGPU-sim - Performance Simulation Engine</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_gpgpu-sim---performance-simulation-engine/</link><pubDate>Tue, 28 Sep 2021 14:59:35 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_gpgpu-sim---performance-simulation-engine/</guid><description>&lt;p>GPGPU-sim - Performance Simulation Engine&lt;/p>
&lt;h1 id="1-performance-model-software-objects">1 Performance Model Software Objects&lt;/h1>
&lt;div class="highlight-container">

 &lt;button class="copy-code-btn outline">Copy&lt;/button>

 
 &lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>ldst_unit &lt;span style="color:#f92672">*&lt;/span>m_ldst_unit;&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;/div>
&lt;p>前面的 m 可能表示这个类型的变量&lt;/p>
&lt;h2 id="12-simt-core-class">1.2 SIMT Core Class&lt;/h2>
&lt;p>SIMT Core 中的微架构在 shader.h/cc 的类 shader_core_ctx 中实现&lt;/p>
&lt;ul>
&lt;li>shd_warp_t objects 的集合用于建模每个 warp 在 core 中的状态&lt;/li>
&lt;li>simt_stack object, 处理每个 warp 的分支&lt;/li>
&lt;li>set of scheduler_unit obj, 选择 set 中 warp 的一条 or 多条指令发射执行&lt;/li>
&lt;li>Scoreboard obj 处理 data hazard&lt;/li>
&lt;li>opndcoll_rfu_t obj, model operand collector&lt;/li>
&lt;li>set of &lt;code>simd_function_unit&lt;/code> obj 实现 ALU pipeline&lt;/li>
&lt;li>&lt;code>ldst_unit&lt;/code> 实现 memory pipeline&lt;/li>
&lt;li>&lt;code>shader_memroy_interface&lt;/code> 将 SIMT Core 连接到相应的 SIMT Core Cluster&lt;/li>
&lt;/ul>
&lt;p>每个 core cycle, 调用 &lt;code>shader_core_ctx::cycle()&lt;/code> 来模拟 SIMT Core 的一个 cycle。cycle function 以按从下往上的顺序 (也就是从 writeback() 到 fetch()) 调用下列函数&lt;/p></description></item><item><title>GPGPU-Sim 运行机制</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</link><pubDate>Tue, 28 Sep 2021 13:39:14 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>在 GPGPU-Sim 跑一些比较大的 benchmark, 或者想要同时跑很多组 benchmark 的时候，在自己的电脑上跑，或者在虚拟机上运行的话速度肯定达不到要求，会成为工作中瓶颈。因此了解一下如何在服务器上跑 simulation, 以及如何提高运行 benchmark 的速度。&lt;/p></description></item><item><title>搭建GPGPU-Sim实验环境</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E6%90%AD%E5%BB%BAsim%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker/</link><pubDate>Mon, 27 Sep 2021 22:54:06 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E6%90%AD%E5%BB%BAsim%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker/</guid><description>&lt;h1 id="服务器">服务器&lt;/h1>
&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>第一个思路是&lt;/p>
&lt;ul>
&lt;li>服务器OS-&amp;gt;Docker Container-&amp;gt;Ubuntu中运行GPGPU-Sim。&lt;/li>
&lt;li>Docker Container update Docker Image-&amp;gt;Docker Image-&amp;gt;XXX.tar-&amp;gt;复制到你的电脑Windows-&amp;gt;复制到你的虚拟机Ubuntu-&amp;gt;XXX.tar-&amp;gt;Docker Image-&amp;gt;Docker Container-&amp;gt;Ubuntu中运行GPGPU-Sim-&amp;gt;修改GPGPU-Sim&lt;/li>
&lt;li>然后同样使用上述过程移植到服务器，运行&lt;/li>
&lt;/ul>
&lt;p>这样是有问题的。首先这个过程没有意义，如果这样在你自己的虚拟机里面运行Docker, 那么仍然是命令行界面，和在服务器上运行的区别在哪？&lt;/p></description></item><item><title>SIMT_Core</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_simt_core/</link><pubDate>Sat, 04 Sep 2021 19:04:57 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_simt_core/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>搞懂 SIMT Core 对于理解 GPGPU 的指令 fetch、指令发射、内存访问、数据传输等步骤非常重要，按照 GPGPU-Sim 的官方文档进行一个简单的梳理&lt;/p>
&lt;p>SIMT Core 的微架构模型中有几个比较重要的硬件单元，接下来会一一介绍他们的作用，&lt;/p></description></item><item><title>Ubuntu 20.04 下安装运行 GPGPU-Sim</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_ubuntu-20.04-%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-gpgpu-sim/</link><pubDate>Mon, 10 May 2021 15:17:51 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_ubuntu-20.04-%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BF%90%E8%A1%8C-gpgpu-sim/</guid><description>&lt;h3 id="0-前言">&lt;strong>0. 前言&lt;/strong>&lt;/h3>
&lt;p>最近因为课程 Project 需要使用 GPGPU-Sim 复现一篇 paper，在之后的课题中可能也会用到这个模拟器。所以收集了相关资料以搭建 GPGPU-Sim 的环境并运行 Demo。GPGPU-Sim 的参考资料实在是不多，主要参考了&lt;a href="http://gpgpu-sim.org/manual/index.php/Main_Page">官方文档&lt;/a>、&lt;a href="https://github.com/gpgpu-sim/gpgpu-sim_distribution">Github 中 README 文件&lt;/a>，还有一些相关的 Blog。&lt;/p></description></item></channel></rss>