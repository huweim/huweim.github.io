<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cory Code</title><link>https://huweim.github.io/</link><description>Recent content on Cory Code</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 10 Jun 2022 15:27:08 +0800</lastBuildDate><atom:link href="https://huweim.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://huweim.github.io/about/</link><pubDate>Thu, 08 Jul 2021 17:46:31 +0800</pubDate><guid>https://huweim.github.io/about/</guid><description>&lt;p>oh man, I love computer science and coding.&lt;/p>
&lt;p>一个计算机体系结构方向的学生，喜欢体系结构，喜欢编程，喜欢篮球。目前的课题主要关注 GPU/GPGPU。&lt;/p>
&lt;p>不确定自己是否喜欢折腾，是否喜欢新鲜事物，是否擅长编程。希望在一步一步探索中找到自己真正感兴趣的事情，或者确定这就是自己真正感兴趣的事情。&lt;/p></description></item><item><title>VSCode, Chrome 常用快捷键</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_%E5%BF%AB%E6%8D%B7%E9%94%AE_vscode_chrome/</link><pubDate>Fri, 10 Jun 2022 15:27:08 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_%E5%BF%AB%E6%8D%B7%E9%94%AE_vscode_chrome/</guid><description>&lt;h1 id="1-vscode">1. VSCode&lt;/h1>
&lt;p>&lt;strong>目前生疏但是需要常用的&lt;/strong> 2022-06-10 15:14:48&lt;/p>
&lt;ul>
&lt;li>⭐ 选择所有当前选中的字符（可以理解为全局版的 Ctrl + D）: Ctrl + Shift + L&lt;/li>
&lt;li>在选中行末尾插入光标：Alt + Shift + i&lt;/li>
&lt;li>在右侧打开 Markdown 预览：Ctrl + K, V&lt;/li>
&lt;li>查看定义：Alt + F12；只是小窗查看，比较方便，注意跳转和查看的区别&lt;/li>
&lt;li>重新打开最后关闭的标签页：Ctrl + Shift + T&lt;/li>
&lt;li>向左切换标签：Ctrl + Tab / Ctrl + PgDn&lt;/li>
&lt;li>向右切换标签：Ctrl + Shift + Tab / Ctrl + PgUp&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>快捷键的意义不在于记住每一个键位，而是你需要知道某个操作是可以通过快捷键达到的。当你需要多次重复这个操作时，可以去查找这个快捷键。&lt;/p>
&lt;/blockquote>
&lt;h2 id="11-编辑">1.1 编辑&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>选中当前单词 Ctrl + D，多次按的话可以批量更改变量&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⭐ 选择所有当前选中的字符（可以理解为全局版的 Ctrl + D）: Ctrl + Shift + L&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选择所有出现的当前单词：Ctrl + F2；不用选中，光标放在单词上即可，相当于先 Ctrl + D 然后 Ctrl + Shift + L&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>控制台终端显示与隐藏&lt;/strong>：Ctrl + ~&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>选中代码 ：&lt;/strong> Shift + Home/End/方向键 （配置 Ctrl 使用效果更佳）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>全局替换：&lt;/strong> Ctrl + Shift + H&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分屏 Ctrl + \&lt;/p>
&lt;/li>
&lt;li>
&lt;p>合并分屏 Ctrl + Alt + \&lt;/p>
&lt;/li>
&lt;li>
&lt;p>重新打开最后关闭的标签页：Ctrl + Shift + T&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在选中行末尾插入光标/也就是 1.3 中的多行编辑：Alt + Shift + i&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在右侧打开 Markdown 预览：Ctrl + K, V&lt;/p>
&lt;/li>
&lt;li>
&lt;p>向左切换标签：Ctrl + Tab / Ctrl + PgDn&lt;/p>
&lt;/li>
&lt;li>
&lt;p>向右切换标签：Ctrl + Shift + Tab / Ctrl + PgUp&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按单词跳转 ⭐ Ctrl + 方向键&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这个非常常用，可以快速地在单行的单词之前跳转光标&lt;/p>
&lt;/blockquote>
&lt;p>行操作&lt;/p>
&lt;ul>
&lt;li>&lt;strong>复制当前行&lt;/strong>：Shift + Alt + Up/Down / Ctrl + C&lt;/li>
&lt;li>剪切当前行 Ctrl + X&lt;/li>
&lt;li>&lt;strong>删除当前行&lt;/strong>：Shift + Ctrl + K&lt;/li>
&lt;li>选择整行 Ctrl + L&lt;/li>
&lt;li>移动选中的行：Alt + Up/Down&lt;/li>
&lt;li>跳转到指定行 Ctrl + G&lt;/li>
&lt;/ul>
&lt;h2 id="12-编程">1.2 编程&lt;/h2>
&lt;ul>
&lt;li>Go to definition: Ctrl + 鼠标左键/F12&lt;/li>
&lt;li>显示所有引用：Shift + F12&lt;/li>
&lt;li>跳转到光标的上一个位置： Alt + 方向键←&lt;/li>
&lt;li>参数提示：Ctrl + Shift + Space&lt;/li>
&lt;li>查看定义：Alt + F12；只是小窗查看，比较方便，注意跳转和查看的区别&lt;/li>
&lt;/ul>
&lt;h2 id="13-多行编辑">1.3 多行编辑&lt;/h2>
&lt;p>Step&lt;/p>
&lt;ul>
&lt;li>选中多行；可以用鼠标，也可以用 Ctrl + Shift + 方向键/Home/End&lt;/li>
&lt;li>按下快捷键 Alt + Shift + i，进入多行编辑状态&lt;/li>
&lt;/ul>
&lt;h2 id="14-文件">1.4 文件&lt;/h2>
&lt;p>打开新窗口：Ctrl + N
打开文件：Ctrl + P
选择文件：Ctrl + O
最近打开的 workplace: Ctrl + R&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h1 id="2-chrome">2. Chrome&lt;/h1>
&lt;p>&lt;strong>最常用&lt;/strong>并且目前比较生疏 2022-06-10 14:45:52&lt;/p>
&lt;ul>
&lt;li>新建标签页：Ctrl + T&lt;/li>
&lt;li>向左切换标签：Ctrl + Tab / Ctrl + PgDn&lt;/li>
&lt;li>向右切换标签：Ctrl + Shift + Tab / Ctrl + PgUp&lt;/li>
&lt;li>跳转到地址栏：Ctrl + l / Alt + D / F6&lt;/li>
&lt;/ul>
&lt;h2 id="21-标签和窗口">2.1 标签和窗口&lt;/h2>
&lt;p>个人认为会比较常用的&lt;/p>
&lt;ul>
&lt;li>新建标签页：Ctrl + T&lt;/li>
&lt;li>重新打开最后关闭的标签页：Ctrl + Shift + T&lt;/li>
&lt;li>向左切换标签：Ctrl + Tab / Ctrl + PgDn&lt;/li>
&lt;li>向右切换标签：Ctrl + Shift + Tab / Ctrl + PgUp&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>2022-06-10 14:24:50，向左右切换标签正是在寻找的功能，这个也可以用在 VSCode 窗口中使用。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>在新的后台标签页中打开链接：Ctrl + 单击 / 鼠标滚轮单机&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>可以代替 右键 -&amp;gt; 在新标签页中打开链接&lt;/p>
&lt;/blockquote>
&lt;p>其他&lt;/p>
&lt;ul>
&lt;li>新建窗口：Ctrl + N&lt;/li>
&lt;li>新建无痕窗口：Ctrl + Shift + N&lt;/li>
&lt;li>标签内打开 Home 页面：Alt + Home&lt;/li>
&lt;li>最小化当前窗口：Alt + 空格键 + N&lt;/li>
&lt;li>最大化当前窗口：Alt + 空格键 + X&lt;/li>
&lt;li>在新窗口打开链接： Shift + 单击&lt;/li>
&lt;/ul>
&lt;h2 id="22-功能">2.2 功能&lt;/h2>
&lt;p>个人认为常用，好像没有特别常用的。。&lt;/p>
&lt;p>其他&lt;/p>
&lt;ul>
&lt;li>下载内容：Ctrl + J&lt;/li>
&lt;li>历史记录：Ctrl + H&lt;/li>
&lt;li>开发者工具：F12 / Ctrl + Shift + J / Ctrl + Shift + I&lt;/li>
&lt;li>保存网页：Ctrl + S&lt;/li>
&lt;li>添加书签：Ctrl + D&lt;/li>
&lt;li>添加所有打开的网页添加书签：Ctrl + Shift + D&lt;/li>
&lt;li>书签管理器：Ctrl + Shift + O&lt;/li>
&lt;li>用浏览器打开文件：Ctrl + O&lt;/li>
&lt;li>任务管理器：Shift + Esc&lt;/li>
&lt;li>清除历史记录：Ctrl + Shift + Del&lt;/li>
&lt;/ul>
&lt;h2 id="23-地址栏">2.3 地址栏&lt;/h2>
&lt;p>&lt;strong>个人认为常用&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>地址栏搜索：Ctrl + K / Ctrl + E&lt;/li>
&lt;li>跳转到地址栏：Ctrl + l / Alt + D / F6&lt;/li>
&lt;li>站内搜索：关键字 + site：网址&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>快速跳转到地址栏是需要掌握的
站内搜索：关键字 + site：网址，这个如果使用 google 需要翻墙，并不是单纯地字符串匹配。&lt;/p>
&lt;/blockquote>
&lt;p>其他&lt;/p>
&lt;ul>
&lt;li>使用其他搜索引擎进行搜索：Tab&lt;/li>
&lt;li>为网站名称添加 www. 和 .com：Ctrl + Enter&lt;/li>
&lt;/ul>
&lt;h2 id="24-页面">2.4 页面&lt;/h2>
&lt;p>个人认为常用&lt;/p>
&lt;ul>
&lt;li>搜索：Ctrl + F&lt;/li>
&lt;li>刷新：Ctrl + R / F5 / Ctrl + F5&lt;/li>
&lt;li>调整页面字体大小：Ctrl + &amp;lsquo;&amp;rsquo;+&amp;rsquo;&amp;rsquo; / Ctrl + &amp;lsquo;&amp;rsquo;-&amp;rsquo;&amp;rsquo; 或者 Ctrl + 鼠标滚轮上/下&lt;/li>
&lt;/ul>
&lt;p>其他&lt;/p>
&lt;ul>
&lt;li>先下翻页：PgUp&lt;/li>
&lt;li>向上翻页：PgDn&lt;/li>
&lt;li>滑动到最顶部：Home&lt;/li>
&lt;li>滑动到最底部：End&lt;/li>
&lt;li>打印：Ctrl + P&lt;/li>
&lt;li>页面字体恢复默认：Ctrl + 0&lt;/li>
&lt;li>全屏切换：F11&lt;/li>
&lt;/ul>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/43730820#:~:text=Chrome%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%201%20%E5%90%8C%E4%B8%AA%E7%AA%97%E5%8F%A3%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE%EF%BC%9ACtrl%20%2B%20T%202%20%E9%87%8D%E6%96%B0%E6%89%93%E5%BC%80%E6%9C%80%E5%90%8E%E5%85%B3%E9%97%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5%EF%BC%9ACtrl,%2F%20Ctrl%20%2B%20Shift%20%2B%20...%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20">https://zhuanlan.zhihu.com/p/43730820#:~:text=Chrome%20%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8%201%20%E5%90%8C%E4%B8%AA%E7%AA%97%E5%8F%A3%E6%96%B0%E5%BB%BA%E6%A0%87%E7%AD%BE%EF%BC%9ACtrl%20%2B%20T%202%20%E9%87%8D%E6%96%B0%E6%89%93%E5%BC%80%E6%9C%80%E5%90%8E%E5%85%B3%E9%97%AD%E7%9A%84%E6%A0%87%E7%AD%BE%E9%A1%B5%EF%BC%9ACtrl,%2F%20Ctrl%20%2B%20Shift%20%2B%20...%20%E6%9B%B4%E5%A4%9A%E7%BB%93%E6%9E%9C...%20&lt;/a>&lt;/p></description></item><item><title>（转载）MLSys 个方向综述</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E8%BD%AC%E8%BD%BDmlsys-%E4%B8%AA%E6%96%B9%E5%90%91%E7%BB%BC%E8%BF%B0/</link><pubDate>Mon, 09 May 2022 22:17:43 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E8%BD%AC%E8%BD%BDmlsys-%E4%B8%AA%E6%96%B9%E5%90%91%E7%BB%BC%E8%BF%B0/</guid><description>&lt;p>最近在试着寻找ML + sys可做的方向，发现涉及到的坑太多了，有点眼花缭乱的感觉&amp;hellip;&amp;hellip;不如写点东西总结一哈，帮自己理一下思路。&lt;/p>
&lt;p>个人感觉MLsys不能算是一种方向，而是一种思路&amp;hellip;&amp;hellip;比如对于system研究者来说，可以把ML作为我们开发的系统要适配的一种benchmark，就像transaction对于数据库、某种文件场景对于File System的意义一样。这样一想可做的空间就宽广多了。就算ML哪天又进入寒冬，之前所学的技术也仍然是可持续的。传统的system研究者也应该适应这个潮流，不能简单的把MLsys一律归为大水漫灌..&lt;/p>
&lt;p>有很多topic我也是初次接触，还不是很熟悉。如有错误还请批评指点~&lt;/p>
&lt;h1 id="1-分布式机器学习distributed-dnn-training">1. 分布式机器学习（Distributed DNN Training）&lt;/h1>
&lt;p>这个又可以分为两个方面：from ML / system perspective。安利一下刘铁岩老师的《分布式机器学习》这本书（[ch_]表示引用这本书中的一些章节），还有UCB cs294 19fall的这一节。&lt;/p>
&lt;h2 id="11-ml">1.1 ML&lt;/h2>
&lt;p>从ML的角度做，主要是发明或改进分布式训练算法[ch4] [ch5]，保证在分布式加速的同时，仍然能达到原来的学习效果（loss/accuracy）。因此很多工作也被投在像ICML、NIPS这种专业ML会议上。主要用到的方法包括优化（optimization）和统计学习理论（statistical learning theory）。&lt;/p>
&lt;p>还有一类工作涉及到如何把单机算法改造成分布式[ch9]，比如同步/异步SGD等。这里主要涉及到的问题是如何降低分布式环境下的通信开销，提高加速比。&lt;/p>
&lt;p>这方面了解不多就少写点了&amp;hellip; 可以参考这里。&lt;/p>
&lt;h2 id="12-system">1.2 System&lt;/h2>
&lt;p>还有一个就是从System的角度做。从分布式计算的角度来看，可以把相关工作分为以下几类：&lt;/p>
&lt;p>对于计算量太大的场景（计算并行），可以多线程/多节点并行计算，多节点共享公共的存储空间。常用的一个算法就是同步随机梯度下降（synchronous stochastic gradient descent），含义大致相当于K个（K是节点数）mini-batch SGD [ch6.2]
对于训练数据太多，单机放不下的场景（数据并行，也是最主要的场景），需要将数据划分到多个节点上训练。每个节点先用本地的数据先训练出一个子模型，同时和其他节点保持通信（比如更新参数）以保证最终可以有效整合来自各个节点的训练结果，并得到全局的ML模型。 [ch6.3]
对于模型太大的场景，需要把模型（例如NN中的不同层）划分到不同节点上进行训练。此时不同节点之间可能需要频繁的sync。这个叫做模型并行。 [ch6.4]
Pipeline Parallelism：这是去年（SOSP19 PipeDream）才出现的概念，参考这里的第90、95页 以及这里的简介。Pipeline Parallelism相当于把数据并行和模型并行结合起来，把数据划分成多个chunk，也把训练模型的过程分成了Forward Pass和Backward Pass两个stage。然后用流水线的思想进行计算。
另外，分布式ML本质上还是分布式系统嘛，所以像传统分布式系统里的一些topic（比如一致性、fault tolerance、通信、load balance等等）也可以放到这个背景下进行研究。&lt;/p>
&lt;p>最近挖的比较多的坑大致涉及以下几个点：&lt;/p>
&lt;h3 id="111-分布式ml系统设计">1.1.1 分布式ML系统设计&lt;/h3>
&lt;p>[ch7.3] 最著名的就是几大分布式DL模型：Parameter Server / AllReduce等。&lt;/p>
&lt;p>个人感觉这里面一个可以挖的坑是Decentralized Training。地里一位大佬也在做这个方向。&lt;/p>
&lt;h3 id="112-edge-computing">1.1.2 Edge Computing&lt;/h3>
&lt;p>很多ML模型是需要在手机上运行的（比如毁图秀秀）。针对这一场景，一个是要对手机这种低功耗设备对ML model进行裁剪加速（后面会提到），还有一个要做的就是运行在多个device上的分布式ML。&lt;/p>
&lt;p>这里有个最近非常火的概念：Federated Learning。其实本质还是炒数据并行的冷饭&amp;hellip;不过应用场景比较不一样。FL更多是为了Privacy的考虑，而分布式加速训练在这里倒是个次要目标。FL还涉及到了模型聚合[ch8]，也就是如何把多个device本地训练出的模型合并到一起。&lt;/p>
&lt;h3 id="113-大量计算资源的scheduling--device-placement">1.1.3 大量计算资源的Scheduling / device placement&lt;/h3>
&lt;p>UCB的CS294 19spring对这一节有过介绍。&lt;/p>
&lt;p>这里的计算资源的数量级是很大的&amp;hellip;&amp;hellip;比如工业界会有万台CPU服务器 / 上千台GPU服务器搭建的DL平台。这个小方向要解决的问题就是如何充分利用它们的性能。比如在阿里PAI组的JD里就有这么一条：“设计探索高效的分布式Placement算法，以更系统化的方式来解决大规模深度学习高效训练的问题”。&lt;/p>
&lt;p>这方面比较早的工作大概是这篇paper，说的是如何为TensorFlow计算图里的不同算子分配不同的device，最后用强化学习实现了这个目标。这个工作看起来有点prototype，但提出了一个新的思路。另外还有很多猛如虎的类似Train XX model in y minutes的工作。这种就不仅是placement好就能完成的了，还需要涉及系统拓扑的设计、降低communication开销等等。&lt;/p>
&lt;p>对于集群调度，工业界的一个热点是使用容器平台（例如k8s）来运行分布式机器学习应用。虽然k8s本身就有容器集群调度的功能，但为了让它更好地适应ML的workload，人们开发了一些新的轮子，比如针对TensorFlow（Parameter Server模型）和PyTorch的KubeFlow。还有用k8s来跑AutoML的katib。学术界对这方面的一个研究热点是GPU集群调度，在下面2.2节会介绍。&lt;/p>
&lt;h3 id="114-communication相关">1.1.4 communication相关&lt;/h3>
&lt;p>[ch3.5] [ch7]介绍了一些宏观上的通信模型，但深入进去还有很多可搞的坑。传统搞网络/分布式系统的组比较契合这个小方向。&lt;/p>
&lt;p>例如我校的分布式组原来有一些geo-distributed system的工作，现在也可以往ML上装。&lt;/p>
&lt;h3 id="115-其他sys-for-ml可做的坑">1.1.5 其他sys for ML可做的坑&lt;/h3>
&lt;p>工业界的一个ML pipeline不仅仅是训练，还涉及到很多其他的坑。这些是目前被挖的还比较少的：&lt;/p>
&lt;p>存储 / Data Management：&lt;/p>
&lt;ol>
&lt;li>训练数据的规模是很大的。如何为ML设计一个专用的文件系统（类似大数据界的HDFS）或者数据库来加速读数据呢？ 类似的工作有管理ML model的ModelDB.&lt;/li>
&lt;li>在ML framework中，以及Parameter Server中，需要用一个KV storage system来存储参数。可不可以针对ML的场景优化这个KV存储系统呢？ 关于这个可以参考neopenx大神的blog。&lt;/li>
&lt;/ol>
&lt;h1 id="2-深度学习模型压缩加速-">2. 深度学习模型压缩/加速 ⭐&lt;/h1>
&lt;p>这方面和architecture结合比较紧密。CS229有这一节，也可以参考NIPS19上的这个talk。&lt;/p>
&lt;p>对DL model进行压缩主要考虑两个角度：减少计算量（例如conv层的计算量） / 内存占用（NN的参数数量）。不仅要考虑ML上的metric，也要考虑system层面的performance（例如latency / throughput / 功耗。有时候这些比ML模型的accuracy还重要）。具体的方式大概有以下几种：&lt;/p>
&lt;ol>
&lt;li>Architectural Compression
Layer Design -&amp;gt; Typically using factorization techniques to reduce storage and computation
Pruning（剪枝） -&amp;gt; Eliminating weights, layers, or channels to reduce storage and computation from large pre-trained models. 减少卷积核大小 / 通道数等等&lt;/li>
&lt;li>Weight Compression
Low Bit Precision Arithmetic -&amp;gt; Weights and activations are stored and computed using low bit precision
Quantized（量化） Weight Encoding -&amp;gt; Weights are quantized and stored using dictionary encodings.
很多相关的工作是在ML的角度来压缩模型的（也就是Arch Compression，特别是针对CNN和RNN。比如很著名的MobileNet）。这里我们先(kan)略(bu)过(dong)，来看从System的角度是如何加速的。&lt;/li>
&lt;/ol>
&lt;h2 id="21-通过quantized量化降低计算精度要求-">2.1 通过Quantized（量化）降低计算精度要求 ⭐⭐&lt;/h2>
&lt;p>量化的含义是将卷积层（the weights and / or activations of a CNN）通常要用到的32位浮点数用更低位的数来表示，如int32, int16, int8等等，来降低资源占用（float32无论是计算还是存储都是很吃资源的..）。量化之后无疑会损失一部分精度，但神经网络对噪声并不是特别敏感，因此控制好量化的程度之后对ML任务的影响可以很小。&lt;/p>
&lt;p>一种常用的量化方法是train in floating point and then quantize the resulting weights，训练时还是用float32（因为要涉及到反向传播和梯度下降，全是int就很难搞了..），但在inference的阶段就可以加速啦。一个直观的方法是事先找好一般网络参数的min / max值，然后将训练好的网络参数乘一个scala factor来映射到[MIN_INT, MAX_INT]区间内的整数存起来。在inference时先按int来计算，最后结果再转换回float32。这一过程中其实加速了大量的卷积计算。比如这篇paper就实现了float32到int8的量化。&lt;/p>
&lt;p>混合精度计算：上面讲的方法是用在inference阶段的，其实在模型训练时也可以用类似的方法来加速，只不过再用int就不大行了。一种比较新的方法是用float16（也就是俗称的半精度），fp16占用空间是单精度(fp32)的一半，双精度(double，也就是fp64)的1/4。&lt;/p>
&lt;p>量化的具体实现方法可以参考这里。NVIDIA专门推出了针对inference阶段量化加速的工具包TensorRT&lt;/p>
&lt;h2 id="22-新硬件--dl-acclerator-">2.2 新硬件 / DL Acclerator ⭐⭐&lt;/h2>
&lt;p>在纯硬件方面针对DL workload的工作也有很多，这里来看几个parallel相关的技术。最近Data-Level Parallelism不仅在深度学习中，在其他一些领域（比如数据库）也有了越来越多的应用。&lt;/p>
&lt;p>CPU：尽管GPU已经成了深度学习计算的标配，有时候仍然是需要CPU运算的。例如要在手机等辣鸡设备上进行inference。&lt;/p>
&lt;p>SIMD：SIMD的含义是同一条指令在多个数据流上操作，和在向量处理器中一样。在具体实现中（例如SSE指令集）是把一个128位SSE寄存器（这是新增加的SIMD专用寄存器，和早期借用FPU寄存器的MMX不同。在SSE指令集中是增加了8个这种寄存器）划分成4个块，同时存放4个float32单精度浮点数，4个块可以同时进行运算（有多个运算单元，作用于不同的地址），这样就提高了并行度。后来的SSE2 / SSE3 / SSE4 / AVX指令集在此基础上又增加对float64 / 更多运算的支持，以及扩展了SIMD专用寄存器的位数，但本质上还是一样的。　　另外，SIMD带来的并行和超标量处理器的并行性（一个周期issue多个指令，用于instruction level parallelism）不是一个概念。非超标量处理器也可以SIMD，而超标量处理器可以更并行issue多个SIMD操作。&lt;/p>
&lt;p>VLIW：和一次issue多条指令，然后靠硬件进行ILP调度（也叫动态多发射。需要硬件实现乱序执行、分支预测等操作）的超标量处理器不同，VLIW（Very Large Instruction Width，采用这种技术的处理器也叫做静态多发射处理器）的含义是一次只issue一条可以完成多个操作的复杂长指令（也叫发射包，其实从软件的角度看是多条指令的集合）。因此一条指令的位宽可以很大。VLIW是通过编译器来进行指令级并行调度的（比如一个常用的方法是循环展开，通过识别出可并行的重叠跨循环体指令块来实现ILP）。VLIW的本意是希望在编译阶段就识别出程序中的依赖关系（静态调度），得到可以并行执行的发射包，硬件只需要根据调度好的发射包直接执行即可，这样就简化了硬件实现，从而实现更大宽度发射包的并行执行。intel Itanium的IA64指令集就使用了这个技术，但它在当年并没有取得成功。一个重要的原因是它只适合计算密集、算法固定可控的workload。传统的通用应用程序可能很难具备这个属性（有很多run-time才能确定的值，另外cache访问也是不确定的），但深度学习任务具备这些性质。&lt;/p>
&lt;p>GPU：GPU的本质可以看做SIMT（Single Instruction Multiple Threads）。&lt;/p>
&lt;ul>
&lt;li>GPU集群：DL框架一般都支持GPU和分布式训练，已经可以在GPU集群环境下运行了，但实际上还存在一些问题导致分布式场景下资源的使用率提不上去：1). CPU和GPU之间memcpy开销太大、2). 参数通信开销太大、3). 显存不够用、4). GPU很难虚拟化(多任务共享)、5).需要针对ML workload的更好的集群调度策略。 对于1和3其实也可以用前面提到的神经网络压缩、模型并行等方法解决； 对于2一个解决方案是尽量让计算和通信在时间上重叠起来，参考ATC17的Poseidon； MSR对于5做了很多工作，一方面是对大规模GPU集群上的真实日志数据进行分析，得出了一些经验（发表在ATC19）。另一方面是设计一些更好的scheduling策略，例如OSDI2018的Gandiva（针对DL workload自身的特点来提高GPU集群使用率）和NSDI2019的Tiresias； 对于4目前还没啥很好的解决方案，但可以通过一些软调度方案来模拟。&lt;/li>
&lt;li>这学期8205课上会有GPGPU的topic，到时候再补充 ⭐⭐⭐&lt;/li>
&lt;/ul>
&lt;p>系统结构：这个和纯计算关系不是很大，可能暂时和ML加速也没啥关系（事实上目前在计算机网络研究中用的还多一些）&amp;hellip;&amp;hellip;但对于优化整体性能会有帮助&lt;/p>
&lt;ul>
&lt;li>NUMA：当单个CPU性能已经到瓶颈时，多处理器就成了比较好的解决方案。为了方便编程，需要保证能为应用程序提供跨越所有处理器的单一物理地址空间，这种也叫做共享内存处理器（Shared Memory Processor）。SMP又可以分为两种类型：1) 任何处理器访问任何地址的仿存时间都是相同的，叫做统一存储访问（Uniform Memory Access）。 2) 对于每个核心，访问某些字会比访问其他字快一些，整个内存空间被分割并分配给不同处理器 / 内存控制器，这叫做非统一存储访问（NonUniform Memory Access，NUMA）。NUMA虽然看起来复杂，但可以支持更大的规模（更多的核心），并且访问附近的存储器时具有较低的延迟。 在过去内存控制器还在北桥的时代，多处理器用的是UMA（所有处理器都通过FSB总线连接北桥，再访问内存）。后来随着核心越来越多，为提高访存速度，内存处理器被做到了CPU内，每个CPU有（或者很少的几个核心共享）一个内存控制器，然后直连一部分内存空间，这些核心就被归为一个NUMA node。而跨NUMA node之间的内存访问需要走QPI总线。可以参考这里的图解。 在一些涉及many core的工作中会经常用到NUMA的概念&lt;/li>
&lt;li>RDMA：在网络环境中会用到。RDMA全称是Remote Direct Memory Access，用于实现不需要OS参与的远程内存访问（因为message passing through kernel会浪费本来很大的内存和网络带宽）。具体的技术细节可以参考这里。不过最近（Eurosys2019）已经有了应用RDMA来加速分布式机器学习的工作。&lt;/li>
&lt;/ul>
&lt;p>专用硬件：CPU性能太菜，GPU又太庞大，于是人们开发了AI专用芯片&lt;/p>
&lt;ul>
&lt;li>FPGA：全称是Field Programmable Gate Array，是可以多次烧写的。因为本质上属于软件所以可以快速开发 / 迭代。&lt;/li>
&lt;li>ASIC：全称是application-specific integrated circuits，出厂后电路就不可以改变了（需要流片）。但是性能比FPGA高。Google的TPU就属于一种ASIC。&lt;/li>
&lt;/ul>
&lt;h2 id="23-矩阵算子优化">2.3 矩阵算子优化&lt;/h2>
&lt;p>神经网络中的很多运算本质上就是对矩阵运算，因此可以用一些矩阵乘法优化方案来加速。比如cublas就是封装好的针对矩阵和向量运算的加速库，而对于神经网络加速则会使用cudnn&lt;/p>
&lt;p>算子优化是个非常贴近hardware的工作，对多种设备都人工调优这些算子其实是比较难的&amp;hellip;如果能简化一部分工作就最好啦。于是就有了下面会提到的深度学习编译器。&lt;/p>
&lt;blockquote>
&lt;p>这个工作可能偏向于工业界&lt;/p>
&lt;/blockquote>
&lt;h2 id="24-automl">2.4 AutoML&lt;/h2>
&lt;p>这个严格来说可能不算MLsys了&amp;hellip;但它的思路在很多MLsys问题中也会被用到&lt;/p>
&lt;p>AutoML最早只能调很有限的几种参数，用的方法也比较暴力（启发式搜索）。后来能调的东西越来越多，方法也更加猛如虎&amp;hellip;一个里程碑是NAS，标志着神经网络结构也可以Auto了。&lt;/p>
&lt;p>常用的调参方法大致可以分为这几种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>随机搜索，或者说叫启发式搜索。包括 GridSearch 和 RandomSearch。这种方法的改进空间主要体现在使用不同的采样方法生成配置，但本质上仍然是随机试验不同的配置，没有根据跑出来的结果来反馈指导采样过程，效率比较低。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Multi-armed Bandit。这种方法综合考虑了“探索”和“利用”两个问题，既可以配置更多资源（也就是采样机会）给搜索空间中效果更优的一部分，也会考虑尝试尽量多的可能性。Bandit 结合贝叶斯优化，就构成了传统的 AutoML 的核心。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深度强化学习。强化学习在 AutoML 中最著名的应用就是 NAS，用于自动生成神经网络结构。另外它在 深度学习参数调优 中也有应用。它的优点是从“从数据中学习”转变为“从动作中学习”（比如某个参数从小调到大），既可以从性能好的样本中学习，也可以从性能坏的样本中学习。但强化学习的坑也比较多，体现在训练可能比较困难，有时结果比较难复现。
之所以把AutoML也列出来，是因为这些方法在下面提到的ML for system问题中会很有用。比如之前做过的AutoTiKV就应用了一种贝叶斯优化方法来调节数据库参数。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>cs294中给出了几个可提高的方向：&lt;/p>
&lt;p>Accelerate data collection and preparation&lt;/p>
&lt;ul>
&lt;li>Automatic data discovery&lt;/li>
&lt;li>Distributed data processing, esp. for image and video data&lt;/li>
&lt;li>Data cleaning and schema driven auto-featurization&lt;/li>
&lt;/ul>
&lt;p>Accelerate model selection and hyper-parameter search&lt;/p>
&lt;ul>
&lt;li>Parallel and distributed execution&lt;/li>
&lt;li>Data and feature caching across training runs&lt;/li>
&lt;/ul>
&lt;p>Provenance&lt;/p>
&lt;ul>
&lt;li>Track previous model development to inform future decisions&lt;/li>
&lt;li>Connect errors in production with decisions in model development&lt;/li>
&lt;/ul>
&lt;h1 id="3-深度学习框架系统设计">3. 深度学习框架/系统设计&lt;/h1>
&lt;p>和Distributed Training的区别是这里更关注一些工程上的东西（框架设计、API设计等等）。一个Deep Learning Framework大致需要以下几个元素：&lt;/p>
&lt;ul>
&lt;li>支持各种算子(op) 和 tensor (data)&lt;/li>
&lt;li>计算图的定义方式（动态 v.s. 静态）&lt;/li>
&lt;li>Auto Diff&lt;/li>
&lt;li>Optimizer（例如Adam）&lt;/li>
&lt;li>各种加速和优化的库：cudnn, openblas,mkl等&lt;/li>
&lt;/ul>
&lt;h2 id="31-deep-learning-framework">3.1 Deep Learning Framework&lt;/h2>
&lt;p>这一节重点关注这几个方向：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Differentiable Programming：如果用过Keras或者PyTorch就会记得它可以简单得像搭积木一样摞一个NN出来，只需要定义一个一个的层（前向传播逻辑）和损失函数就行了。而NN的训练需要Backward Propagation / Forward Propagation，也就是计算微分，运算时framework可以根据定义好的计算图自动求导算梯度。只要可微分就可以保证这个积木能摞出来，然后使用链式法则就可以自动计算微分（Automatic Differentiation）。如果一个语言或者framework具备了Differentiable Programming的性质，就可以更简单的在它上面开发Deep Learning应用（可以类比python手写NN和Keras的区别）。这篇文章对Auto Diff的实现做了很详细的介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Embedded Domain Specific Languages：DSL的概念我们都知道，比如SQL就是数据库系统中的DSL，但这已经相当于一个全新的语言了。Embedded DSL是在现有语言上（例如Python）针对某个特定任务做的扩展。比如为了让Python做矩阵计算更方便发明了numpy；为了进行机器学习就有了TensorFlow / PyTorch等等。Embedded DSL的作用是完成 Linear Algebra -&amp;gt; Pipelines -&amp;gt; Differentiable Programs 的转化。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>根据计算图的定义方式，可以分为Declarative Abstraction（Embedded DSL先生成静态计算图，类似编译执行 define-and-run，例如Tensorflow、Caffe）和Imperative（Embedded DSL生成动态计算图并直接输出结果，类似解释执行 define-by-run，例如PyTorch、Tensorflow Eager）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>对于具体的DL框架来说，虽然很多公司都开始自研框架了，但最流行的基本就TensorFlow、PyTorch、mxnet等等那几家了。不过最近又出现了分布式强化学习框架Ray，也具有很好的落地潜能。&lt;/p>
&lt;blockquote>
&lt;p>确实如此，工业界很多公司都在做自己的框架了。&lt;/p>
&lt;/blockquote>
&lt;h2 id="32-inference--model-serving">3.2 Inference / Model Serving&lt;/h2>
&lt;p>之前关注了很多训练ML模型中会遇到的问题。但实际应用场景里，inference（直接使用训练好的模型predict）的次数会比training多很多，因此inference的性能也很重要。&lt;/p>
&lt;p>Inference可以再分为以下两种：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Offline: Pre-Materialize Predictions：所有可能的query都是已知的，就事先predict好存起来。一般没有这么玩的&amp;hellip;&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Online: Compute Predictions on the fly：根据用户的输入实时predict。这才是最常见的场景&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>一个典型的ML inference pipeline大致涉及到以下工序：&lt;/p>
&lt;ul>
&lt;li>input data&lt;/li>
&lt;li>-&amp;gt; Preprocessing(比如图片要resize)&lt;/li>
&lt;li>-&amp;gt; model prediction(有时候会同时用很多model，还要ensemble起来)&lt;/li>
&lt;li>-&amp;gt; 输出结果，有时候还要处理一下&lt;/li>
&lt;/ul>
&lt;p>这个pipeline的衡量指标包括Latency、Throughput等（和传统的system问题一样呀）。cs294里列出了几个最近的工作，可以参考这里的paper解读。个人感觉这里可做的坑不多&amp;hellip;.大多是修修补补&amp;hellip;&lt;/p>
&lt;h2 id="33深度学习编译器">3.3深度学习编译器&lt;/h2>
&lt;p>这里值得提一下TVM。这篇文章对TVM进行了非常详细的介绍。&lt;/p>
&lt;p>简单的说TVM是在把训练好的ML model部署在不同设备上时用的，重点关注的是Inference而不是Training（也就是推理引擎）。在这一过程中，模型本身可能用了不同的framework来写（比如tensorflow / PyTorch / MXNet，本质区别在于使用的算子类型可能不一样），而要部署到的设备也可能有不同的硬件架构（比如x86 / ARM / GPU / FPGA）。inference的过程也就是将framework X写出来的model放在硬件Y上运行的过程，这一过程和编译器是非常相似的（将语言X写的程序编译到硬件Y上运行），这也就是深度学习编译器的含义。&lt;/p>
&lt;p>为了设计一个高效的深度学习编译器，TVM借鉴了传统编译器LLVM的设计思想：抽象出编译器前端[ 高级语言C/java -&amp;gt; IR ]，编译器中端[ 优化IR，这种是不同编译器平台共享的 ]，编译器后端[ IR -&amp;gt; 目标硬件上的binary ]等概念，引入IR (Intermediate Representation。深度学习问题中可以将计算图作为IR，称为Graph IR)。这样不同硬件/framework都对标同一套IR，就避免了需要对每种硬件和framework排列组合适配的问题。TVM主要解决的是后端的问题[在目标硬件上高效运行IR]。而前端的问题[生成和优化IR]就交给深度学习框架们完成（针对这一步，在TVM stack中提供了NNVM，作用是represent workloads from different frameworks into standardized computation graphs）。&lt;/p>
&lt;p>TVM是和硬件深度集成的，也就是需要针对每种硬件平台实现相关的AI算子（类似NVIDIA GPU上的cuDNN）。然而人工调优这些算子的实现是很费精力的（特别是要针对不同形状的业务模型），这里面也有一些knob需要调整。为了让这个过程也能ML化，于是后来有了AutoTVM。&lt;/p>
&lt;p>cs294 sp19还提出了几个可能的future work：&lt;/p>
&lt;ul>
&lt;li>Compilers are great at Ahead of Time scheduling, what about Just-In-Time scheduling?&lt;/li>
&lt;li>Any way we can share GPU in predictable way and maximize utilization for DNN inference?&lt;/li>
&lt;li>Can we optimize for “fitness” of the kernel when it’s executed along with other kernels instead of its latency?&lt;/li>
&lt;/ul>
&lt;h1 id="4-用ml优化传统的system问题">4. 用ML优化传统的system问题&lt;/h1>
&lt;p>这里面的花样就更多了&amp;hellip;在上学期Jon的ML system课上有过较详细的接触。大部分是用ML去优化一个传统system问题中，一些需要人工经验调整、或者说可以从历史情况learn到一些东西的模块。比如数据库参数、操作系统页表、数据库索引等等。一个模块可以被ML化的前提是它必须是empirical的，参考它在页表（OS的工作集原理）、数据库（DBA是个很吃经验的活&amp;hellip;）中的应用。如果人工都看不出来啥规律就别指望它能ML了&amp;hellip;&lt;/p>
&lt;p>一般认为用ML优化system的思想是起源于Jeff Dean在NIPS2017的workshop。这方面的工作很多发表在纯system的顶级会议以及下属的AI for xxx workshop上，另外一些AI会议的workshop也会收录一些这方面的工作，比如nips 2018的MLsys workshop。从2017年开始已经有很多坑被做过了，但个人感觉还是有一些搞头的。感觉可以从下面两个角度再来搞：&lt;/p>
&lt;p>同样的scenario，使用更合适的ML算法。注意这里是更合适，而不是更高大上猛如虎。
比如这篇ML+Database的paper，使用了LSTM来预测未来的workload pattern，还要用GPU训练，但生产环境上要求数据库服务器也安个显卡是不现实的。工程上的一个解决方案是搞个集中式的训练集群（类似OtterTune），在DBaaS的情况下这种方法倒是行得通，但在对外发布的数据库产品中就不行了。
这里感觉可以参考早期AutoML的一些工作，因为它们本质是很类似的（都是调参嘛&amp;hellip;）。传统方法有启发式搜索/贝叶斯优化。最近也有很多人用强化学习去搞，但还是存在太吃资源的问题&amp;hellip;
这方面对ML知识的要求高一点。
寻找system界更多可以ML化的场景。这个更适合专业的system researcher来做，对ML倒是略有了解即可。
有一类思路是把ML深度集成到系统设计中，比如Andy在2019年的15-721课上提到过Self-Driving Database的概念，和之前用ML优化数据库的工作不同的是，Self-Driving DB更关注如何把ML和DB深度集成，而不是搞一个又一个外挂的模块了。
一个类似的工作是在OS领域：https://engineering.purdue.edu/WukLab/LearnedOS-OSR19.pdf 。
另外还有个工作是在Key-Value Storage Engine的领域：https://arxiv.org/pdf/1907.05443.pdf。它提出了Design Continuum的概念：存储系统中的很多数据结构本质上是很像的（arise from the very same set of fundamental design principles），例如B+tree, LSM-tree, LSH-table等，但它们却有不同的应用场景（比如KV Store中用LSM就比B+ Tree更合适），很难有一个十全十美的设计。这说明它们有相互替换的空间。这样我们可以将不同数据结构的选择也作为存储系统的一个knob，根据具体workload和硬件的情况来自动选择一个合适的底层数据结构（find a close to optimal data structure design for a key-value store given a target workload and hardware environment）。
一个更宏观一些的思路是做system and algorithm co-design，让任意计算机系统都能和ml深度集成。虽然具体的target system不一样，但其中有很多模块都是类似的（例如training、inference、system monitor等等）。针对这一目标MSR提出了AutoSys，对这些通用模块进行了整合。&lt;/p>
&lt;blockquote>
&lt;p>这部分就如同用 ML 方法去选择调度算法一样，比较 trick。&lt;/p>
&lt;/blockquote>
&lt;h1 id="5-其他">5. 其他&lt;/h1>
&lt;p>方向不是很契合就先不看了&amp;hellip;等用到了再填坑&lt;/p>
&lt;p>ML pipeline / lifecycle：https://ucbrise.github.io/cs294-ai-sys-fa19/assets/lectures/lec03/03_ml-lifecycle.pdf
Privacy：https://ucbrise.github.io/cs294-ai-sys-fa19/assets/lectures/lec10/10_adversarial_ml.pdf
图神经网络训练系统：https://www.msra.cn/zh-cn/news/features/2019-review-machine-learning-system [ATC19 NeuGraph]&lt;/p>
&lt;p>需要的技能树
这是从一些公司ML System Research Scientist岗位的招聘要求中整理出来的，更侧重system一些。&lt;/p>
&lt;p>System：&lt;/p>
&lt;p>工程基础：C/C++、OO programming。阅读源码是个很好的学习方式
OS
分布式系统
编译原理。特别是编译器优化技术、LLVM、memory optimization。Parser之类不喜欢也可以不看
Computer Architecture。另外还需要了解：1.GPU架构，例如显存分配机制、CPU与GPU交互。 2.CPU、存储系统相关的新技术。 3.有条件可以了解下深度学习专用硬件。
常见的并行计算框架，例如MPI/OpenMP/CUDA
ML framework的底层原理，扒源码
工业界的一些新东西：例如k8s、KubeFlow、ElasticDL
ML：&lt;/p>
&lt;p>机器学习基础
常见的分布式机器学习算法、DL模型压缩、模型加速方法（根据具体方向而定）
数理基础不要太菜…不要被人吐槽像没学过高中数学…&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/104444471">https://zhuanlan.zhihu.com/p/104444471&lt;/a>&lt;/p></description></item><item><title>cmake 目录结构和使用</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_cmake-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%BF%E7%94%A8/</link><pubDate>Mon, 09 May 2022 22:17:43 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_cmake-%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E4%BD%BF%E7%94%A8/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>cuTLASS 使用到了 cmake，之前没有接触过，先学习一下他的目录结构和编译过程。&lt;/p>
&lt;h2 id="01-cmake-简介">0.1 Cmake 简介&lt;/h2>
&lt;p>对于 C++ 程序，手动编写 Makefile 非常麻烦。cmake 用于自动编写 Makefile。通过读取 CMakeLists.txt 文件，可以自动生成 make 文件。cmake 中 macro 和 function 的使用，使得 cmake 更像是一个脚本语言。&lt;/p>
&lt;h1 id="1-cmake-目录">1. cmake 目录&lt;/h1>
&lt;h2 id="11-目录结构">1.1 目录结构&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>|-- bin &lt;span style="color:#75715e">#存放可执行文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- build &lt;span style="color:#75715e">#目录用于存放编译生成的文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- CMakeLists.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- include &lt;span style="color:#75715e">#统一存放头文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- hello.h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- gpgpu.h
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- README.md
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>|-- src
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- CMakeLists.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- main.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- model1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- CMakeLists.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- gpgpu.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- model.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| |-- model2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- CMakeLists.txt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- hello.cpp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>| | |-- model.cpp
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于大一点的项目可能还会需要 util 目录，library 目录夹或者 tool 目录&lt;/p>
&lt;p>&lt;strong>src&lt;/strong>: 这个 example 包含了 2 models，main.cpp 依赖于 2 基础 models，另外，注意到他们都包含 &lt;code>CMakeLists.txt&lt;/code> 文件&lt;/p>
&lt;h2 id="12-理解-cmakeliststxt">1.2 理解 CMakeLists.txt&lt;/h2>
&lt;p>注意 cmake 文件中不区分大小写&lt;/p>
&lt;h3 id="121-baseline">1.2.1 Baseline&lt;/h3>
&lt;p>最基础的包含以下一些信息，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 规定该CMakeLists.txt适用的cmake最小版本，这里是 3.12，自己手动安装了 3.20 版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cmake_minimum_required&lt;span style="color:#f92672">(&lt;/span>VERSION 3.12.4 FATAL_ERROR&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 项目名称，也就是 cutlass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>project&lt;span style="color:#f92672">(&lt;/span>CUTLASS VERSION 2.9.0 LANGUAGES CXX&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 定义生成的可执行文件(程序)的名称，假设为 gemm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里没找到 cutlass 对应的，cutlass 中有一个 function(cutlass_add_executable_tests NAME TARGET)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>add_executable &lt;span style="color:#f92672">(&lt;/span>gemm gemm.cxx&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 指定头文件搜索路径，根目录下 include&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>include_directories &lt;span style="color:#f92672">(&lt;/span>include&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2-cmake-编译过程">2. cmake 编译过程&lt;/h1>
&lt;h2 id="21-build-编译并运行">2.1 build, 编译并运行&lt;/h2>
&lt;p>build 目录用于存放编译生成的文件，一般的编译过程：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ mkdir build &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cd build
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cmake .. -DCUTLASS_NVCC_ARCHS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">75&lt;/span> &lt;span style="color:#75715e"># compile for NVIDIA Turing GPU architecture&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="22-问题可执行程序在哪个目录生成">2.2 问题，可执行程序在哪个目录生成？&lt;/h2>
&lt;p>看起来似乎是和 Makefile 文件同一目录，而 cutlass 中，执行 make 操作之后，会对程序进行编译，然后直接运行。由于在 sim 上运行需要把 gpgpusim.config 放到程序运行的目录下，所以我们需要知道是在哪个目录运行的。&lt;/p>
&lt;p>cmake 设置 library and executable 文件的存放路径：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>set&lt;span style="color:#f92672">(&lt;/span>LIBRARY_OUTPUT_PATH path&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>set&lt;span style="color:#f92672">(&lt;/span>EXECUTABLE_OUTPUT_PATH path&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;blockquote>
&lt;p>如果子目录中的某个CMakeLists.txt中设置了 set(&amp;hellip;)，就以当前文件中设置的路径为主，否则以父目录中设置的路径为主&lt;/p>
&lt;/blockquote>
&lt;p>如果都没设置呢？从简单的程序来看，在 &lt;code>build&lt;/code> 目录下 &lt;code>cmake .. XXXX&lt;/code>，在 &lt;code>build&lt;/code> 目录下生成 Makefile，执行 &lt;code>make &amp;amp; make install&lt;/code>，可执行程序就在当前（&lt;code>build&lt;/code>） 目录下。&lt;/p></description></item><item><title>Hugo_让你的博客被Google收录</title><link>https://huweim.github.io/post/blog_hugo_%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%A2%ABgoogle%E6%94%B6%E5%BD%95/</link><pubDate>Mon, 09 May 2022 22:17:43 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E8%AE%A9%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%A2%ABgoogle%E6%94%B6%E5%BD%95/</guid><description>&lt;h1 id="1-step">1. Step&lt;/h1>
&lt;p>网站在没有提交搜索引擎收录之前，直接搜索你网站的内容是搜不到的，因为搜索引擎不会去检索你的Github仓库。下面的解决方法&lt;/p>
&lt;h2 id="11-check-是否被谷歌收录">1.1 Check 是否被谷歌收录&lt;/h2>
&lt;p>打开谷歌搜索，在搜索框中输入&lt;/p>
&lt;p>site:https://huweim.github.io/&lt;/p>
&lt;p>如果提示说：找不到和您查询的“site:https://huweim.github.io/ ” 相符的内容或信息，说明未被收录。&lt;/p>
&lt;p>如果搜索结果的第一条就是你的博客站点，说明已被收录，不用再继续看下面的内容了。&lt;/p>
&lt;h2 id="12-提交谷歌搜索">1.2 提交谷歌搜索&lt;/h2>
&lt;p>进入Google Web Master Search Console，登录之后提交你的博客网址&lt;/p>
&lt;p>提交后需要通过 DNS 记录验证域名所有权，Github DNS 服务器配置教程：https://docs.github.com/cn/enterprise-server@3.2/admin/configuration/configuring-network-settings/configuring-dns-nameservers&lt;/p>
&lt;p>❌ 1.2.1 ssh 链接到 GitHub Enterprise Server instance，不使用域名验证方法，使用上传 html 文件的方法&lt;/p>
&lt;h2 id="13-上传-html-文件">1.3 上传 html 文件&lt;/h2>
&lt;h3 id="131-放在-content">1.3.1 放在 content&lt;/h3>
&lt;p>将下载的 html 文件放置在 &lt;code>content&lt;/code> 目录下，开启服务后，&lt;code>http://localhost:1313/googlead4e3c06724927ae/&lt;/code> 能够索引到即可，然后 push to Github. ❌&lt;/p>
&lt;h3 id="132-放在-themelayouts">1.3.2 放在 theme/layouts&lt;/h3>
&lt;p>放在 content 目录下不行，检索不到后缀 .html，比如 &lt;code>http://localhost:1313/googlead4e3c06724927ae.html/&lt;/code> 就索引不到了。折腾了半个小时，发现应该放在 &lt;code>themes\jane\layouts&lt;/code> 目录下，因为发现 &lt;code>http://localhost:1313/index.html&lt;/code> 才能够有效地索引，那么对于 &lt;code>googlead4e3c06724927ae.html&lt;/code> 也是一样的道理。&lt;/p>
&lt;p>不过仍然找不到，不是说复制到&lt;code>themes\jane\layouts&lt;/code> 目录下就能索引到，比如我复制了一个 &lt;code>404.html&lt;/code>，改名为 &lt;code>40411.html&lt;/code>，是无法直接找到的。&lt;/p>
&lt;h3 id="133-static">1.3.3 static&lt;/h3>
&lt;p>知识：static这个文件夹有一个特性就是可以将里面的文件复制到public文件夹里面。我们可以将我们自定义的页面放到这个目录下，因为它不是hugo生成的，所以不会被覆盖。&lt;/p>
&lt;p>首先在根目录下的 &lt;code>static&lt;/code> 下创建一个目录，目录名是你的页面名（googlead4e3c06724927ae.html）。然后在这个目录下创建 &lt;code>index.html&lt;/code>，把 &lt;code>googlead4e3c06724927ae.html&lt;/code> 中的内容复制到 &lt;code>index.html&lt;/code>，目的就达到了。这样，访问 &lt;code>http://localhost:1313/googlead4e3c06724927ae.html/&lt;/code> 页面时加载的就是 &lt;code>googlead4e3c06724927ae.html&lt;/code> 的内容。&lt;/p>
&lt;p>2022-05-09 11:13:15，这一方法验证成功。&lt;/p>
&lt;p>&lt;img src="./Img/Verify.png" alt="">&lt;/p>
&lt;h2 id="14-等待">1.4 等待&lt;/h2>
&lt;p>提交博客之后，需要等待一段时间才能在Google上搜到，因为Google需要时间来处理我们的请求、抓取相应网页并将其编入索引。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://huiyu-li.github.io/2019/11/27/Tools/2019-11-27-%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E5%86%8DGitHub%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2/">https://huiyu-li.github.io/2019/11/27/Tools/2019-11-27-%E8%AE%A9%E8%B0%B7%E6%AD%8C%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E5%86%8DGitHub%E4%B8%8A%E7%9A%84%E5%8D%9A%E5%AE%A2/&lt;/a>&lt;/p></description></item><item><title>编译运行cuTLASS</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Ccutlass/</link><pubDate>Mon, 09 May 2022 22:17:43 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Ccutlass/</guid><description>&lt;h1 id="1-环境">1. 环境&lt;/h1>
&lt;h2 id="11-prerequisites">1.1 Prerequisites&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ git clone https://github.com/NVIDIA/cutlass
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>CUTLASS requires:&lt;/p>
&lt;ul>
&lt;li>NVIDIA CUDA Toolkit (9.2 or later required, 11.1 recommended)&lt;/li>
&lt;li>CMake 3.12+&lt;/li>
&lt;li>host compiler supporting C++11 or greater (g++ 7.3.0 or Microsoft Visual Studio 2015 recommended)&lt;/li>
&lt;li>Python 3.6+&lt;/li>
&lt;/ul>
&lt;p>CUTLASS may be optionally compiled and linked with&lt;/p>
&lt;ul>
&lt;li>cuBLAS&lt;/li>
&lt;li>cuDNN v7.6 or later&lt;/li>
&lt;/ul>
&lt;h3 id="111-cmake">1.1.1 cmake&lt;/h3>
&lt;p>官方给出了建议的环境，cmake 没有安装，apt-get install 安装的是 3.12 版本，不符合要求。手动安装一下 3.20 cmake，&lt;a href="https://gist.github.com/bmegli/4049b7394f9cfa016c24ed67e5041930">教程&lt;/a>&lt;/p>
&lt;p>注意有个 BUG，&lt;code> Could NOT find OpenSSL,&lt;/code>，&lt;code>apt-get install libssl-dev&lt;/code> 即可&lt;/p>
&lt;h3 id="112-gcc">1.1.2 gcc&lt;/h3>
&lt;h2 id="12-build">1.2 Build&lt;/h2>
&lt;p>之后就可以 build 了。这里用 Turing 架构&lt;/p>
&lt;p>Construct a build directory and run CMake.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ export CUDACXX&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>CUDA_INSTALL_PATH&lt;span style="color:#e6db74">}&lt;/span>/bin/nvcc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ mkdir build &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> cd build
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ cmake .. -DCUTLASS_NVCC_ARCHS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">75&lt;/span> &lt;span style="color:#75715e"># compiles for NVIDIA Turing GPU architecture&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-build-and-run-the-cutlass-profiler">1.3 Build and run the CUTLASS Profiler&lt;/h2>
&lt;p>From the &lt;code>build/&lt;/code> directory created above, compile the the CUTLASS Profiler. 主要是 build &lt;code>build/tool/profiler&lt;/code> 目录。 ✔️&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ make cutlass_profiler -j12
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then execute the CUTLASS Profiler computing GEMM, execute the following command. ❌&lt;/p>
&lt;p>这一步果然不行，cudaGetDeviceProperties() failed for given device，找不到 device&lt;/p>
&lt;p>2022-05-08 14:41:46，✔️，在工作站上就可以用 gpgpu-sim 运行，很奇怪，明明都是同一个 Docker 环境，只是自己电脑没有 GPU 而已&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./tools/profiler/cutlass_profiler --kernels&lt;span style="color:#f92672">=&lt;/span>sgemm --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4352&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>4096
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">=============================&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Problem ID: &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Provider: CUTLASS
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Operation: cutlass_simt_sgemm_128x128_nn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Disposition: Passed
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Status: Success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Arguments: --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4352&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --A&lt;span style="color:#f92672">=&lt;/span>f32:column --B&lt;span style="color:#f92672">=&lt;/span>f32:column --C&lt;span style="color:#f92672">=&lt;/span>f32:column --alpha&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --beta&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --split_k_slices&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --batch_count&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --op_class&lt;span style="color:#f92672">=&lt;/span>simt --accum&lt;span style="color:#f92672">=&lt;/span>f32 --cta_m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span> --cta_n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span> --cta_k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --stages&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> --warps_m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> --warps_n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span> --warps_k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --inst_m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --inst_n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --inst_k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> --min_cc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">50&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --max_cc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Bytes: &lt;span style="color:#ae81ff">52428800&lt;/span> bytes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> FLOPs: &lt;span style="color:#ae81ff">146064539648&lt;/span> flops
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Runtime: 10.5424 ms
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Memory: 4.63158 GiB/s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Math: 13854.9 GFLOP/s
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="14-build-and-run-cutlass-unit-tests">1.4 Build and run CUTLASS Unit Tests&lt;/h2>
&lt;h3 id="141-workspace">1.4.1 Workspace&lt;/h3>
&lt;p>From the &lt;code>build/&lt;/code> directory created above, simply build the target &lt;code>test_unit&lt;/code> to compile and run all unit tests. ❌&lt;/p>
&lt;p>这一步失败，看起来是 gcc 版本的问题。换了 gcc 版本，还是直接崩掉。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ make test_unit -j
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span>----------&lt;span style="color:#f92672">]&lt;/span> Global test environment tear-down
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[==========]&lt;/span> &lt;span style="color:#ae81ff">946&lt;/span> tests from &lt;span style="color:#ae81ff">57&lt;/span> test cases ran. &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#ae81ff">10812&lt;/span> ms total&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">[&lt;/span> PASSED &lt;span style="color:#f92672">]&lt;/span> &lt;span style="color:#ae81ff">946&lt;/span> tests.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>指定一个 unit，会 building 目录 &lt;code>test/unit/gemm/warp/CMakeFiles&lt;/code> 中的内容，仍然是找不到 GPU Device ID&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ make test_unit_gemm_warp -j
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="142-工作站">1.4.2 工作站&lt;/h3>
&lt;p>&lt;strong>工作站：&lt;/strong> 还是找不到 gpgpusim.config，这个应该找到对应的执行目录，把 config 文件复制过去即可。&lt;code>cp ~/gpgpu-sim_distribution/configs/tested-cfgs/SM75_RTX2060/* ~/cutlass/build/test/unit/gemm/warp/CMakeFiles/test_unit_gemm_warp.dir/&lt;/code>&lt;/p>
&lt;p>2022-05-09 15:31:59，猜测是在 &lt;code>/cutlass/build/test/unit/gemm/warp&lt;/code> 目录下执行，把 gpgpusim.config 文件复制过去。✔️&lt;/p>
&lt;p>可以成功运行，新的问题是之前遇到的一个问题，wmma 指令的 align syntax 错误。&lt;/p>
&lt;h2 id="15-profiler-和-test-unit-的执行有什么区别">1.5 Profiler 和 Test Unit 的执行有什么区别？&lt;/h2>
&lt;h2 id="16-gemm-运行参数">1.6 gemm 运行参数&lt;/h2>
&lt;p>cutlass_profiler 支持非常自由的运行参数，并且支持参数的批处理（用 , 间隔）。参数如下，f32 应该就是对应的 data type 设置。&lt;/p>
&lt;p>2022-05-09 20:34:24 找到了官方的 &lt;a href="https://github.com/NVIDIA/cutlass#documentation">Documentation&lt;/a>，可以看 Section 3 中的详细解释。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cutlass_profiler &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --operation&lt;span style="color:#f92672">=&lt;/span>Gemm &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8192&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8192&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8192&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --A&lt;span style="color:#f92672">=&lt;/span>f32:column &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --B&lt;span style="color:#f92672">=&lt;/span>f32:column &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --C&lt;span style="color:#f92672">=&lt;/span>f32:column &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --beta&lt;span style="color:#f92672">=&lt;/span>0,1,2 &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --profiling-iterations&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --providers&lt;span style="color:#f92672">=&lt;/span>cutlass &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> --output&lt;span style="color:#f92672">=&lt;/span>functional-test.csv
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>尝试修改 data type，是否有 i8? 这个语句执行结束后生成了一堆 .csv 文件，包括 conv2d, conv3d, gemm, rank_k, rank_2k，难道是一次执行了这么多程序？而且没有成功跑起来 ❌&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./tools/profiler/cutlass_profiler --kernels&lt;span style="color:#f92672">=&lt;/span>cutlass_tensorop_s*gemm_f16_*_nt_align8 --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3456&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --A&lt;span style="color:#f92672">=&lt;/span>i8:column --B&lt;span style="color:#f92672">=&lt;/span>i8:column --C&lt;span style="color:#f92672">=&lt;/span>i8:column --output&lt;span style="color:#f92672">=&lt;/span>test.csv &amp;gt; ~/output/tensor_op3.log.lrr &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>去掉 output 选项，data type 改成 f32&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./tools/profiler/cutlass_profiler --kernels&lt;span style="color:#f92672">=&lt;/span>cutlass_tensorop_s*gemm_f16_*_nt_align8 --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3456&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --A&lt;span style="color:#f92672">=&lt;/span>f32:column --B&lt;span style="color:#f92672">=&lt;/span>f32:column --C&lt;span style="color:#f92672">=&lt;/span>f32:column &amp;gt; ~/output/tensor_op3.log.lrr &amp;amp;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2-examples">2. examples&lt;/h1>
&lt;p>使用官方 README.md 编译会因为没有 Device 而失败，那么换一个思路，尝试利用 cmake 编译运行 examples 中提供的文件。&lt;/p>
&lt;h2 id="21-cmake-编译流程">2.1 cmake 编译流程&lt;/h2>
&lt;ul>
&lt;li>编写CMakeLists.txt&lt;/li>
&lt;li>通过cmake生成Makefile&lt;/li>
&lt;li>make编译&lt;/li>
&lt;/ul>
&lt;p>cuTLASS 在 &lt;code>example&lt;/code> 目录下提供了 CMakeLists.txt。用法&lt;/p>
&lt;ul>
&lt;li>进入 example 目录，新建 build 文件夹；&lt;code>$ mkdir build; cd build&lt;/code>&lt;/li>
&lt;li>&lt;code>cmake ../&lt;/code>; cmake会在找到上级目录找到CMakeLists.txt，生成makefile和一些其它文件&lt;/li>
&lt;li>在makefile所在目录，调用make命令，会根据makefile对程序进行编译生成。&lt;/li>
&lt;/ul>
&lt;h1 id="3-documentation">3. Documentation&lt;/h1>
&lt;h2 id="32-functionality">3.2 Functionality&lt;/h2>
&lt;p>这个部分介绍了 opcode class, *&lt;strong>data type&lt;/strong>, layout. data type 正是我们所需要的。&lt;/p>
&lt;p>opcode class, including Simt, TensorOp, SpTensorOp&lt;/p>
&lt;h3 id="322-device-level-implicit-gemm-convolution">3.2.2 Device-level Implicit GEMM convolution&lt;/h3>
&lt;p>列出了 Device-level Implicit GEMM convolution 的 opcode class, data type, layout&lt;/p>
&lt;h3 id="323-warp-level-matrix-multiply-with-tensor-cores">3.2.3 Warp-level Matrix Multiply with Tensor Cores&lt;/h3>
&lt;p>TensorOp 16-by-8-by-64. 支持 int4b_t，&lt;/p>
&lt;h3 id="324-warp-level-matrix-multiply-with-cuda-wmma-api">3.2.4 Warp-level Matrix Multiply with CUDA WMMA API&lt;/h3>
&lt;p>WmmaTensorOp,&lt;/p>
&lt;p>Instruction Shape ( 16-by-16-by-16, 8-by-32-by-16)&lt;/p>
&lt;p>Warp Shapes (32x32x16, 32x64x16, 64x32x16; 32x32x16, 32x64x16, 64x32x16)&lt;/p>
&lt;h2 id="33-efficient-gemm-in-cuda">3.3 Efficient GEMM in CUDA&lt;/h2>
&lt;h3 id="331-threadblock-level-gemm">3.3.1 Threadblock-level GEMM&lt;/h3>
&lt;p>Each threadblock computes its portion of the output GEMM by iteratively loading tiles of input matrices and computing an accumulated matrix product.&lt;/p>
&lt;h3 id="332-warp-level-gemm">3.3.2 Warp-level GEMM&lt;/h3>
&lt;p>Multiple warps within a threadblock fetch data from shared memory into registers and perform computations. Warp-level GEMMs may be implemented either by TensorCores issuing mma.sync or wmma instructions or by thread-level matrix computations issued to CUDA cores. For maximum performance, access to shared memory should be bank conflict free. To maximize data reuse within the warp, a large warp-level GEMM tile should be chosen.&lt;/p>
&lt;p>使用到了 wmma 指令，shared memory。&lt;/p>
&lt;h3 id="333-thread-level-gemm">3.3.3 Thread-level GEMM&lt;/h3>
&lt;p>SGEMM, IGEMM, HGEMM, and DGEMM are computed by SIMT math instructions issued by thread-level matrix multiply procedures.&lt;/p>
&lt;p>所以现在跑的是 thread-level GEMM&lt;/p>
&lt;h2 id="34-terminology">3.4 Terminology&lt;/h2>
&lt;p>Layout: functor mapping logical coordinates of a tensor to linear offset (as LongIndex); owns stride vectors, if any.&lt;/p>
&lt;p>Operator: an object performing a computation on matrix or tensor objects. May be further refined by scope within the execution model hierarchy.&lt;/p>
&lt;p>Tile: partitions of a tensor that have constant extents and layout known at compile time&lt;/p>
&lt;h2 id="35-cutlass-profiler-">3.5 CUTLASS Profiler ⭐&lt;/h2>
&lt;p>The CUTLASS Profiler is a command-line driven test and profiling environment for CUTLASS computations defined in the CUTLASS Instance Library. The CUTLASS Profiler is capable of executing each GEMM, Sparse Gemm, Conv2d, and Conv3d kernel.&lt;/p>
&lt;p>&lt;code>cutlass_profiler&lt;/code> 就是一个封装好的脚本，运行各类程序&lt;/p>
&lt;p>进入到目录 &lt;code>build/tools/profiler&lt;/code>，运行 &lt;code>cutlass_profiler --help&lt;/code> 可以查看一些有用的信息，直接 &lt;code>cutlass_profiler --help&lt;/code> 找不到 cutlass_profiler；用 &lt;code>./cutlass_profiler --help&lt;/code> 就开始跑程序了，有点不知道怎么用这个 &amp;ndash;help。&lt;/p>
&lt;p>2022-05-09 20:22:30，还是用 &lt;code>./cutlass_profiler --help&lt;/code> 就可以跑，不过神奇的是这是用 gpgpu-sim 跑得，最后会把需要的信息 print 在屏幕上。&lt;/p>
&lt;h3 id="351-gemm">3.5.1 GEMM&lt;/h3>
&lt;p>The CUTLASS Profiler is capable of executing GEMM and Sparse GEMM problems.&lt;/p>
&lt;h4 id="3511-gemm-arguments-">3.5.1.1 GEMM Arguments ⭐&lt;/h4>
&lt;p>The complete set of arguments available to each operation may be viewed by specifying the operation name in addition to &amp;ndash;help. The argument flags and their aliases usable for GEMM appear as follows.&lt;/p>
&lt;p>可以通过 option &lt;code>--help&lt;/code> 查看完整的 operation，他这里给出的例子是 &lt;code>./tools/profiler/cutlass_profiler --operation=gemm --help&lt;/code>，所以还是得执行这个脚本吧。&lt;/p>
&lt;p>&lt;img src="./Image/gemm_aug.png" alt="">&lt;/p>
&lt;h4 id="3512-example-tensor-core-gemm-operations">3.5.1.2 Example Tensor Core GEMM Operations&lt;/h4>
&lt;p>To execute kernels targeting Tensor Core operations, supply the flag &lt;code>--op_class=tensorop&lt;/code> in the command line.&lt;/p>
&lt;p>实际上，op_class 也就是选择 TensorOp or SIMT&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./tools/profiler/cutlass_profiler --op_class&lt;span style="color:#f92672">=&lt;/span>tensorop --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3456&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">4096&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8192&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3513-自己运行">3.5.1.3 自己运行&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>./tools/profiler/cutlass_profiler --operation&lt;span style="color:#f92672">=&lt;/span>Gemm --op_class&lt;span style="color:#f92672">=&lt;/span>tensorop --m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span> --n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1024&lt;/span> --k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">128&lt;/span> --inst_m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> --inst_n&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span> --inst_k&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>如何使用 4-bit 进行计算&lt;/strong>: 对于 TensorOp, Instruction Shape 8-by-8-by-32 对应的是 A-int4b_t, B-int4b_t, C-int32_t，通过参数 &lt;code>--inst_m&lt;/code>, &lt;code>--inst_n&lt;/code>, &lt;code>inst_k&lt;/code> 来决定&lt;/p>
&lt;h3 id="352-conv">3.5.2 Conv&lt;/h3>
&lt;p>和 gemm 也是类似的，重点还是搞懂他们的参数。&lt;/p></description></item><item><title>关于 Deep Work</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_deep_work/</link><pubDate>Sun, 08 May 2022 20:56:54 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_deep_work/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>Why read? 最近同步推进的任务比较多，包括雅思/托福，LeetCode刷题（不能说不找实习就荒废掉了），自己lead的课题（可以先读paper慢开始，但是对本人提升很重要），科研实习的课题（这个必须定时有反馈，留下不错的印象），公司的一些活儿（按时完成且上心），锻炼（荒废了一段时间但是必须），AICS 课程（好在这个和目前的研究有了相关性）。&lt;/p>
&lt;p>因此，需要进行详细而且比较严格的时间管理，才能同时做好这么多事情。&lt;/p>
&lt;h2 id="01-知乎">0.1 知乎&lt;/h2>
&lt;p>知乎一位作者写的自我观察非常好，在我需要去完成论文的那段时间，我也是进入了这样一种状态。这个任务必须去交付（DDL 4.14），而且需要交互（修改之后给娄老师，并且完成娄老师交代的改动），是一种紧张，紧凑的任务，但是不觉得效率很高，写初稿反而磕磕盼盼，但是事后来看，在一段比较短的时间内（4.4-4.13）产出了一篇有结构的初稿并且慢慢完善并投稿。而现在，你需要记住、重拾这种状态，并把他融入到你的日常工作中。&lt;/p>
&lt;blockquote>
&lt;p>我观察到自己真正非常高效地推进困难任务，产出自己想要的结果往往发生在连续的长时间的工作中，并且我的心理状态是这样的：我一定要在这个任务上有重大突破或者完成它，不然饭也先别吃了，于是我往往会在同一个任务上从下午一点工作到六七点，或者从下午五点工作到晚上十点十一点，碰到问题就解决问题，没有头绪就尝试各种可能推进任务的可能性。别看这一下子时间花的挺长，产生的结果和进展常常令我感到惊讶。以我常规的工作方式（如每天固定投入1-2小时），往往拖了一两周都毫无进展的困难任务，我一整个下午就解决了。这样的情况发生了很多次，并且反差如此的强烈，于是我打算将这个现象思考清楚，总结出其中的原因。我很自然地联想到了Cal Newport的《Deep Work》，隐隐感觉和他提出的“深度工作”的这个概念有关。当然在总结他书中的观点之前，我会想梳理一下自己的思考。&lt;/p>
&lt;/blockquote>
&lt;h2 id="02-知乎总结">0.2 知乎总结&lt;/h2>
&lt;blockquote>
&lt;p>最小阻力定律 （The Law of Least Resistance），我们人类天生倾向于选择一条阻力最小的路径，也就是说我们倾向于回避困难任务，选择更轻松、更简单的事情先做。因此在常规工作方式下，你太容易不自觉地回避困难任务了，虽然你可能计划要在某件事上工作1-2小时，但其实在这些时间内，你都很可能有意无意地远离真正能推进任务的困难的点，只是做些表层的简单的事，并且很容易被别的事情分心从而中断在这个任务上的投入（比如，查看回复邮件，肚子饿了想着先回家吃饭）；于是你在这个困难任务上真正的有效投入其实非常有限，也就不奇怪几周时间也没什么进展了。而另一种深度工作方式，由于我在一开始就和自己约定好了：不解决问题，饭都不吃，做好了打持久战的准备，所以退无可退，避无可避，只能直面最困难的点。&lt;/p>
&lt;/blockquote>
&lt;p>毫无疑问，我会倾向于在简单任务（LeetCode简单题，回复邮件，刷知乎，读paper的intruction和abstract，浅层的阅读代码）上花费时间来获取反馈、满足感和完成感。面对困难任务时，总是在解决掉困难任务的一个简单部分\有所进展之后，就想回到床上躺一会儿。这时最近（2022-05-07 14:40:33）工作的普遍现象。&lt;/p>
&lt;blockquote>
&lt;p>尽量不要切换任务，因为有各种成本（意志力成本，任务启动成本）。意志力成本：我们对困难任务多少会有些恐惧，所以启动它本身就要消耗一些意志力，如果你按照常规的工作方式拖着很多天都没解决，那么每次启动这个任务的时候都要一次又一次地消耗意志力成本。任务启动成本：启动任务直到在最困难的点想办法推进任务之前，你需要回顾涉及到的各种背景知识、约束条件和细节，因此你在不同的时间段启动任务时，每次这个任务启动成本也是不能省的。因此一件事干大半天、一整天的收益和产生的价值远远超过你一天在几个任务间切换，每个任务各花1-2小时。当我们把指数效应放到较大的时间尺度下，我们看到的现象是一件事你坚持很多天，很多个月，很多年，越到后期你越能获得指数级的丰厚回报；其实我们也可以把指数效应放到较小的时间尺度下，比如一天，在一天中，你坚持做一件事一直做下去，越到后面你也越能获得指数级的回报，而如果你只在一件事上花了1-2小时，很可能你还没等到收益指数级增长的时候。（而像盖茨这样的大神，在创业初期写程序的时候，可能连续几周几个月连轴转都在高度专注地推进一件事，可以想象到后面所产生的恐怖的指数级的价值。）&lt;/p>
&lt;/blockquote>
&lt;p>没错，启动任务会消耗大量的精神力，而自己老是在启动后自我中断，这无疑大大降低了自己的效率。自己能认识到中断任务的负面反映，知道过于固定的任务时间（比如严格 2h paper reading）是不可取的，这也是我寻求 time management 方法的原因。&lt;/p>
&lt;blockquote>
&lt;p>当然不是所有事情都适合用深度工作的方式，现在看来自认为的困难任务是适合的，而比较简单但工作量巨大的任务却不适合，原因其实就在上面写的两条中了。
更新一条：长时间专注于同一个任务，越到后面越会有指数级的效应和产出，还很可能和cognitive workload theory有关，越到后面，因为在之前的时间里你已经将那些基础性的东西都弄得很熟悉了，所以也就不再占据你的认知工作负荷（cognitive workload），这样到最后你大脑的认知思考能力全部被解放出来集中在最难的点上，不断地取得之前浅度工作（shallow work）所不能取得的突破。&lt;/p>
&lt;p>Cal自己是”深度工作“的践行者，他的一整天都会深度围绕着一项核心的工作，然后将那些无法避免的浅层工作压缩到自己日程的边角料时间段里。这样一天仅仅三到四个小时的无中断的高度专注的工作，一周五天就能创造出很多有价值的东西。Cal自己还是两个孩子的父亲，这样的工作方式也让他有更多的时间留给家人，并且让他有时间阅读惊人数量的书籍。&lt;/p>
&lt;/blockquote>
&lt;h1 id="1-youtube">1. Youtube&lt;/h1>
&lt;p>举了几个例子，JK 罗琳为了避免干扰，找了家酒店写作，她原本没打算一直待在那里。但是第一天工作的效果很好，所以他就继续下去了，直到完成《哈利波特》。&lt;/p>
&lt;p>比尔盖茨 1974 年用 deep work 理论完成 basic 的第一版，在 8 个周的时间内，他一直在写代码，累了就在键盘上趴一会儿，睡一个小时。最后 8 周完成了这个软件。&lt;/p>
&lt;p>MIT 和一些学校的学生、老师发现 deep work 对他们研究工作的帮助，于是创作了这本书。普通人可能没法像他们那样一次在一个工作上投入 8 weeks，但是仍然有进入 deep work 的方法。&lt;/p>
&lt;p>deep work 很难，也很稀少。我们的世界有很多分散注意力的东西，比如合作时需要立刻回邮件，回消息，比如社交媒体的影响，刷虎扑，微博等等。&lt;/p>
&lt;p>一些 deep work 的方法&lt;/p>
&lt;h2 id="11-schedule-distraction">1.1 Schedule Distraction&lt;/h2>
&lt;p>大概就是说统一一个时间来处理分散注意力的事项。这个和我最近在做的其实很像，比如昨天（2022-05-07）在想去看一些信息的时候（研究院）没有立刻去，而是把它记录下来，之一统一处理。这是一个避免分散注意力，保持高效的方法。玩手机，回邮件也应该有意识地去克制。&lt;/p>
&lt;h2 id="12-deep-work-ritual">1.2 Deep Work Ritual&lt;/h2>
&lt;p>简而言之就是，保持节奏，养成习惯。养成习惯这个技巧，在有意识地学习。&lt;/p>
&lt;p>一周 7 天，你可能习惯在晚上进入 deep work，那就 7 天都保持这个节奏，把会议，事项安排到早上，把需要 deep work 的工作安排在晚上。&lt;/p>
&lt;p>研究表明新手大概能保持 1h deep work，但是 deep work master 能够保持大概 4h，要争取做到这个强度。&lt;/p>
&lt;h2 id="13-evening-shundown">1.3 Evening Shundown&lt;/h2>
&lt;p>休息好很重要。没做完的事情，拆分成比较具体的事情，写入第二天的计划中。因为此时一天的工作还保存在大脑的 cache 中，主要是还没有断开连接，列好计划，第二天可以减少很多开销。对于需要 deep work 的工作，需要及时 shutdown，列好计划之后在第二天留出充足的时间来完成，而不是强行低效率地去磨。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/39759254">https://zhuanlan.zhihu.com/p/39759254&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=gTaJhjQHcf8">https://www.youtube.com/watch?v=gTaJhjQHcf8&lt;/a>&lt;/p></description></item><item><title>如何读论文（李沐）</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87%E6%9D%8E%E6%B2%90/</link><pubDate>Sun, 08 May 2022 20:16:17 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E5%A6%82%E4%BD%95%E8%AF%BB%E8%AE%BA%E6%96%87%E6%9D%8E%E6%B2%90/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>最近（2022-05-08 16:40:17）看到了李沐的这个系列，之前没看过。其实读研以来陆陆续续也看过很多阅读文章，写文章的技巧，教程等等，自己也有一些感触和经验。而最近做完 GPU 微架构相关的一部分课题之后，恰好会接触一个比较新的领域。去读这种新的领域的文章，慢慢开拓到熟悉，也是一种体验。正好这个时间点，就结合自己之前读论文的经验，学到的技巧，结合李沐大神在视频中传授的方法，以及他阅读和看待文章的视角，来做一个总结和记录。&lt;/p>
&lt;h1 id="1-方法">1. 方法&lt;/h1>
&lt;p>第一遍，title, abs, conclusion, conclusion 一般和 abs 结构是一样的，可能会有更加详细的数据，性能提升 XX% 等等; 浏览 method 和实验部分的图表，大概花十几分钟看看这篇文章在讲什么，是不是值得继续读下去。&lt;/p>
&lt;p>标题中的作者，学校，也很重要，你对领域内比较熟悉的话，对这些作者肯定也是有所了解的。&lt;/p>
&lt;p>第二遍，精读，知道每个 part 在讲什么，但是不需要知道所有的细节，看懂重要的 figure description. 判断是不是自己领域内的，&lt;strong>圈出没看过的参考文献&lt;/strong>，如果这篇比较难读，可以从参考文献中的经典入手。&lt;/p>
&lt;p>第三遍，带着自己的思考，提出的是什么问题，你能想到这个问题吗？用的什么解决方法，你来做的话会用什么方法？如果用同样的方法，你能做出什么优化？你能拓展出新的东西吗，他的做法可参考吗，你能够复现吗，他有什么地方讲得有问题吗？等等等等，带着一系列问题，给自己设置一系列问题。这一遍看完，合上文章之后，也知道文章在讲什么，也可以给别人讲述出技术细节（所以有人讨论，有一个输出的机会也是很重要的）。&lt;/p>
&lt;h1 id="2-第二遍精读关于-alexnet">2. 第二遍精读，关于 AlexNet&lt;/h1>
&lt;p>看视频，从李沐阅读 paper 的视角，去思考一位领域内大牛看到文章中的一些句子，脑海中的想法是怎样的。&lt;/p>
&lt;h2 id="21-intro">2.1 Intro&lt;/h2>
&lt;p>看到第一段，李沐不光介绍了段落表达的意思，还做了额外的科普，过拟合是 ML 中的一大派别，我想他应该能继续讲出哪些人在做这方面的工作。推测出，从现在的眼光来看，正则好像又没那么重要。&lt;/p>
&lt;p>第一段主要是讲故事，比如自己，需要介绍 GPU 广泛应用于XXX，以及 warp 调度等等。&lt;/p>
&lt;p>之后，分析文章写法的问题。在介绍完数据集之后，直接就开始提，用 CNN 解决问题。写法的问题在于，当时的主流并非 CNN，其实应该介绍一些主流算法，然后过渡到 CNN。（同意这个观点）&lt;/p>
&lt;p>最后一段开始讲 paper 的贡献，讲自己的工作，做了什么，做了 5 层卷积，3 层全连接，等等。他们用了一些新的技术（挖坑，可以继续往下做），阐述了他们不光卖点很好，也有很多新的东西。&lt;/p>
&lt;blockquote>
&lt;p>从这个角度管中窥豹，一篇文章有好的结果本身已经是一个卖点了，但是他们的方法可能过于复杂，难以复现，别的研究者没法跟进，那么文章可能能中但是不太会有人跟；另一方面，有好的结果，同时有创新的东西，大家都可以 follow，那么这个工作很可能是一篇开山之作，挖坑之作，会有比较高的引用率。&lt;/p>
&lt;/blockquote>
&lt;h2 id="22-the-dataset">2.2 The DataSet&lt;/h2>
&lt;p>AlexNet 这篇文章标题带了 ImageNet，因此大概介绍了一下数据集。自己写的时候，也是大概交代一下 GPU 的 baseline 架构背景，和简单的领域内知识。这个部分对同行来说不是很重要，完善文章结构，没有涉及到 paper 的 idea。&lt;/p>
&lt;p>最后一段还说明了对图片做的一些处理。&lt;/p>
&lt;p>什么是 End to end: 原始的图片\文本直接进去，不做任何特征提取，神经网络能帮你做出来。end to end 是他当时的亮点，但是当时由于历史局限性，可能没有发现。&lt;/p>
&lt;h2 id="23-the-architecture">2.3 The Architecture&lt;/h2>
&lt;p>Section 3.1 首先介绍了 ReLU。有一些技术细节，其实刚接触的时候是不知道具体意思的，没有关系，可以圈一下，记录一下。比如 3.1 的 saturating non-linearity, non-saturating non-linearity.&lt;/p>
&lt;p>Section 3.2 介绍了 Training on Multiple GPU, 如何划分 GPU 的。这个部分，站在 ML 研究者角度，第二遍可以略过，除非需要复现，因为可能看不懂，而且不是 ML 方法上的东西；对于 系统/体系结构 研究者，可以关注一下。&lt;/p>
&lt;p>Section 3.3 讲了 LRN 的一些细节，第二遍读的时候也可以忽略掉&lt;/p>
&lt;p>Section 3.4 讲了 Overlap Pooling，实际上一般 pooling 是没有 overlap，如果不知道 pooling 是什么可以先跳过，去看了 pooling 之后再细读。这个地方可以大概知道用的 pooling 方法不太常规。&lt;/p>
&lt;p>文章类似于一个技术报告的风格，没有 highlight, 宣传做了什么。&lt;/p>
&lt;p>李沐老师对于 Figure 2 的讲解通俗易懂。&lt;/p>
&lt;p>为什么模型图切到两块 GPU？可能是 Alex 刚好是这么做了，并且写了大量的代码去支撑这个工作，所以将其作为一个贡献放在里面。&lt;/p>
&lt;h2 id="24-reducing-overfitting">2.4 Reducing Overfitting&lt;/h2>
&lt;p>介绍如何降低过拟合。&lt;/p>
&lt;p>Section 4.2 Dropout, 很多模型融合到一起太贵了&lt;/p>
&lt;blockquote>
&lt;p>这两部分主要是关于技术细节，所以结合自己经历的感触可能不是特别多。&lt;/p>
&lt;/blockquote>
&lt;h2 id="25-details-of-learning">2.5 Details of Learning&lt;/h2>
&lt;p>介绍模型是如何训练的。逐渐出现了一些看起来玄学的部分，比如一些参数的设置。&lt;/p>
&lt;p>当时需要训练 5-6 天，在两个 GPU 上。&lt;/p>
&lt;h2 id="26-result">2.6 Result&lt;/h2>
&lt;p>进入到了实验部分，对于不复现的人来说，或者不是同领域的人，实验相对没有那么重要。&lt;/p>
&lt;h1 id="3-如何找到研究想法">3. 如何找到研究想法&lt;/h1>
&lt;h2 id="31-打补丁">3.1 打补丁&lt;/h2>
&lt;p>在原作者想法的基础上，做一些加减法。比如他用了新的 loss，用了两个（我能不能用 3 个？做数据增强，我能不能做？），用故事把你的补丁串联起来。&lt;/p>
&lt;p>如果一篇文章已经是打补丁的论文，可能难以找到机会。如果脑洞比较大的工作，可以做更多尝试。比如 iPAWs 已经是 16 年的文章，follow 的人有但不是特别多，回头来看可能不是一个特别好的选择。&lt;/p></description></item><item><title>Matplotlib</title><link>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_matplotlib/</link><pubDate>Tue, 19 Apr 2022 20:29:07 +0800</pubDate><guid>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_matplotlib/</guid><description>&lt;h4 id="plthist">plt.hist()&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>data &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">1&lt;/span>,&lt;span style="color:#ae81ff">2&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">6&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">7&lt;/span>,&lt;span style="color:#ae81ff">64&lt;/span>,&lt;span style="color:#ae81ff">66&lt;/span>,&lt;span style="color:#ae81ff">5&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>,&lt;span style="color:#ae81ff">8&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>hist(data, bins&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;weight&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="参数">参数&lt;/h5>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>bins，直方图的 bucket，bins = 3 表示将区间分为 3 buckets。数值范围是 0-66，那么大概分为 0-22，23-45，45-67 三个 bucket，然后根据 &lt;code>data&lt;/code> 中的情况，往这几个 bucket 投票/计数。&lt;/li>
&lt;li>range，x 轴的显示范围&lt;/li>
&lt;/ul>
&lt;h4 id="pltplot">plt.plot()&lt;/h4>
&lt;h5 id="ylabel">y.label()&lt;/h5>
&lt;p>给出y轴的名称&lt;/p>
&lt;p>论文中时常需要设置 y 轴参数&lt;/p>
&lt;p>plt.legend() 显示 label&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>legend(loc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;upper right&amp;#39;&lt;/span>, ncol&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>, fontsize&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">30&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ncol 设置行列如何排布，有时候需要排成一排，有时候需要排成一列&lt;/p>
&lt;h5 id="pltxticks-pltyticks">plt.xticks(), plt.yticks()&lt;/h5>
&lt;p>关于刻度的一些设置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>xticks(locs, [labels], &lt;span style="color:#f92672">**&lt;/span>kwargs) &lt;span style="color:#75715e"># Set locations and labels&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>yticks(np&lt;span style="color:#f92672">.&lt;/span>arange(&lt;span style="color:#ae81ff">0.5&lt;/span>, &lt;span style="color:#ae81ff">1.3&lt;/span>, step&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0.05&lt;/span>),family&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;Arial&amp;#39;&lt;/span>, weight&lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;normal&amp;#39;&lt;/span>, size&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">20&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>np.arange(0.5, 1.3, step=0.05) 设置刻度的范围和步长&lt;/p>
&lt;p>不显示 y 轴刻度&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>yticks([])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="pltylim05-13">plt.ylim((0.5, 1.3))&lt;/h5>
&lt;p>设置坐标轴范围，为 0.5-1.3&lt;/p>
&lt;h5 id="plttitle">plt.title()&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>title(filename, {&lt;span style="color:#e6db74">&amp;#39;family&amp;#39;&lt;/span> : &lt;span style="color:#e6db74">&amp;#39;Arial&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;weight&amp;#39;&lt;/span> : &lt;span style="color:#e6db74">&amp;#39;normal&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;size&amp;#39;&lt;/span> : &lt;span style="color:#ae81ff">20&lt;/span>})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="pltsubplot">plt.subplot()&lt;/h5>
&lt;p>这个是画图的时候比较常用的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 分成2x2，占用第一个，即第一行第一列的子图&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> plt&lt;span style="color:#f92672">.&lt;/span>subplot(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;cifar&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> show_graph_cifar(filename)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 分成2x2，占用第一个，即第一行第一列的子图&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> plt&lt;span style="color:#f92672">.&lt;/span>subplot(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;resnet&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> show_graph_resnet(filename)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># 分成2x1，占用第二个，即第二行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> plt&lt;span style="color:#f92672">.&lt;/span>subplot(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> filename &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;alex&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> show_graph_alex(filename)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>效果&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h5 id="pltlegend">plt.legend()&lt;/h5>
&lt;p>参数 &lt;code>ncol&lt;/code> 设置列数，可以把他们排成一行&lt;/p>
&lt;h5 id="pltgrid">plt.grid&lt;/h5>
&lt;p>如何把网格放在最底层？zorder 似乎没有效果。虽然警告了 &lt;code>zorder unknown word&lt;/code>，但是设置之后还是 work 了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>grid(visible&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>, which&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;major&amp;#39;&lt;/span>, axis&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;y&amp;#39;&lt;/span>, linestyle&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;--&amp;#39;&lt;/span>, zorder&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>zorder 设置值比 bar 更小，就可以放在最底层了&lt;/p>
&lt;h5 id="pltbar-绘制直方图和叠加直方图">plt.bar() 绘制直方图和叠加直方图&lt;/h5>
&lt;p>叠加直方图这次没做，不过不是很难，大概是给 bar 指定一个起始位置&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x_length &lt;span style="color:#f92672">+&lt;/span> bar_width,y_8,width&lt;span style="color:#f92672">=&lt;/span>bar_width,label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;8 entry&amp;#34;&lt;/span>, color&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;darkorange&amp;#39;&lt;/span>, edgecolor&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;black&amp;#39;&lt;/span>, zorder&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>加上边框 edgecolor 会好看很多。&lt;/p>
&lt;h5 id="pltsubplots_adjustbottom035">plt.subplots_adjust(bottom=0.35)&lt;/h5>
&lt;p>提前设置好 top, bottom, 各种空白等参数，让打出来的图片可以直接使用&lt;/p>
&lt;h5 id="color-参数">color 参数&lt;/h5>
&lt;!-- raw HTML omitted --></description></item><item><title>CSAPP阅读笔记</title><link>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>最近刚把 adaptive 调度的一部分工作写成了文章，在 SOCC DDL（4.14） 投了出去。之后会准备oneflow面试，如果可以拿下这份远程实习，对工程能力和并行计算优化方面会有更好的优化。因此，希望可以好好准备一下oneflow二面。准备的方式就是浏览一遍CSAPP，一方面是复习体系结构中的一些知识，另一方面再构建一下对整个计算机结构，操作系统，C语言的了解和认识。&lt;/p>
&lt;h2 id="01-知识点挖坑">0.1 知识点挖坑&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>浮点数的表示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流水线的设计（第四章）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="12">1.2&lt;/h2>
&lt;p>预处理：把 # 开头的一些代码替换成对应的内容，比如 &lt;code>#include&amp;lt;stdio.gh&amp;gt;&lt;/code>, &lt;code>#define&lt;/code>，或者是之前见过的，别人写代码时用到的宏定义来代替 for 循环等操作。hello.c -&amp;gt; hello.i&lt;/p>
&lt;p>编译器：得到汇编语言，也就是各种指令。生成 hello.s (s 代表 assembly？)&lt;/p>
&lt;p>汇编阶段：translate assembly to machine code.&lt;/p>
&lt;p>链接：合并，比如 hello 程序调用了 printf 函数，which is in &lt;code>printf.o&lt;/code>，链接器（ld）负责做这种合并&lt;/p>
&lt;p>大型项目往往会出现和链接器相关的错误。比如你定义了2个名字相同的全局变量，静态库和动态库区别？第七章会介绍&lt;/p>
&lt;h3 id="141-系统的硬件组成">1.4.1 系统的硬件组成&lt;/h3>
&lt;p>这里有描述架构和微架构的区别&lt;/p>
&lt;blockquote>
&lt;p>指令集架构描述的是每条机器代码指令的效果；微体系结构（微架构）描述的是处理器实际上是如何实现的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="141-运行-hello-程序">1.4.1 运行 hello 程序&lt;/h3>
&lt;p>DMA，data 不通过处理器，直接从磁盘到达主存&lt;/p>
&lt;h2 id="15-cache-至关重要">1.5 Cache 至关重要&lt;/h2>
&lt;p>cache，SRAM&lt;/p>
&lt;h2 id="17-os管理硬件">1.7 OS管理硬件&lt;/h2>
&lt;p>两个基本功能：防止硬件被失控的应用程序滥用；向application提供简单一致的机制来控制复杂而大不相同的低级硬件设备&lt;/p>
&lt;p>PS: 硬件设备的架构、配置各不相同，而OS正是这样的一个接口。&lt;/p>
&lt;h3 id="171-进程process">1.7.1 进程（process）&lt;/h3>
&lt;p>OS 跟踪 进程 运行需要的所有状态信息，这种状态称为&lt;strong>上下文&lt;/strong>，包括 PC，register file。&lt;/p>
&lt;p>上下文切换：OS 决定把控制权转移到另一个进程，进行上下文切换&lt;/p>
&lt;p>PS：从微架构来理解，其实就是执行的下一条指令PC以及数据（来自register file）换掉了，换成了OS层面的另一个进程。&lt;/p>
&lt;h3 id="172-线程">1.7.2 线程&lt;/h3>
&lt;p>这个是OS中的线程概念，一个进程由多个线程的执行单元组成&lt;/p>
&lt;h3 id="173-虚拟内存-">1.7.3 虚拟内存 ⭐&lt;/h3>
&lt;p>抽象概念，为每个进程提供独占DRAM的假象。&lt;/p>
&lt;p>&amp;ldquo;&lt;img src="D:%5CShanghaiTech%5C2022-Spring%5CCSAPP%5CNote%5CImg%5CVirtual_Memory.png" alt=""> align=left&amp;rdquo;&lt;/p>
&lt;p>从下到上（低地址向高地址）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>代码和数据： 所有进程代码都是从同一固定地址开始。之后是存放全局变量的位置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆：malloc, free 这种标准库函数来进行申请，程序员来管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>共享库：存放C标准库，数学库。第七章动态链接部分会介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>栈：编译器管理，实现函数调用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核虚拟内存：application 无法直接调用，必须调用kernel来执行&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="191-amdahls-law">1.9.1 Amdahl&amp;rsquo;s Law&lt;/h3>
&lt;p>HPC，并行加速&lt;/p>
&lt;h2 id="21-信息存储">2.1 信息存储&lt;/h2>
&lt;p>浮点数：以2为基数的科学计数法。&lt;/p>
&lt;h3 id="212-字数据大小">2.1.2 字数据大小&lt;/h3>
&lt;p>字长（word size）决定虚拟地址空间的最大大小。对于字长 $w$，虚拟地址的范围为 0~$2^w-1$。近几年64位字长的机器比较多，32位字长使得虚拟地址空间为4GB。大多数64位机器可以运行32位机器编译的程序，向后兼容性。&lt;/p>
&lt;h3 id="213-寻址和字节顺序">2.1.3 寻址和字节顺序&lt;/h3>
&lt;p>这里面比较重要的知识是大端小端。&lt;/p>
&lt;p>知识前提：多字节对象（比如一个int）被存储为连续的字节序列。假设一个 int 型变量 x，取地址为 0x100，int 32bit，4 字节，实际上他的 4 个字节存储在 0x100, 0x101, 0x102, 0x103，这个是还未对齐到 cache line 的，每个字节的地址。&lt;/p>
&lt;p>假设 x = 0x01234567&lt;/p>
&lt;p>小端就是最低有效字节（67）在 0x100 地址处&lt;/p>
&lt;p>&amp;ldquo;&lt;img src="D:%5CShanghaiTech%5C2022-Spring%5CCSAPP%5CNote%5CImg%5CByte_address.png" alt=""> align=left&amp;rdquo;&lt;/p>
&lt;p>反汇编（disassembler）：确定可执行文件所表示的指令序列。&lt;/p>
&lt;p>typedef 给数据命名，主要是改善代码可读性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>int_pointer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int_pointer ip;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过这个*为什么是和 int_pointer 挨在一起的？&lt;/p>
&lt;h3 id="217-位运算">2.1.7 位运算&lt;/h3>
&lt;p>这个自己编程时用的比较少&lt;/p>
&lt;p>与运算：$&amp;amp;$&lt;/p>
&lt;p>或运算：$|$&lt;/p>
&lt;p>NOT，取反：$~$ &lt;code>~0x41&lt;/code>&lt;/p>
&lt;h2 id="22">2.2&lt;/h2>
&lt;p>介绍一些补码，无符号数，有符号数&lt;/p>
&lt;p>2.3 阐述整数运算&lt;/p>
&lt;h2 id="24-浮点数">2.4 浮点数&lt;/h2>
&lt;h3 id="242-ieee浮点表示">2.4.2 IEEE浮点表示&lt;/h3>
&lt;p>尾数（significand）：一个二进制小数&lt;/p>
&lt;p>阶码（exponent）：浮点数加权。&lt;/p>
&lt;h1 id="3-程序的机器级表示">3. 程序的机器级表示&lt;/h1>
&lt;h3 id="321-机器级代码">3.2.1 机器级代码&lt;/h3>
&lt;p>大概讲一讲汇编代码，指令的编码格式，执行流程，关于控制的条件码&lt;/p>
&lt;h2 id="37-过程">3.7 过程&lt;/h2>
&lt;p>运行时栈&lt;/p>
&lt;h3 id="374-栈上的局部存储">3.7.4 栈上的局部存储&lt;/h3>
&lt;p>有时，寄存器不足够存放所有的本地数据，对于GPU会把这部分数据放入local memory&lt;/p>
&lt;h3 id="3101-理解指针">3.10.1 理解指针&lt;/h3>
&lt;h1 id="4-处理器体系结构">4. 处理器体系结构&lt;/h1>
&lt;h2 id="41-y86-65-指令集体系结构">4.1 Y86-65 指令集体系结构&lt;/h2>
&lt;p>介绍指令集架构，指令，RISC，CISC&lt;/p>
&lt;h2 id="42-逻辑设计和硬件控制语言-hcl">4.2 逻辑设计和硬件控制语言 HCL&lt;/h2>
&lt;p>最常用的是 Verilog，描述电路的语言。&lt;/p>
&lt;p>设计逻辑门，组合逻辑电路，布尔表达式，存储器，时钟（CLK）&lt;/p>
&lt;p>很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为组合电路(combinational circuits)。构建这些网有两条限制：&lt;/p>
&lt;ul>
&lt;li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障&lt;/li>
&lt;li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。&lt;/li>
&lt;/ul>
&lt;h2 id="43-y86-65-的顺序实现">4.3 Y86-65 的顺序实现&lt;/h2>
&lt;p>介绍了几个 pipeline stage, fetch, decode, excute, memory, write back, PC update&lt;/p>
&lt;h2 id="44-流水线的通用原理">4.4 流水线的通用原理&lt;/h2>
&lt;p>介绍流水线如何缩短执行所需的 cycle&lt;/p>
&lt;p>流水线会有一些&lt;strong>局限性&lt;/strong>：不同逻辑单元的时钟周期并非完全一致的。流水线过深会造成收益下降。&lt;/p>
&lt;h2 id="45-y86-64-的流水线实现">4.5 Y86-64 的流水线实现&lt;/h2>
&lt;p>设计分支预测，data hazard, control hazard, structure hazard。主要是关于几个 hazard，以及处理方式，比如 stall, forward（转发）。&lt;/p>
&lt;p>什么是结构危害？&lt;/p>
&lt;p>当硬件不能在重叠执行中同时支持所有可能的指令组合时，资源冲突就会引起&lt;strong>结构性危险&lt;/strong>。在现代处理器中，结构性危害主要发生在不常用的特殊功能单元中（例如浮点除法或其他复杂的长期运行指令）。这个没有 data hazard and control hazard 常见。&lt;/p>
&lt;p>还涉及异常处理&lt;/p>
&lt;h3 id="458-流水线控制逻辑">4.5.8 流水线控制逻辑&lt;/h3>
&lt;p>发现特殊控制条件，流水线控制机制，控制逻辑实现&lt;/p>
&lt;h3 id="459-性能分析">4.5.9 性能分析&lt;/h3>
&lt;p>其实就是 IPC 和 CPI&lt;/p>
&lt;h2 id="5-优化程序性能">5. 优化程序性能&lt;/h2>
&lt;p>编写高效的程序：适当的算法和数据结构；编写编译器能够有效优化以转换成高效可执行代码的源码，这一点就要求比较了解和编译器相关的知识；利用并行性。&lt;/p>
&lt;h2 id="51-优化编译器的能力和局限性">5.1 优化编译器的能力和局限性&lt;/h2>
&lt;p>&lt;code>-O2 -O3&lt;/code> 级别的优化可以进一步提高程序的性能，但是也可能增加程序的规模。&lt;/p>
&lt;p>阻碍优化的因素：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>阐述了两个指针可能指向同一个内存位置的情况，这个被称为&lt;strong>内存别名使用&lt;/strong>(memory aliasing)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数调用，函数可能会有副作用（改变全局程序状态的一部分）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>大部分编译器不会判断函数是否偶副作用。可以用 inline function 替换来优化函数调用&lt;/p>
&lt;p>gcc不是最好的编译器，但对于大部分人已经足够用。&lt;/p>
&lt;h2 id="52-表示程序性能">5.2 表示程序性能&lt;/h2>
&lt;blockquote>
&lt;p>我们引入度量标准每元素的周期数(Cycles Per Element, CPE)作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹(GHz)，即十亿周期每秒来表示。CPE 越小越好。&lt;/p>
&lt;/blockquote>
&lt;h2 id="54-消除循环的低效率">5.4 消除循环的低效率&lt;/h2>
&lt;p>最常见的就是把函数调用放到 loop 之外，比如我之前编程时很喜欢写&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> vec.size(); i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样会大量调用 size() function，可以做如下优化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> vec.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上的代码移动(code motion)是一种优化。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。&lt;/p>
&lt;h2 id="55-减少过程调用">5.5 减少过程调用&lt;/h2>
&lt;blockquote>
&lt;p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。我们可以直接访问数组，而不是利用函数调用并加上边界检查。&lt;/p>
&lt;/blockquote>
&lt;p>也就是说去掉不必要的一些边界检查。&lt;/p>
&lt;h2 id="56-消除不必要的内存引用">5.6 消除不必要的内存引用&lt;/h2>
&lt;p>比如无需每次都把结果写入 dest，可以使用一个临时变量，消除不必要的存储器引用&lt;/p>
&lt;h2 id="57-理解现代处理器">5.7 理解现代处理器&lt;/h2>
&lt;p>提到了 superscaler，OoO，分支预测。大概是介绍这类技术&lt;/p>
&lt;h2 id="58-循环展开">5.8 循环展开&lt;/h2>
&lt;blockquote>
&lt;p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。其思想是在一次迭代中访问数组并做乘法，这样得到的程序需要更少的迭代，从而降低循环的开销。&lt;/p>
&lt;/blockquote>
&lt;p>PS：这个应该是和最基础的并行思想想结合。&lt;/p>
&lt;h2 id="59-提高并行性">5.9 提高并行性&lt;/h2>
&lt;p>多个积累变量；重新结合变换；这就涉及到 SIMD&lt;/p>
&lt;h2 id="511-一些限制因素">5.11 一些限制因素&lt;/h2>
&lt;p>寄存器溢出；分支预测和预测错误处罚；Amdahl定律&lt;/p>
&lt;h2 id="512-理解内存性能">5.12 理解内存性能&lt;/h2>
&lt;p>这个就是研究 load/store 的影响，也就是 cache&lt;/p>
&lt;h2 id="513-应用性能提高技术">5.13 应用：性能提高技术&lt;/h2>
&lt;p>高级设计：为遇到的问题选择适当的算法和数据结构。&lt;/p>
&lt;p>基本编码原则：消除连续的函数调用；消除不必要的内存引用；&lt;/p>
&lt;p>低级优化：展开循环；SIMD；&lt;/p>
&lt;h2 id="514-确认和消除性能瓶颈">5.14 确认和消除性能瓶颈&lt;/h2>
&lt;p>也就是常说的 profiling 技术，code profiler。&lt;/p>
&lt;p>最基础的就是插入工具代码，确定程序的各个部分需要多少时间。&lt;/p>
&lt;h1 id="6-存储器层次结构memory-system">6. 存储器层次结构（memory system）&lt;/h1>
&lt;h2 id="61-存储技术">6.1 存储技术&lt;/h2>
&lt;p>RAM，Random-Access-Memory，分为 SRAM，DRAM。&lt;/p>
&lt;p>SRAM：每个 bit 存在一个双稳态（bitstable）存储器单元。只有两个稳定的配置（configuration）或者状态（state）&lt;/p>
&lt;p>DRAM：DRAM相比SRAM，对干扰非常敏感。内存系统必须周期性地读出，然后重写来刷新每一位。&lt;/p>
&lt;p>NVM（Non-Volatile Memory）：闪存（flash memory），新型的基于闪存的磁盘驱动器，SSD（Solid State Disk）&lt;/p>
&lt;p>Cache 的一些基本信息。&lt;/p>
&lt;h1 id="7-链接">7. 链接&lt;/h1>
&lt;p>链接：将各种代码和数据和数据片段收集并组合成为一个单一文件的过程，这个文件可以被&lt;strong>加载&lt;/strong>（复制）到内存并执行。链接可以执行与 compile time, load time, run time.&lt;/p>
&lt;p>PS：链接在大型工程项目编译时应该很重要，可以避免对一些源代码文件的重复编译。&lt;/p>
&lt;p>大多数编译系统提供编译驱动程序（compiler driver），为用户根据需求调用语言预处理器、编译器、汇编器和链接器。&lt;/p>
&lt;h2 id="72-静态链接">7.2 静态链接&lt;/h2>
&lt;p>为了创建可执行文件，链接器必须完成两个主要任务：&lt;/p>
&lt;ul>
&lt;li>符号解析（symbol resolution），将一个符号引用和一个符号定义结合起来&lt;/li>
&lt;li>重定位（relocation），编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。&lt;/li>
&lt;/ul>
&lt;p>目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。&lt;/p>
&lt;h2 id="73-目标文件">7.3 目标文件&lt;/h2>
&lt;p>目标文件有三种形式：&lt;/p>
&lt;ul>
&lt;li>可重定位目标文件，包含二进制文件和代码，其形式在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件&lt;/li>
&lt;li>可执行目标文件，其形式可被拷贝到存储器并执行&lt;/li>
&lt;li>共享目标文件，一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。&lt;/li>
&lt;/ul>
&lt;p>编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件&lt;/p>
&lt;h2 id="710-动态共享链接库">7.10 动态共享链接库&lt;/h2>
&lt;p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器的程序来执行的。&lt;/p>
&lt;p>共享库也称为共享目标(shared object)，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。&lt;/p>
&lt;p>动态链接库和静态链接库的区别：&lt;/p>
&lt;p>关于静态库&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态库对函数库的链接是放在编译时期完成的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序在运行时与函数库再无瓜葛，移植方便。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>为什么需要动态库？&lt;/strong>&lt;/p>
&lt;p>空间浪费是静态库的一个问题。&lt;/p>
&lt;p>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。&lt;/p>
&lt;p>&lt;strong>动态库特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="8-异常控制流">8. 异常控制流&lt;/h1>
&lt;p>这部分后面有需要再看&lt;/p>
&lt;blockquote>
&lt;p>处理器按照一定的序列的地址执行对应的指令，从这一个地址过渡到下一个地址成为控制转移，这样的控制转移序序列称为处理器的控制流（flow control）&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control Flow, ECF)。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。&lt;/p>
&lt;/blockquote>
&lt;h1 id="9-虚拟内存">9. 虚拟内存&lt;/h1>
&lt;p>虚拟内存这一块工作，以及请求到下级缓存之后的知识完全不solid，这也间接导致了商汤，平头哥的面试出现重大问题。在和 Xia 的交流中，这是一个潜在的研究方向。既是补短板，也是打基础。&lt;/p>
&lt;h1 id="91-物理和虚拟寻址">9.1 物理和虚拟寻址&lt;/h1>
&lt;p>物理寻址：理解为类似直接映射的方式。&lt;/p>
&lt;p>虚拟寻址：请求中包含的是一个 VA（virtual memory），经过 MMU 进行 address translation 后得到 PA（physical address），此时去 Main memory 寻址。&lt;/p>
&lt;h1 id="93-虚拟内存作为缓存的工具">9.3 虚拟内存作为缓存的工具&lt;/h1>
&lt;p>VM 系统将虚拟内存分割为大小固定的块，称为虚页（virtual page, VP）。类似地，物理内存被分割为物理页（physical page, PP）。&lt;/p>
&lt;p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：&lt;/p>
&lt;ul>
&lt;li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。&lt;/li>
&lt;li>缓存的：当前缓存在物理存储器中的已分配页。&lt;/li>
&lt;li>未缓存的：没有缓存在物理存储器中的已分配页。&lt;/li>
&lt;/ul>
&lt;h3 id="931-dram高速缓存的组织结构">9.3.1 DRAM高速缓存的组织结构&lt;/h3>
&lt;p>在存储层次结构中，DRAM缓存的位置对于他的组织结构有很大的影响。DRAM 缓存的组织结构完全是由巨大的不命中开销（large overhead）驱动的。&lt;/p>
&lt;p>因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是4KB-2MB。&lt;/p>
&lt;p>由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。&lt;/p>
&lt;p>PS：也就是说虚拟页采用的是写回的替换策略。&lt;/p>
&lt;h3 id="932-页表">9.3.2 页表&lt;/h3>
&lt;p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。&lt;/p>
&lt;p>PS：这个和 cache 的逻辑其实是类似的。页是访问的最小单位&lt;/p>
&lt;p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做页表(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。&lt;/p>
&lt;p>下图展示了一个页表的基本组织结构。&lt;strong>页表&lt;/strong>就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="933-页命中">9.3.3 页命中&lt;/h3>
&lt;h3 id="934-缺页">9.3.4 缺页&lt;/h3>
&lt;p>在虚拟存储器的习惯说法中，DRAM不命中称为缺页（page fault）。缺页异常调用内核中缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和存储器之间传送页的活动叫做交换(swapping)或者页面调度(paging)。&lt;/p>
&lt;p>PS：那就和 cache miss, cache replacement 类似。DRAM 提供不了，需要找 disk 去要数据&lt;/p>
&lt;h3 id="936-局部性再次搭救">9.3.6 局部性再次搭救&lt;/h3>
&lt;p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集(resident set)。&lt;/p>
&lt;p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸（thrashing），这时页面将不断的换进换出。&lt;/p>
&lt;p>PS：这些概念和 cache 都是类似的。&lt;/p>
&lt;h2 id="96-address-translation">9.6 Address Translation&lt;/h2>
&lt;p>虚拟地址有两段信息，&lt;strong>虚拟页号&lt;/strong> 以及 &lt;strong>虚拟页偏移量&lt;/strong>，通过虚拟页号查询&lt;strong>页表&lt;/strong>得到物理页号，物理页偏移和虚拟页偏移对应。&lt;/p>
&lt;h3 id="962-利用tlb加速地址翻译">9.6.2 利用TLB加速地址翻译&lt;/h3>
&lt;p>TLB 是什么？TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连性。&lt;/p>
&lt;p>PS：也就是快速地查找 虚拟页表 到 物理页表 的映射。&lt;/p>
&lt;p>下图的描述很清晰，仔细去看 1,2,3 过程。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="963-多级页表">9.6.3 多级页表&lt;/h3>
&lt;p>PS：这个是平头哥面试过程中没有回答出来的部分。对于页表概念的空白，一部分原因应该是对OS的掌握不够。&lt;/p>
&lt;p>为什么需要用到多级页表？得先了解一级页表的缺陷，一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。&lt;/p>
&lt;p>假设虚拟地址空间为32位（即4GB），每个页面映射4KB以及每条页表项占4B：&lt;/p>
&lt;ul>
&lt;li>一级页表：进程需要1M个页表entry（4GB / 4KB = 1M, 2^20个页表项），即页表（每个进程都有一个页表）占用4MB（1M * 4B = 4MB）的内存空间。&lt;/li>
&lt;li>二级页表：一级页表映射4MB（2^22）、二级页表映射4KB，则需要1K个一级页表项（4GB / 4MB = 1K, 2^10个一级页表项）、每个一级页表项对应1K个二级页表项（4MB / 4KB = 1K），这样页表占用4.004MB（1K * 4B + 1K * 1K * 4B = 4.004MB）的内存空间。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>多级页表的内存空间占用反而变大了。但是二级页表可以不存在，二级页表可以存在但不存在主存。&lt;/p>
&lt;p>做个简单的计算，假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB（1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB），对比单级页表的4M是不是一个巨大的节约？&lt;/p>
&lt;p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址；假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有1M个页表项来映射，而二级页表则最少只需要1K个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p>
&lt;/blockquote>
&lt;p>PS：讲一下个人理解。每个process有4GB虚拟地址空间，因为程序的虚拟地址可能是4GB中的任意一个字节。一级页表覆盖了整个4GB的虚拟地址空间，但是如果某个一级页表没有被用到，那么就无需创建这个页表项对应的二级页表，可以在需要时再创建二级页表。&lt;/p>
&lt;h2 id="99-动态内存分配">9.9 动态内存分配&lt;/h2>
&lt;p>这部分和OS以及编程中的内存管理相关。&lt;/p>
&lt;p>显式分配：比如malloc, free, new, delete&lt;/p>
&lt;p>隐式分配：分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。&lt;/p>
&lt;p>垃圾回收（GC, Garbage Collection）：自动释放未使用的已分配的块。一些高级语言会依赖于GC来释放已分配的块，比如 Lisp, ML, JAVA&lt;/p>
&lt;h1 id="10-系统级io">10. 系统级IO&lt;/h1>
&lt;p>将一些输入输出，打开/读取文件，重定向&lt;/p>
&lt;h1 id="11-网络编程">11. 网络编程&lt;/h1>
&lt;p>IP, Socket, Web 服务器, HTTP。&lt;/p>
&lt;p>PS：这部分自己不是很熟&lt;/p>
&lt;h1 id="12-并发编程">12. 并发编程&lt;/h1>
&lt;p>竞争，死锁&lt;/p></description></item><item><title>Paper写作 如何写文章</title><link>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>终于要开始写作了，先动笔把内容填上去，再一步一步地修正。&lt;/p>
&lt;p>自己的想法，摆几篇领域内的经典文章，尤其是相关的，比如前人做的各种调度算法，模仿他们的introduction，关键是要把你自己的动机和故事写上去。&lt;/p>
&lt;p>摆一篇你熟悉的老师的文章，模仿他的风格。&lt;/p>
&lt;h1 id="1-准备工作">1. 准备工作&lt;/h1>
&lt;h2 id="11-论文框架">1.1 论文框架&lt;/h2>
&lt;p>参考 SoCC 的篇幅要求，大概4-6页，参考自己读过的几篇经典的文章，大概可以分为 &lt;strong>Introduction, Background, Baseline Architecture, Adaptive Scheduling, Evaluation, Related Work, Result&lt;/strong>&lt;/p>
&lt;h2 id="12-过往-writing">1.2 过往 Writing&lt;/h2>
&lt;p>找一下之前在研究生论文写作课程中的评价，对自己的写作水平要有数。&lt;/p>
&lt;ul>
&lt;li>还存在一些基本的语法错误。除了自己注意以外，可以使用 Grammarly 之类的工具检查&lt;/li>
&lt;li>HW1，语法错误和格式错误；遣词有些不合理，因为有的源于中文翻译，like &amp;ldquo;people group&amp;rdquo;&lt;/li>
&lt;li>英文表达有待提高，中式英文和介词滥用会影响文章质量&lt;/li>
&lt;li>在HW2中把总结性的话写到了方法介绍的part&lt;/li>
&lt;li>HW3 中，结构组织的还不错，调研充分。&lt;/li>
&lt;/ul>
&lt;h2 id="13-经验结合自己经历">1.3 经验结合自己经历&lt;/h2>
&lt;p>第一遍太注重遣词造句，确实会卡很久，半天都憋不出一段内容，很多经验文章也强调了这点。因此第一遍就按照列好的大纲和逻辑，直白地把自己的内容写出来，之后再去反复修改即可。&lt;/p>
&lt;h1 id="2-如何模仿">2. 如何模仿&lt;/h1>
&lt;p>准备了一些优秀的论文，如何模仿他们的写作方法。&lt;/p>
&lt;h5 id="视频">视频&lt;/h5>
&lt;p>&lt;a href="https://www.zhihu.com/zvideo/1418154868939227136">https://www.zhihu.com/zvideo/1418154868939227136&lt;/a>&lt;/p>
&lt;ul>
&lt;li>目标是 C 会，那么就模仿顶会的写作和框架&lt;/li>
&lt;li>论文一定是修改出来的，反复修改&lt;/li>
&lt;li>抄下来，背下来，经典句式和表达&lt;/li>
&lt;/ul>
&lt;h1 id="3-通用表达学习模仿">3. 通用表达学习/模仿&lt;/h1>
&lt;p>2022-04-11 12:59:07，目前自己写完了大概的初稿，由于词汇量的匮乏和写作水平低下，很多时候会用大量重复的句子表达类似的意思（比如出现了 N 次的 some researchers，比如 LRR exceeds GTO），如果整体结构一成不变也是不行的，现在记录一些别人文章中的经典表达。&lt;/p>
&lt;h5 id="性能提升">性能提升&lt;/h5>
&lt;p>LRR scheduling policy far &lt;strong>outperforms&lt;/strong> GTO, by up to 78% in $conv2$ and 56.7% in $conv3$.&lt;/p>
&lt;p>GTO scheduler &lt;strong>exceeds&lt;/strong> LRR in kernel $conv1$ of ResNet and AlexNet&lt;/p>
&lt;p>MT-prefetching &lt;strong>improves performance&lt;/strong> on average by 16%&lt;/p>
&lt;p>&lt;strong>provide 33% average performance improvement&lt;/strong> compared to the commonly-employed round-robin warp scheduling policy&lt;/p>
&lt;h5 id="分析图片对于xxx">分析图片，对于XXX&lt;/h5>
&lt;p>For example,&lt;/p>
&lt;p>For CifarNet,&lt;/p>
&lt;p>As a result,&lt;/p>
&lt;p>Both the ResNet and AlexNet&lt;/p>
&lt;h1 id="5-一些阅读总结">5. 一些阅读总结&lt;/h1>
&lt;p>&lt;strong>Academic tips:&lt;/strong> &lt;a href="http://taoxie.cs.illinois.edu/advice/">advice collection by Professor Tao Xie&lt;/a>. 有很多有用的关于研究、写作的建议。&lt;/p>
&lt;h5 id="why-i-gave-your-paper-a-strong-reject">Why I gave your paper a Strong Reject&lt;/h5>
&lt;p>&lt;strong>The abstract and intro suck&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这部分有语法错误就很扣分了&lt;/li>
&lt;li>必须在摘要和介绍中描述你的方法和实验结果&lt;/li>
&lt;li>花更多时间在前两页 paper，剩下的只是backup up你在前两页说的东西&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Diving into your solution before defining the problem&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简单地说，就是 motivate the wok&lt;/li>
&lt;li>不要一上来就一大堆细节，先把问题讲清楚&lt;/li>
&lt;li>描述 目标，限制，提供细节的应用（NN，性能差异）；tell that 之前的解决方案 doesn&amp;rsquo;t work&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Focusing the paper on the mundane implementation details, rather than the ideas&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>审稿人只在意你的 idea&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Writing a bunch of wordy bullshit that doesn&amp;rsquo;t mean anything&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简洁而具体&lt;/li>
&lt;li>bad idea 不会因为 sound fancy 而被接收&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Overcomplicating the problem so you get a chance to showcase some elaborate technical approach&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>有时作者会将问题复杂化，以此展示自己的解决方案&lt;/li>
&lt;li>如果将问题简化，那么 beautiful design 可能就不那么必要了&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Figures with no descriptive captions&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>理想情况下，图片的caption需要总结图片的内容和数据含义&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cursory and naive treatment of related work&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>应该讨论相关工作，和你的方法进行对比，而不是简单地列出一堆 reference&lt;/li>
&lt;li>尊重相关工作。 如果您认为这是错误的，请说出来，并说明原因。 如果您正在建立其他人的好想法，请给予他们应有的信任。 正如我的博士生导师曾经告诉我的那样，站在巨人的肩膀上，而不是他们的脚趾上。&lt;/li>
&lt;/ul>
&lt;h5 id="导师教给我的英文论文写作经验">导师教给我的英文论文写作经验&lt;/h5>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/158599066">https://zhuanlan.zhihu.com/p/158599066&lt;/a>&lt;/p>
&lt;ul>
&lt;li>一些没有把握的词语/搭配，copy扔进google里看有没有人曾经使用过&lt;/li>
&lt;/ul>
&lt;h5 id="容易陷入的误区">容易陷入的误区&lt;/h5>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/dcy9w-KjP3TgFKikQbn02w">https://mp.weixin.qq.com/s/dcy9w-KjP3TgFKikQbn02w&lt;/a>&lt;/p>
&lt;ol>
&lt;li>不列大纲，上来就开干。我发现很多认识的大佬都会把每一章节甚至每一段大概要写什么，论点是什么会先列上，这样写起来事半功倍。&lt;/li>
&lt;li>第一遍初稿就极度追求完美，写的每一句话都斟酌很久，精心选词。第一遍如果过于注重语法与修饰，很容易写到崩溃，写了一周都没把前两章写完。一般来说，第一遍只要能把自己要写的大概内容表达清楚即可，甚至有些句子是由单蹦的词语组成也没事，后面一遍遍修改。&lt;/li>
&lt;li>作图草率，稀里哗啦随便画。现在很多reviewer极度缺乏耐心，你图做的不好看基本就被判死刑了。&lt;/li>
&lt;li>自己孤军奋战，不会借助外力。&lt;strong>正如前面选题、读文献、实现idea一样，写论文也要学会借助外力&lt;/strong>。起了草稿之后，多多“骚扰”师兄师姐提意见，让他们帮忙修改（当然你要挂人家名字），然后差不太多了再找老师修改。&lt;/li>
&lt;/ol>
&lt;h5 id="人大赵鑫老师如何以初学者角度写好一篇国际学术论文">【人大赵鑫老师】如何以初学者角度写好一篇国际学术论文？&lt;/h5>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw">https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw&lt;/a>&lt;/p>
&lt;p>画图非常重要，图不行就不要投论文了。&lt;/p>
&lt;p>摘要和结论放在最后写&lt;/p>
&lt;h1 id="6-实际写作感受和总结">6. 实际写作感受和总结&lt;/h1>
&lt;ul>
&lt;li>第一句话可以先概括，尤其是展示图片，然后再开始叙述&lt;/li>
&lt;/ul>
&lt;p>Therefore, 6 bits is needed for each warp and 4 warps need 24 bits in total. 2022-04-13 23:38:34，太漂亮了这一句，忍不住记录一下&lt;/p>
&lt;h1 id="61-词汇">6.1 词汇&lt;/h1>
&lt;p>同义替换的正式语句一定要多收集，多掌握，甚至背诵。&lt;/p>
&lt;h1 id="62-基本格式">6.2 基本格式&lt;/h1>
&lt;p>引用格式：这个是投稿的当天（2022-04-14）娄老师发现的。我之间从 google scholar 上粘贴下来的，实际上自己把需要的信息模板整理好，引用时去找对应的信息就行了，尤其是会议和期刊。（已整理）&lt;/p>
&lt;p>其他：比如 &lt;code>etc. et al.&lt;/code>，要注意后面带一个 &lt;code>.&lt;/code>。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://www.zhihu.com/question/22790506">https://www.zhihu.com/question/22790506&lt;/a> 如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文? By Terafer&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/22790506/answer/990626321">https://www.zhihu.com/question/22790506/answer/990626321&lt;/a> 如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文? By Dr.Evil&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw">https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw&lt;/a> 【人大赵鑫老师】如何以初学者角度写好一篇国际学术论文？&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/158599066">https://zhuanlan.zhihu.com/p/158599066&lt;/a> 导师教给我的英文论文写作经验 By Joy Chu
​&lt;/p></description></item><item><title>Paper写作 文章添加引用</title><link>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>2022-04-10 22:59:52，折腾了一个小时搞定，纠结了很久顺序的问题，其实文末的引用是 bib 自动生成的。粘贴一篇比较好的教程&lt;/p>
&lt;h1 id="1-模板">1. 模板&lt;/h1>
&lt;p>就用 IEEE Conference 模板即可&lt;/p>
&lt;pre tabindex="0">&lt;code>https://www.ieee.org/content/dam/ieee-org/ieee/web/org/pubs/conference-latex-template_10-17-19.zip
&lt;/code>&lt;/pre>&lt;h2 id="11-代码替换">1.1 代码替换&lt;/h2>
&lt;blockquote>
&lt;p>对于 LATEX，我们一般在谷歌学术或者知网导出 &lt;code>BibTex&lt;/code> 格式的参考文献，而 IEEE 会议模版默认使用的参考文献为 &lt;code>\bibitem&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>在同级目录下新建文件 &lt;code>ref.bib&lt;/code>，用来存放需要引用的文章信息&lt;/p>
&lt;p>模板代码替换&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\begin&lt;/span>{thebibliography}{00}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&amp;#39;&amp;#39; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&amp;#39;&amp;#39; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b4} K. Elissa, ``Title of paper if known,&amp;#39;&amp;#39; unpublished.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b5} R. Nicole, ``Title of paper with only first word capitalized,&amp;#39;&amp;#39; J. Name Stand. Abbrev., in press.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&amp;#39;&amp;#39; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b7} M. Young, The Technical Writer&amp;#39;s Handbook. Mill Valley, CA: University Science, 1989.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\end&lt;/span>{thebibliography}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接替换为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibliographystyle&lt;/span>{IEEEtran}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibliography&lt;/span>{references}{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="12-bib-文件">1.2 bib 文件&lt;/h2>
&lt;p>在 &lt;code>ref.bib&lt;/code> 中添加一篇参考文献&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@article{creswell2018generative,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={Generative adversarial networks: An overview},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Creswell, Antonia and White, Tom and Dumoulin, Vincent and Arulkumaran, Kai and Sengupta, Biswa and Bharath, Anil A},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> journal={IEEE Signal Processing Magazine},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume={35},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number={1},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages={53--65},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2018},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={IEEE}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-正文中引用">1.3 正文中引用&lt;/h2>
&lt;p>原来不是手动输入框框 []，通过代码 &lt;code>\cite{creswell2018generative}&lt;/code> 来引用，LaTex 会自动编号参考文献（原来不是手动地在后面添加）&lt;/p>
&lt;h1 id="2-编译">2. 编译&lt;/h1>
&lt;p>还有关键的一步，编译需要选择 &lt;code>PDFLaTex ——&amp;gt;BibTex——&amp;gt;PDFLaTex——&amp;gt;PDFLaTex&lt;/code>&lt;/p>
&lt;h1 id="3-引用模板">3. 引用模板&lt;/h1>
&lt;h2 id="31-会议">3.1 会议&lt;/h2>
&lt;p>需要 author, booktile 填一下会议的名称，如果加了缩写，那么所有引用都加上缩写，个人喜欢加上缩写。Proceedings of the 是自己手动添加的，后面跟上会议名称即可，根据别人的引用情况，去掉了类似于“第几届”，“IEEE”之类的信息&lt;/p>
&lt;p>title 填写文章标题，&lt;strong>需要注意的是如果有大写&lt;/strong>，需要用 &lt;code>{}&lt;/code> 括起来，这个 CAWA 其实是一个典型，甚至第一次提交（2022-04-14 16:47:01）忘记了大写 GPGPU，而最开始别人标题中的大写没有生效，后来发现是 {} 的原因&lt;/p>
&lt;p>address 最好加上，正式一点，搜一下这个会议就能查到了。year 和 page 是一定要有的。page 要注意有些 bibtex 没有给完整，只有一页，需要自己去核对一下。&lt;/p>
&lt;p>以目前的了解（2022-04-14 20:10:36），其他信息应该不作要求&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@INPROCEEDINGS{7284091,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author={Lee, Shin-Ying and Arunkumar, Akhil and Wu, Carole-Jean},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>booktitle={Proceedings of the International Symposium on Computer Architecture (ISCA)},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title={{CAWA}: Coordinated warp scheduling and Cache Prioritization for critical warp acceleration of GPGPU workloads},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>address={Portland, OR, USA},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>year={2015},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>volume={},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>number={},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pages={515-527}, doi={10.1145/2749469.2750418}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="32-期刊">3.2 期刊&lt;/h2>
&lt;p>title, author, pages, year 等信息和会议类似。&lt;/p>
&lt;p>journal 填写期刊名称就行，根据全局的情况加上缩写。不过这个 Computing in Science &amp;amp; Engineering 的缩写为 Computing Sci. Eng.，感觉比较相似我就没加，之后核对一下。&lt;/p>
&lt;p>volume, number 是期刊区别于会议的信息，要正确填写。期刊一般没有 address&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@article{stone2010opencl,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={{OpenCL}: A parallel programming standard for heterogeneous computing systems},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Stone, John E and Gohara, David and Shi, Guochun},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> journal={Computing in Science &lt;span style="color:#66d9ef">\&amp;amp;&lt;/span> Engineering},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume={12},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number={3},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2010},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages={66-73},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={NIH Public Access}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="33-书籍">3.3 书籍&lt;/h2>
&lt;p>除了这些信息，可能还需要别的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@book{farber2011cuda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={{CUDA} application design and development},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Farber, Rob},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2011},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={Elsevier}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="34-技术报告">3.4 技术报告&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@TECHREPORT{Krizhevsky09learningmultiple,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author = {Alex Krizhevsky},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title = {Learning multiple layers of features from tiny images},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> institution = {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year = {2009}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://blog.51cto.com/u_13977270/3398538">https://blog.51cto.com/u_13977270/3398538&lt;/a> IEEE 会议论文的参考文献&lt;/p></description></item><item><title>Hugo 文件结构</title><link>https://huweim.github.io/post/blog_hugo_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 19 Apr 2022 18:10:17 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>配置博客的代码高亮&lt;/p>
&lt;h1 id="1-文件夹结构">1. 文件夹结构&lt;/h1>
&lt;p>其中，&lt;code>config.toml&lt;/code> 是网站的配置文件，Hugo还可使用 &lt;code>config.yaml&lt;/code> 或者 &lt;code>config.json&lt;/code> 进行配置。&lt;/p>
&lt;p>&lt;code>content&lt;/code> 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。&lt;/p>
&lt;p>&lt;code>layouts&lt;/code> 文件夹存放 &lt;code>.html&lt;/code> 格式的模板。模板确定了静态网站渲染的样式。&lt;/p>
&lt;p>&lt;code>themes&lt;/code> 文件夹存放网站使用的theme主题模板。&lt;/p>
&lt;p>&lt;code>static&lt;/code> 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。&lt;/p>
&lt;p>&lt;code>archetypes&lt;/code> 文件夹存放网站预设置的文件模板头部，当使用 &lt;code>hugo new&lt;/code> 时即可生成一个带有该头部的实例。&lt;/p>
&lt;p>&lt;code>data&lt;/code> 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。&lt;/p>
&lt;h2 id="11-post">1.1 Post&lt;/h2>
&lt;pre tabindex="0">&lt;code>---
date: &amp;#34;2021-07-08T19:38:26+08:00&amp;#34;
draft: false
title: &amp;#34;Blog&amp;#34;
---
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>其中，&lt;code>date&lt;/code> 说明该博客建立时间，&lt;code>draft&lt;/code> 说明这篇是否是草稿，若是草稿，在无特别指明情况下并不会生成静态网页，&lt;code>title&lt;/code> 表明该文件显示的标题。&lt;/p>
&lt;p>在同样文件夹下，建立其他 &lt;code>.md&lt;/code> 文件，同样也是有相似的文件头部。该博客的文件名应和 &lt;code>title&lt;/code> 一致，但要注意 &lt;code>title&lt;/code> 中的空格或者 &lt;code>+&lt;/code> 作为文件名时应该替换成&lt;code>-&lt;/code>， 不然会报找不到404网页。文件内容在这块区域下面，使用markdown语法。&lt;/p>
&lt;/blockquote></description></item><item><title>Hugo 文章扉页设置</title><link>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E6%89%89%E9%A1%B5%E8%AE%BE%E7%BD%AE/</link><pubDate>Tue, 19 Apr 2022 18:10:17 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E6%89%89%E9%A1%B5%E8%AE%BE%E7%BD%AE/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>描述如何设置和自定义一篇 post 的页面内容和标签&lt;/p>
&lt;p>这个在英文中的描述应该是 扉页 front matter&lt;/p>
&lt;h1 id="1原型">1、原型&lt;/h1>
&lt;p>原型是创建新页面内容（运行&lt;code>hugo new&lt;/code>命令）时使用的模板，预先配置格式：例如md文件的&lt;strong>扉页&lt;/strong>（ front matter）、其它格式等。原型文件应该存放在&lt;strong>archetypes&lt;/strong>目录内。&lt;/p>
&lt;p>原型（&lt;strong>archetypes/default.md&lt;/strong>）内的扉页貌似不能进行日期格式转换：&lt;/p>
&lt;ul>
&lt;li>date属性只能是&lt;code>date: {{ .Date }}&lt;/code>，因为之后的日期格式转换&lt;a href="https://gohugo.io/functions/format/#hugo-date-and-time-templating-reference">基于此date属性&lt;/a>。若&lt;code>date: {{.Date.Format &amp;quot;2006-01-02&amp;quot;}}&lt;/code>，将会触发错误：Error: Failed to process archetype file “default.md”:: template: default:3:19: executing “default” at &amp;lt;.Date.format&amp;gt;: can&amp;rsquo;t evaluate field format in type string&lt;/li>
&lt;/ul>
&lt;h2 id="11-archetypesdefaultmd">1.1 archetypes/default.md&lt;/h2>
&lt;p>default.md：将md文件构建为HTML的页面文件（type：缺省）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ replace .Name &amp;#34;&lt;/span>-&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; | title }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: {{ &lt;span style="color:#ae81ff">.Date }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;komantao&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierDisplayName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;komantao&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierEmail&lt;/span>: &lt;span style="color:#ae81ff">komantao@hotmail.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">url&lt;/span>: {{ &lt;span style="color:#ae81ff">replace .Dir &amp;#34;\\&amp;#34; &amp;#34;/&amp;#34; }}{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}.html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">draft&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;文章描述&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">keywords&lt;/span>: [&lt;span style="color:#ae81ff">keyword1, keyword2, keyword3]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: [&lt;span style="color:#ae81ff">标签1, 标签2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: [&lt;span style="color:#ae81ff">分类1, 分类2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">首页描述。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="3扉页">3、扉页&lt;/h1>
&lt;p>扉页（ front matter）用来配置文章的标题、时间、链接、分类等元信息，提供给模板调用。可使用的格式有：yaml格式（默认格式，使用3个减号-）、toml格式（使用3个加号+）、json格式（使用大括号{}）。除了网站主页外，其它内容文件都需要扉页来识别文件类型和编译文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章标题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">menuTitle&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章标题在菜单栏中显示的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">keywords&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;Hugo&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;keyword&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 关键字描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2018-08-20&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章创建日期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;tag1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;tag2&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 自定义标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;cat1&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;cat2&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 自定义分类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#75715e"># 自定义此页面在章节中的排序优先级（按照数字的正序排序）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">disableToc&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 若值为false（缺省值）时，此页面启用TOC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">pre&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义menu标题的前缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">post&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义menu标题的后缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">chapter&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># 若值为true（缺省值）时，将此页面设置为章节（chapter）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">hidden&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># 若值为true（缺省值）时，此页面在menu中隐藏&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierDisplayName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义修改者的名称，显示在页脚中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierEmail&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义修改者的Email，显示在页脚中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">draft&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># true，表示草稿，Hugo将不渲染草稿&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#75715e"># 重置permalink，默认使用文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#75715e"># type与layout参数将改变Hugo寻找该文章模板的顺序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">layout&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>weight属性&lt;/p>
&lt;ul>
&lt;li>缺省时按照date属性的倒序排序（新日期排在前面）&lt;/li>
&lt;li>设置时，自定义此页面在章节中的排序（按照数字值的正序排序，数字小的排在前面，若数字值相同，则按照date属性的倒序排序）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>pre属性&lt;/p>
&lt;p>在菜单栏中的标题前添加前缀：可为数字、文字、图标（&lt;a href="https://fontawesome.com/v4.7.0/icons/">&lt;strong>Font Awesome&lt;/strong>&lt;/a>库）等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">+++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">title = &amp;#34;Github repo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">pre = &amp;#34;&amp;lt;i class=&amp;#39;fab fa-github&amp;#39;&amp;gt;&amp;lt;/i&amp;gt; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">+++&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>menuTitle属性&lt;/p>
&lt;ul>
&lt;li>缺省时调用title属性作为此页面在menu中显示的名称&lt;/li>
&lt;li>设置时，自定义此页面在menu中显示的名称&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://kuang.netlify.app/blog/hugo.html">https://kuang.netlify.app/blog/hugo.html&lt;/a>&lt;/p></description></item><item><title>LeetCode刷题记录</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 16 Mar 2022 08:59:50 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>&lt;h4 id="关键字检索">关键字检索&lt;/h4>
&lt;ul>
&lt;li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。&lt;/li>
&lt;li>知识点：题目所涉及到的大概知识点。&lt;/li>
&lt;li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针&lt;/li>
&lt;li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。&lt;/li>
&lt;/ul>
&lt;h4 id="短板总结">短板总结&lt;/h4>
&lt;ul>
&lt;li>短板：二叉树，矩阵，DFS，BFS&lt;/li>
&lt;/ul>
&lt;p>2022-04-15 17:28:42，BFS，DFS，二叉树 稍微熟练了一些；目前的短板&lt;/p>
&lt;ul>
&lt;li>DP，堆，矩阵&lt;/li>
&lt;/ul>
&lt;h3 id="常见-bug">常见 BUG&lt;/h3>
&lt;h5 id="1-itoa">1. itoa&lt;/h5>
&lt;p>gcc error : undefined reference to `itoa'&lt;/p>
&lt;p>原因：itoa is a non-standard function which is supported by some compilers. Going by the error, it&amp;rsquo;s not supported by your compiler. Your best bet is to use snprintf() instead.&lt;/p>
&lt;h3 id="311">3.11&lt;/h3>
&lt;h4 id="查缺补漏">查缺补漏&lt;/h4>
&lt;ul>
&lt;li>二叉树建树&lt;/li>
&lt;li>二叉树后序遍历&lt;/li>
&lt;/ul>
&lt;h3 id="311-1">3.11&lt;/h3>
&lt;h5 id="jz03">JZ.03&lt;/h5>
&lt;p>3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；&lt;/p>
&lt;p>第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)&lt;/p>
&lt;p>第三种原地Hash，鸽巢原理。源于一个条件 &lt;code>element value &amp;lt; nums.size()&lt;/code>，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector 可以用下标索引&lt;/li>
&lt;li>标签：hash，排序，数组&lt;/li>
&lt;/ul>
&lt;h5 id="jz04-二维数组中的查找-">JZ.04 二维数组中的查找 ❌&lt;/h5>
&lt;p>感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)&lt;/p>
&lt;p>并非 DP，没有秒这题；主要是思路上的解法而非常规算法&lt;/p>
&lt;blockquote>
&lt;p>从右上角开始比较，比它大就往下数一行，比它小就往左数一列&lt;/p>
&lt;p>二分查找也是解法之一&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二维 vector 能否用下标索引？
&lt;ul>
&lt;li>可以&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标签：数组，二分查找，分治，矩阵&lt;/li>
&lt;/ul>
&lt;h5 id="jz05-替换空格">JZ.05 替换空格&lt;/h5>
&lt;p>简单的字符串替换，被 string 和 char，&amp;quot;&amp;quot; 和 &amp;rsquo;&amp;rsquo; 的一些知识卡了一会儿。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>字符串裁剪 &lt;code>str.substr(pos, len)&lt;/code>，&lt;/li>
&lt;li>⚠️ 字符串比较；string 可以直接用 &lt;code>==&lt;/code>，但是注意 s[0] 是 char 型；所以 &lt;code>s[0] == &amp;quot; &amp;quot;&lt;/code> 会报错，应该是 &lt;code>s[0] == ' '&lt;/code>；或者 &lt;code>strcmp(s[0], ' ');&lt;/code>&lt;/li>
&lt;li>注意 &amp;quot;&amp;quot; 和 ''&lt;/li>
&lt;li>❗ 为什么不能用 strcmp？
&lt;ul>
&lt;li>用 &lt;code>strcmp(string , string)&lt;/code> 会就报错；使用 &lt;code>strcmp(char [], char[])&lt;/code> 就可以了；有什么区别？&lt;/li>
&lt;li>string 是一个 managed type，不用担心有多长；char[] 分配的长度固定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz06-反转链表">&lt;strong>JZ.06 反转链表&lt;/strong>&lt;/h5>
&lt;p>从尾到头打印链表，单链表&lt;/p>
&lt;p>自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$&lt;/p>
&lt;p>也可以使用 递归&lt;/p>
&lt;p>⚠️ 注意边界条件，基本每次 case 都会有&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>单向链表；指针；vector&lt;/li>
&lt;li>标签：栈，链表，递归，双指针&lt;/li>
&lt;/ul>
&lt;h3 id="313">3.13&lt;/h3>
&lt;h5 id="jz07-重建二叉树-">JZ.07 重建二叉树 ❌&lt;/h5>
&lt;p>二叉树和链表的数据结构要记住。&lt;/p>
&lt;p>如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解&lt;/p>
&lt;p>In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。&lt;/p>
&lt;p>❌ 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。&lt;/p>
&lt;p>pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>前序遍历列表：第一个元素永远是 【根节点 (root)】&lt;/li>
&lt;li>中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】&lt;/li>
&lt;li>做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end&lt;/li>
&lt;li>标签：数组，hash，分治，二叉树&lt;/li>
&lt;/ul>
&lt;h5 id="jz09-用两个栈实现队列">JZ.09 用两个栈实现队列&lt;/h5>
&lt;p>自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。&lt;/p>
&lt;p>更好的思路：其实不用再把 stack_2 中全部倒回 stack_1&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？&lt;code>stack&amp;lt;int&amp;gt; stk; queue&amp;lt;int&amp;gt; q;&lt;/code>&lt;/li>
&lt;li>两个栈实现队列&lt;/li>
&lt;li>标签：栈，队列&lt;/li>
&lt;/ul>
&lt;h5 id="jz10-斐波那契数列-dp">JZ.10 斐波那契数列 DP&lt;/h5>
&lt;p>自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归&lt;/p>
&lt;p>更好的思路：这题可以用 DP，没有想到。&lt;/p>
&lt;p>现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；&lt;/p>
&lt;p>转移方程：$dp[i+1] = dp[i] + dp[i-1]$&lt;/p>
&lt;p>初始状态：$dp[0] = 0; dp[1] = 1$&lt;/p>
&lt;p>返回值：$dp[n]$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路&lt;/li>
&lt;li>标签：DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz11-青蛙跳台阶">JZ.11 青蛙跳台阶&lt;/h5>
&lt;p>自己的思路：hash 递归；DP&lt;/p>
&lt;p>和上一题很类似，写的是优化空间后的 DP，&lt;/p>
&lt;p>✔️ 要求自己写一个常规的 DP 加深理解&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz11-旋转数组的最小数字-">JZ.11 旋转数组的最小数字 ❌&lt;/h5>
&lt;blockquote>
&lt;p>这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的&lt;/p>
&lt;/blockquote>
&lt;p>确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：二分查找，数组&lt;/li>
&lt;li>查缺补漏：二分查找熟练度不够&lt;/li>
&lt;/ul>
&lt;h3 id="314">3.14&lt;/h3>
&lt;h5 id="jz12-矩阵中的路径-">JZ.12 矩阵中的路径 ❌&lt;/h5>
&lt;p>自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$&lt;/p>
&lt;p>题解 DFS，DFS 已经非常生疏了&lt;/p>
&lt;p>看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>典型的矩阵搜索问题&lt;/li>
&lt;/ul>
&lt;h5 id="jz13-机器人运动范围">JZ.13 机器人运动范围&lt;/h5>
&lt;p>这个也是算法设计课程中出现的考试题目。&lt;/p>
&lt;p>自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。&lt;/p>
&lt;p>写错了一句 &lt;code>tag[i][j] == -1;&lt;/code>，报错居然是 &lt;code>stackoverflow&lt;/code>，要注意尽量一次写出 bug-free code。&lt;/p>
&lt;p>题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>和上一题类似，也是矩阵，DFS还是可以用。&lt;/li>
&lt;li>标签：&lt;strong>DP&lt;/strong>，BFS，DFS；DP 体现在哪？了解 DP 的解法&lt;/li>
&lt;/ul>
&lt;h5 id="jz14-i-剪绳子-">JZ.14-I 剪绳子 ❌&lt;/h5>
&lt;p>自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$&lt;/p>
&lt;p>更好的思路：&lt;/p>
&lt;p>&lt;strong>DP&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>求长度为 n 的绳子剪掉后的乘积，从 &amp;lt;n 的绳子转移而来&lt;/li>
&lt;li>&lt;code>dp数组&lt;/code> 记录 &lt;code>0到n&lt;/code> 的绳子的最大乘积，初始化 &lt;code>dp[2] = 1&lt;/code>&lt;/li>
&lt;li>剪掉第一段，长度为 j，j &amp;gt; 1&lt;/li>
&lt;li>剪了第一段，剩下长度为 &lt;code>(i - j)&lt;/code> 可以剪或者不剪。不剪的话 &lt;code>length = j * (i - j)&lt;/code>；剪了的话 &lt;code>length = j * dp[i - j]&lt;/code>；&lt;code>max(j * (i - j), j * dp[i - j])&lt;/code>&lt;/li>
&lt;li>遍历 j，$j \in [2, i)$，取最大值。&lt;/li>
&lt;/ul>
&lt;p>难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。&lt;/p>
&lt;p>&lt;strong>2022-03-16 10:38:06&lt;/strong>，尝试写一下 DP 解法 ✔️。DP 和自己的思路性能差不多。&lt;/p>
&lt;p>&lt;strong>贪心&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>均值不等式思想；n &amp;gt; 4 时，尽可能把绳子分为长度为 3 的小段，进行乘加。&lt;/li>
&lt;/ul>
&lt;h3 id="316">3.16&lt;/h3>
&lt;h5 id="jz14-ii-剪绳子">JZ.14-II 剪绳子&lt;/h5>
&lt;p>在 I 的基础上加了一个答案取模，取模对于加法没有影响，~~但是会影响乘法的计算结果。~~并没有，那么这题在考察什么？&lt;/p>
&lt;p>这个题目就是考察贪心的解法，如果继续用 DP，应该会超时&lt;/p>
&lt;h5 id="jz15-二进制中1的个数">JZ.15 二进制中1的个数&lt;/h5>
&lt;p>考察位运算。&lt;/p>
&lt;p>自己的思路：比较基础的 $/2%2$ 进行二进制化，时间复杂度 $O(logn)$，可以AC。bitset&lt;/p>
&lt;p>更好的思路：$n&amp;amp;(n-1)$，$n-1:$ 二进制数字 $n$ 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1；$n&amp;amp;(n - 1):$ 二进制数字 $n$ 最右边的 1 变成 0 ，其余不变。时间复杂度 $O(M)$，M 为 1 的数量&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：位运算&lt;/li>
&lt;/ul>
&lt;h5 id="jz16-数值的整数次方-">JZ.16 数值的整数次方 ❌&lt;/h5>
&lt;p>自己的思路：计算 $pow(x, n)$，naive 直接乘 $n$ 次，时间复杂度 $O(n)$，会超时，因此需要的不是 $O(n)$ 的解法。好像和复杂度没有关系，注意 $n$ 的范围，涉及越界的问题。&lt;/p>
&lt;blockquote>
&lt;p>&lt;del>我认为这个应该就是考察 INT 型表示范围的细节，尤其是 $n = 0 - n$ 这种写法会越界&lt;/del>。看来并非如此&lt;/p>
&lt;/blockquote>
&lt;p>处理了越界仍然会超时，用 $x$ 的范围去换 $n$ 的范围。这样并没有降低时间复杂度的数量级，304 case 全过但是仍然超时。因此猜测 $O(n)$​ 的解法 A 不了。加了一个判断 &lt;code>if(x &amp;lt; 0.000005) return x * init_x;&lt;/code> 后 AC 了，因为输出只保留到小数点后 5 位，有点取巧，虽然 AC 但是可能没有满足这道题的考察意图。⚠️ 这个取巧做法不能算真正的 AC。&lt;/p>
&lt;p>&lt;strong>更好的解法&lt;/strong>：确实有 $O(logn)$ 的解法，&lt;strong>快速幂&lt;/strong>。快速幂也就是在循环中递归地使用你只用了一次的降幂操作，每次可以降幂的时候，$x *= x, n &amp;raquo;= 1$，这样将复杂度降至 $O(logn)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>$(-3) % 2$，余数是 1 还是 -1？答案：余数是 -1&lt;/li>
&lt;li>标签：递归，数学&lt;/li>
&lt;/ul>
&lt;h5 id="jz17-打印从1到最大的n位数">JZ.17 打印从1到最大的n位数&lt;/h5>
&lt;p>自己的思路：遍历，时间复杂度 $O(10^n)$，直接 A，意义在哪？评论区有人说原题目是要考虑大数越界问题的。因此，这道题的本意应该是考察字符串和整型数字的转换。&lt;/p>
&lt;p>先放一下&lt;/p>
&lt;blockquote>
&lt;p>若不考虑大数问题，则十分简单一个从1到最大数的循环即可。 若考虑大数问题，则首先需要将数字转成字符串避免溢出，然后全排列字符串的第0位到第n-1位。 存储结果时需去掉字符串前几位的0(0099没有意义，应为99)再放入结果。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：数组（越界，大数），字符串&lt;/li>
&lt;/ul>
&lt;h5 id="jz18-删除链表的节点">JZ.18 删除链表的节点&lt;/h5>
&lt;p>自己的思路：最简单的单链表删除，时间复杂度 $O(n)$，AC。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：链表&lt;/li>
&lt;/ul>
&lt;h5 id="jz20-表示数值的字符串">JZ.20 表示数值的字符串&lt;/h5>
&lt;p>这个题是有实用性的，也许在某些爬虫提取数据的时候会用到。&lt;/p>
&lt;p>自己的思路：就是用条件判断筛选出不合规的情况 &lt;code>return false&lt;/code>，第一次以为空格直接删除就行，提交后发现空格不能出现在有效符号的中间。&lt;/p>
&lt;p>提交 23 次 AC，基本就是看着 case 补条件，完全没有周全考虑，没有使用正则表达式思想。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：字符串，有限状态机&lt;/li>
&lt;/ul>
&lt;h5 id="jz21-调整数组顺序使奇数位于偶数前面">JZ.21 调整数组顺序使奇数位于偶数前面&lt;/h5>
&lt;p>自己的思路：两次遍历，$O(n)$，AC，有没有复杂度更低的解法？&lt;/p>
&lt;p>题解的思路：也是 $O(n)$ 复杂度，但只用遍历一次，双指针，类似快排的思路。分别从左右开始遍历，然后交换。稍快一点。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：数组，双指针，排序&lt;/li>
&lt;/ul>
&lt;h5 id="jz22-链表中倒数第k个节点">JZ.22 链表中倒数第k个节点&lt;/h5>
&lt;p>自己的思路：打印倒数的节点，所以遍历两次，第一次确定链表长度 L，L - k 次 next 就可以找到目标结果，然后返回，AC，时间复杂度 $O(n)$&lt;/p>
&lt;p>更好的解法：双指针，无需统计链表的长度。前指针先走 $k$ 步，然后共同移动，前指针到终点时返回后指针即可，时间复杂度 $O(n)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：链表，双指针&lt;/li>
&lt;/ul>
&lt;h5 id="jz24-反转链表">JZ.24 反转链表&lt;/h5>
&lt;p>自己的思路：一次遍历，forward 指针在前，head 自己在后，一遍遍历一边调整，AC，时间复杂度 O(n)。&lt;/p>
&lt;p>❌ 注意边界条件，注意条件判断时写了 &lt;code>if(head-&amp;gt;next == NULL || head == NULL)&lt;/code>，报错。因为当 head==NULL，是找不到 head-&amp;gt;next，自己写代码不要忽略边界和细节。&lt;/p>
&lt;p>题解：除双指针，还有递归的解法，时间空间都是 $O(n)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：递归，链表&lt;/li>
&lt;li>关于递归，心中要有明确的终止条件的概念。&lt;/li>
&lt;/ul>
&lt;h5 id="jz25-合并两个递增排序的链表">JZ.25 合并两个递增排序的链表&lt;/h5>
&lt;p>自己的思路：非常基础的算法题，一次遍历，其中一个链表完成遍历后直接接过去。最初出现错误的原因：遍历的时候 &lt;code>l2 = l2-&amp;gt;next&lt;/code>，忘记保存头结点。&lt;/p>
&lt;p>一开始的合并写法没有 AC，逻辑有点混乱了，后来直接换了一种写法，新建了一个链表，比较耗费空间，时间复杂度 $O(m+n)$，空间复杂度 $O(m+n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：递归，链表&lt;/li>
&lt;li>引入 &lt;strong>伪头结点&lt;/strong> 合并链表是本题的最优解&lt;/li>
&lt;/ul>
&lt;h4 id="317">3.17&lt;/h4>
&lt;h5 id="jz26-树的子结构-">JZ.26 树的子结构 ❌&lt;/h5>
&lt;p>又到了短板，二叉树相关的题目。&lt;/p>
&lt;p>自己的思路：是否会有一段完全相同的中序遍历？中序遍历能否唯一确定？手写中序遍历 DFS，大概的还记得，有些地方比如 visied，还有判断条件（only care left）疏忽了，但是很快能想起来。Value 还存在负数，那么只能前序也 check 一次了。&lt;/p>
&lt;p>check 了一次前序一次中序，但是还是 AC 不了，说明一开始的思路可能有点问题。写出了前序和中序，但是没法 AC，思路是错的。&lt;/p>
&lt;p>更好的解法：遍历 A 树中的每个节点 $n_A$，判断以 $n_A$ 为根节点的字数是否包含 B。状态一般，没有自己手写题解，之后再熟悉一遍。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：树，DFS&lt;/li>
&lt;/ul>
&lt;h5 id="jz27-二叉树的镜像">JZ.27 二叉树的镜像&lt;/h5>
&lt;p>自己的思路：简单递归。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，由递归栈的深度决定.&lt;/p>
&lt;h5 id="jz28-对称的二叉树-">JZ.28 对称的二叉树 ⚠️&lt;/h5>
&lt;p>自己的思路：一开始直接指针指向 root，翻转二叉树，比较，忽略了只是指针指向了 root，没有保留翻转前的树。后来分别使用递归建树、翻转、比较，AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>更好的思路：一次递归，无需求镜像。递归地比较左右子树是否相等即可&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这个题用到和复习的知识点比较多，包括建树。翻转二叉树，比较&lt;/li>
&lt;li>标签：二叉树，BFS，DFS&lt;/li>
&lt;/ul>
&lt;h5 id="jz29-顺时针打印矩阵">JZ.29 顺时针打印矩阵&lt;/h5>
&lt;p>自己的思路：没考虑算法，用循环每次 push 边界上的几组数，然后不断地更新边界条件，直到所有数都 push 进去。注意边界条件。AC，时间复杂度 $o(mn)$，空间复杂度 $O(mn)$。&lt;/p>
&lt;p>题解：和 K 神题解的思想差不多。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，矩阵，模拟&lt;/li>
&lt;/ul>
&lt;h5 id="jz30-包含-min-的栈">JZ.30 包含 min 的栈&lt;/h5>
&lt;p>自己的思路：用 vector 实现，push 的时候对比一下记录 min 即可，关于 vector 的指定 index 删除有点忘记了。&lt;code>v.erase(pos)&lt;/code>。噢，不过突然想起 stack 是先进后出，那么直接 &lt;code>v.pop_back()&lt;/code> 删掉最后一个即可。不过为了更加造轮子，还是不用 STL 了吧，用数组好了。&lt;/p>
&lt;p>还有一个细节，还需要额外保存一个次小值，当 min pop 时需要用次小值顶上。次小值还不够，应该用一个数组记录不同 stack size 时的 min，空间换时间。&lt;/p>
&lt;p>❗ 细节：栈空时要重置 min。&lt;/p>
&lt;p>题解：很多题解都是用辅助栈，不过这题个人主要是尝试用数组求解。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>关于 vector 的指定 index 删除。&lt;code>v.erase(pos)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h5 id="jz31-栈的-push-pop-顺序">JZ.31 栈的 push, pop 顺序&lt;/h5>
&lt;p>也是经典的算法考题，给一个 push 顺序和 pop 顺序，判断 pop 顺序是否有可能是该 push 顺序下的一个 pop 结果。&lt;/p>
&lt;p>自己的思路：插 pop，给出所有可能性然后对比，这样复杂度有点太夸张了。加一点数学思路来优化，假设 push 序列是顺序的，如果 4 pop，那么 4 之后 &amp;lt;4 的元素出栈时一定不可能是升序，比如 1，2，3；推理到元素 i 出栈，之后 $&amp;lt;i$ 的元素出栈序列一定是降序排列。&lt;/p>
&lt;p>不一定是顺序输入，所以可能需要用 hash 转换一下。hash 转换得费点脑子，找找经典的理解方法。注意细节，mmax 更换时 slide_min 便作废了。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，用了额外的 hash 空间排序。&lt;/p>
&lt;p>题解：这个题其实蛮有意思，题解完全是另一种做法，自己是利用一些数学/算法上的特征解的。根据 push 序列模拟入栈操作，当栈顶元素 &lt;code>top() == popped[i]&lt;/code> 时出栈元素，i++，push 操作完成观察栈是否空即可。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：栈，数组，模拟&lt;/li>
&lt;li>自己使用到了 hash 思想；栈的基本知识；栈空时调用 s.top() 会报错&lt;/li>
&lt;/ul>
&lt;h5 id="jz32-ii-从上到下打印二叉树">JZ.32-II 从上到下打印二叉树&lt;/h5>
&lt;p>自己的思路：线序遍历，根据 height 来决定 push 到哪一行。其中遇到了 vector 初始化的问题，不初始化没办法直接 &lt;code>v[height].push_back(root-&amp;gt;val)&lt;/code>，先根据上限 &lt;code>v.resize(1000)&lt;/code>，遍历结束后根据深度 &lt;code>v.resize(height+1);&lt;/code> 即可。时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二维 vector 初始化
&lt;ul>
&lt;li>&lt;code>v.resize(4); v[0].resize(4);&lt;/code>&lt;/li>
&lt;li>&lt;code>vector&amp;lt;vecotr&amp;lt;int&amp;gt;&amp;gt; v(m, vector&amp;lt;int&amp;gt;(n, 0))&lt;/code>; m 行 n 列全部初始化为0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz32-iii-从上到下打印二叉树">JZ.32-III 从上到下打印二叉树&lt;/h5>
&lt;p>和上题区别在于，第一层从左到右打印，第二层从右到左打印，没法先序遍历直接解。&lt;/p>
&lt;p>自己的思路：vector 是否自带 reverse？正好复习一下，&lt;code>reverse(v.begin(), v.end());&lt;/code>，AC。&lt;/p>
&lt;p>不过有评论说这是经典面试0分方法 😓，那认真学习下题解思路。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：树，BFS&lt;/li>
&lt;li>reverse()&lt;/li>
&lt;/ul>
&lt;h4 id="318">3.18&lt;/h4>
&lt;p>2022-03-17 22:45:21，先把两道树的题方法搞了。贪心和 DP 是薄弱点，后期要加强。&lt;/p>
&lt;h4 id="319">3.19&lt;/h4>
&lt;h5 id="606-construct-string-from-binary-tree-每日一题">606. Construct String from Binary Tree 每日一题&lt;/h5>
&lt;p>这道题中文描述简直是 bullshit，还没给范围，之后直接看英文好了。这道题应该是简单吗？虽然确实不太难但是东西还蛮多，涉及先序遍历，数字转字符串等等。&lt;/p>
&lt;p>自己的思路：先序遍历，数字转字符串，可以省略空子树的括号，省略右子树为空仅有左子树时的括号。时间复杂度 $O(n)$&lt;/p>
&lt;p>&lt;strong>彩蛋&lt;/strong>：2020.04.02 AC过，当时直接用的 &lt;code>to_string()&lt;/code>，记一下这个函数。不知道当时是不是看的题解，那个时候写的解法更好一点~&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>树，DFS，字符串&lt;/li>
&lt;/ul>
&lt;h4 id="320">3.20&lt;/h4>
&lt;h5 id="jz33-二叉搜索树的后序遍历-">JZ.33 二叉搜索树的后序遍历 ❌&lt;/h5>
&lt;p>一开始看题目描述蒙了，没有理解其意思。原来是忽略了二叉搜索树这个条件，太久没有接触到所以生疏了，也就是左孩子 value 小于当前节点，右孩子 value 大于当前节点。&lt;/p>
&lt;p>自己的思路：后序遍历建树，后序遍历不能唯一确定，不过二叉搜索树好像是完全二叉树？这点得确认一下，先按照这个假设。然后判断建好的树是否满足搜索树的概念。&lt;/p>
&lt;p>注意：循环中，&lt;code>it&lt;/code> 不能回到 begin，因为 begin 位置上可能还有之前跳过的数字，留在当前位置即可。出现了意料之外的 case，所以搜索树不一定是完全二叉树？确实如此。&lt;/p>
&lt;p>题解思路：遍历顺序 左右根。这个思路之前有想过。后续遍历区间$[i,j]$，遍历划分左右子树区间，找到第一个大于 root 的元素 index $m$，左子树区间 $[i, m-1]$，右子树区间 $[m,j-1]$，递归判断子树的合法性即可。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector：可以使用迭代器作为 &lt;code>v.erase(pos)&lt;/code> 中的 pos 进行删除；删除后 &lt;code>v.size()&lt;/code> 会发生变化.&lt;/li>
&lt;li>二叉搜索树的概念，正是因为记错了所以思路出现了问题。&lt;/li>
&lt;li>后续遍历的性质，左右根，左右子树的区间&lt;/li>
&lt;li>标签：栈，树，二叉搜索树，递归，单调栈&lt;/li>
&lt;/ul>
&lt;h4 id="326">3.26&lt;/h4>
&lt;h5 id="jz-19-正则表达式匹配-">JZ. 19 正则表达式匹配 ❌&lt;/h5>
&lt;p>自己的思路：考虑所有情况，硬配。写了一个多小时还是考虑不全所有情况，这是一种冗余分类的思路，还没有概括完所有情况。遂看题解，发现原来这也能DP。&lt;/p>
&lt;p>题解的思路：拆分子问题&lt;/p>
&lt;ul>
&lt;li>B 的最后一个字符为正常字符串， 比较 $A_{n-1}$ 和 $B_{m-1}$，如果相等则继续比较 $A_{0..n-2}$ 和 $B_{0..m-2}$，不相等则返回 false&lt;/li>
&lt;li>如果 B 的最后一个字符串为 &lt;code>.&lt;/code>，则比较 $A_{0..n-2}$ 和 $B_{0..m-2}$&lt;/li>
&lt;li>如果 B 的最后一个字符串为 &lt;code>*&lt;/code>，则 $B_{m-2} = c$ 可以重复0次或多次
&lt;ul>
&lt;li>case 1：$A_{n-1}$ 是0个c，舍弃 B 中的 &lt;code>c*&lt;/code>，比较 $A_{0..n-1}$ 和 $B_{0..m-3}$&lt;/li>
&lt;li>case 2：$A_{n-1}$ 是多个c中的最后一个，比较 $A_{0..n-2}$ 和 $B_{0..m-1}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>转移方程&lt;/strong>&lt;/p>
&lt;p>$f[i][j]$ 代表 A 的前 $i$ 个和 B 的前 $j$ 个能否匹配&lt;/p>
&lt;ul>
&lt;li>对于前两种情况可以进行合并，$f[i][j] = f[i-1][j-1]$
&lt;ul>
&lt;li>第三种情况，$f[i][j] = f[i][j-2]$，case 2: $f[i][j] = f[i-1][j]$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>初始条件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>空串和空正则可以匹配，$f[0][0] = true$&lt;/li>
&lt;li>空串和非空正则，需要判断&lt;/li>
&lt;li>非空串和空正则，不匹配，$f[1][0]&amp;hellip;f[n-1][0]=false$&lt;/li>
&lt;li>非空串和非空正则，需要判断&lt;/li>
&lt;/ul>
&lt;p>看题解后自己写：没有正确理解，不是倒着来的，本质上还是正常动态规划的求解过程。用的是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不需要双指针同步推进&lt;/p>
&lt;p>2022-03-27 10:22:03，有点绕，之后再来一遍，看懂了再自己写&lt;/p>
&lt;h5 id="jz-35-复杂链表的复制">JZ. 35 复杂链表的复制&lt;/h5>
&lt;p>自己的思路：先通过&lt;del>递归遍历原链表&lt;/del>，修改了一下，实际无需递归，直接遍历即可。此时 random 指针还没有赋值。第二次遍历复制链表，用 traver_cpoy 指针一一为每个节点找 random 指针应该指向的节点。怎么找？双指针一同遍历 init 链表和 copy 链表，当 init 链表到达当前节点的 random 后停止，copy 指针也跟着停止，此时 copy 指针的位置就是 traver_copy 指针节点的 random 节点。AC，时间复杂度 $O(n^2)$。&lt;/p>
&lt;p>更好的思路：hash map 映射，这个能够加深对于 hash 的应用上的理解。第一次遍历构造新节点时，以 hash 的形式存下 init 和 copy 对应节点的指针 &lt;code>map&amp;lt;*Node, *Node&amp;gt; hash_m&lt;/code>，第二次遍历构造 copy 链表的 random，init 指向 &lt;code>head-&amp;gt;random&lt;/code>，通过 &lt;code>head-&amp;gt;random&lt;/code> 以及 hash，可以查找到 copy random &lt;code>hash_m[head-&amp;gt;random]&lt;/code>，&lt;code>copy-&amp;gt;random = hash_m[head-&amp;gt;random]&lt;/code>。时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>注意复制链表需要新建节点，&lt;code>Node* tmp = new Node(val);&lt;/code>，不然指针连接到之前的链表上，就违背了复制的意图。&lt;/li>
&lt;li>原来这个就是&lt;strong>深拷贝&lt;/strong>的一个例子&lt;/li>
&lt;li>标签：hash，链表&lt;/li>
&lt;/ul>
&lt;h5 id="jz-36-二叉搜索树与双向链表">JZ. 36 二叉搜索树与双向链表&lt;/h5>
&lt;p>自己的思路：刚学的 hash 的思想似乎可以用上。中序遍历把节点的指针存入数组 &lt;code>vector&amp;lt;Node*&amp;gt; ans&lt;/code>，此时 ans 中的指针是有序的。遍历 ans 数组，重新调整节点 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code> 指针的指向即可。AC。&lt;/p>
&lt;p>和题解思路一致&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>栈，DFS，二叉树，双向链表&lt;/li>
&lt;li>主要是利用了 二叉搜索树 中序遍历后有序的性质&lt;/li>
&lt;/ul>
&lt;h5 id="jz37-序列化二叉树">JZ.37 序列化二叉树&lt;/h5>
&lt;p>序列化函数：也就是将二叉树以 string 的形式存起来。反序列化函数：将 string 构造为二叉树&lt;/p>
&lt;p>自己的思路：想到的还是 hash 的形式，把节点的指针存下来。得到了中序和前序遍历的序列，然后就是根据中序和前序遍历建树&lt;/p>
&lt;p>2022-03-31 22:13:41 的思路：有什么东西不重复呢？一开始想到了随机数，但是其实还有有风险，地址应该是不重复的。注意索引越界的问题&lt;/p>
&lt;p>建树：注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。忘了加参数 inorder_left 和 inorder_right&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>整型转字符串：&lt;code>itoa(int num, char* str, int radix)&lt;/code>&lt;/li>
&lt;li>字符串，&lt;code>char str = 'a'; str += 1&lt;/code>，可以直接加整型，此时 &lt;code>str = 'b';&lt;/code>&lt;/li>
&lt;li>map 如何通过 value 查找 key&lt;/li>
&lt;/ul>
&lt;h4 id="331">3.31&lt;/h4>
&lt;h5 id="728-自除数-每日一题">728. 自除数 每日一题&lt;/h5>
&lt;p>每日打卡，简单题，没什么亮点。&lt;/p>
&lt;h4 id="43">4.3&lt;/h4>
&lt;h5 id="每日一题">每日一题&lt;/h5>
&lt;h5 id="jz38-字符串的排序-">JZ.38 字符串的排序 ❌&lt;/h5>
&lt;p>自己的思路：双重循环，swap，set来去重。时间复杂度 $O(n^2)$。❌这种方法覆盖不了所有情况。20分钟没有思路&lt;/p>
&lt;p>题解的思路：递归回溯填空位的思想。递归回去时，使用过的字符串标记也会回溯。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>❗ 本以为把 visit 数组当做参数传进去，return 的时候自动回溯，没想到也需要手动回溯。&lt;/li>
&lt;li>突然想起来，要用引用传参。也不全是，只是突然想起来引用传参这个知识点。&lt;/li>
&lt;/ul>
&lt;h5 id="jz39-数组中出现次数超过一半的数字">JZ.39 数组中出现次数超过一半的数字&lt;/h5>
&lt;p>自己的思路：这个题之前应该是遇到过。最直接的方法就是遍历然后填充 hash 表，之后简单地判断，时间复杂度 $O(n)$，空间复杂度 $O(n)$。印象中有时间复杂度更低的解法，分治的思想之类的。想起来是排序之后找中间那个元素，&lt;del>时间复杂度 $O(logn)$&lt;/del>,oh，原来排序的时间复杂度是 $O(nlogn)$&lt;/p>
&lt;h5 id="jz40-最小的k个数-">JZ.40 最小的k个数 ❌&lt;/h5>
&lt;p>自己的思路：排序后遍历，这样做没有意义，直接看题解。&lt;/p>
&lt;p>题解：基于快排的特点。快排时每次都能把 pivot 放在他最终的位置。当结束一次快排，pivot 正好在 $index_k$ 时，返回数组的前 $k$ 个数即可。&lt;/p>
&lt;p>对快排特点的应用。&lt;/p>
&lt;p>❌ 忘记了快排的写法，这个题卡了1个小时的原因，在于你完全不会手写快排。如同上次蔚来面试答不出快排一样。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>看了题解之后还是折腾了1个小时；完全是因为快排写错了。&lt;/li>
&lt;/ul>
&lt;h4 id="44">4.4&lt;/h4>
&lt;h5 id="307-">307 ❌&lt;/h5>
&lt;p>线段树、树状数组踩坑，明天来学习&lt;/p>
&lt;p>自己的思路：用一个 hash，&lt;code>hash[i]&lt;/code> 存的是数组前 &lt;code>i+1&lt;/code> 个元素之和，查找时复杂度为 $O(1)$，update 时复杂度为 $O(n)$，这个级别的复杂度达不到要求，需要更好的方法。遂看题解。&lt;/p>
&lt;p>题解思路：分块处理，把时间复杂度优化到 $O(\sqrt{n})$；线段树，其实就是把一个完整的区间划分，左右子树分别是根节点的子区间。树节点保存的值为区间内的元素和，线段树看下图会很清晰。首先根据区间建树，用堆来存储更好。递归回退的时候计算每个节点的 val（也就是区间和），这个思路值得学习。&lt;/p>
&lt;p>2022-04-05 14:17:41，做得一团 bullshit，又浪费了一个小时，坑还是剩下，不要抄代码强行提交，先去写论文了。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector 还可以不使用 push，直接 index 吗？&lt;/li>
&lt;/ul>
&lt;h4 id="45">4.5&lt;/h4>
&lt;h5 id="762">762&lt;/h5>
&lt;p>自己的思路：判断质数函数一个，对于整数&lt;code>num&lt;/code>，从 2 遍历到 &lt;code>num/2&lt;/code>，没有整除就是质数，时间复杂度 $O(n)$；统计 bit 为1数量的函数，移位并计数，时间复杂度 $O（logn）$。AC&lt;/p>
&lt;h5 id="5-最长回文子串">5. 最长回文子串&lt;/h5>
&lt;p>经典DP&lt;/p>
&lt;p>自己的思路：秒不了，想不出DP，直接题解。&lt;/p>
&lt;p>题解：中心扩散法，这个比较好理解，主要是来学习DP。&lt;/p>
&lt;blockquote>
&lt;p>动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。&lt;/p>
&lt;/blockquote>
&lt;h5 id="每日-310-最小高度树">每日 310. 最小高度树&lt;/h5>
&lt;p>自己的思路：就是找一个节点，遍历所有节点的深度最小。建表之后dfs，写出了dfs解法，超时，需要优化。还是超时，遂先放弃。&lt;/p>
&lt;h4 id="415">4.15&lt;/h4>
&lt;h5 id="jz41-数据流中的中位数">JZ.41 数据流中的中位数&lt;/h5>
&lt;p>自己的思路：这道题的瓶颈在于排序，无论是插入时排序，还是找中位数时排序，如果每次 call 都进行一次排序，一定会超时。也许需要一颗平衡二叉排序树，把插入时排序的开销降低到 $O(logn)$。&lt;/p>
&lt;p>以为需要建堆，看题解之后AC。但是直接用的现成的优先队列，并且是看的题解，这道题几乎没有自己想的部分。&lt;/p>
&lt;p>题解：大顶堆，小顶堆。小顶堆 A 保存较大的一半数据（size = m），大顶堆 B 保存较小的一般数据（size = n）。插入时优先插入到 A，即：&lt;/p>
&lt;p>m = n，把新元素加到 A：把新元素 num 插入 B，再将 B 的堆顶插入 A。查找：返回 A 和 B 的堆顶之和 / 2&lt;/p>
&lt;p>m != n，把新元素加到 B：把新元素 num 插入 A，再将 A 的堆顶插入 B。返回 A 的堆顶&lt;/p>
&lt;p>为什么用优先队列实现大顶堆？什么事优先队列？优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;p>C++中的优先队列实现。不过要注意，直接用现成的轮子，建堆的过程其实还是不会的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Type, Container, Functional&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//升序队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>priority_queue &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,greater&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//降序队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>priority_queue &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,less&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span>q;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>堆（优先队列），数据流，排序，双指针&lt;/li>
&lt;/ul>
&lt;h5 id="jz42-连续子数组的最大和">JZ.42 连续子数组的最大和&lt;/h5>
&lt;p>自己的思路：经典的DP来了，练习DP的机会来了。这个似乎就是那位同学说的商汤2面的编程题。dp[i] 存放以 index i 为右边界的数组的最大和。&lt;/p>
&lt;p>2022-04-15 18:03:47，果然没有想出来，和我自己想的不太一样。写 dp 方程的时候没考虑到需要连续这一特性。要接受自己的愚蠢，看答案。&lt;/p>
&lt;p>思路绕进去了，一直在想 dp[i] 小于0不一定不能加；实际上自己想的是 nums[i] 小于0不一定不能加。而 dp[i] 如果小于0，说明以 i 为右边界的数组的连续子数组最大和为负数，故可以直接舍弃。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，分治，DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz43-1n-整数中-1-出现的次数">JZ.43 1～n 整数中 1 出现的次数&lt;/h5>
&lt;p>自己的思路：首先尝试暴力的方法，遍历，把int转为char，统计1的数量。itoa 还是用不了，找到了替代，sprintf。暴力法必然超时，打表应该是通过的方法之一，这样需要预处理。没有使用打表的方式，以10000为步长来计算。一次AC，nice（2022-04-15 20:44:01），虽然这道题可能算不上困难。&lt;/p>
&lt;ul>
&lt;li>递归，数学规律，DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz44-数字序列中某一位的数字-">JZ.44 数字序列中某一位的数字 ❌&lt;/h5>
&lt;p>自己的思路：实际上就是构造这个序列化字符串。这个字符串长度大于n时跳出即可。承接上一题，还是继续使用 sprintf。atoi 格式忘记了。&lt;/p>
&lt;p>2022-04-16 19:50:05，先放一放，往后做&lt;/p>
&lt;h4 id="416">4.16&lt;/h4>
&lt;h5 id="jz45-把数组排成最小的数-">JZ.45 把数组排成最小的数 ❌&lt;/h5>
&lt;p>自己的思路：排序后遍历，因为数字都是100以内，先拼接小的即可，拼接22之前先拼接2，拼接33之前先拼接3。晕，看错条件了，说的是 nums 长度小于 100。&lt;/p>
&lt;p>没有A，看题解了。这道题也是有一些数学的规律，自定义字符串的排序规则。字符串排序规则，若 $x + y &amp;gt; y + x$，说明 y 应该放在左边。&lt;/p>
&lt;p>除了 sprinft，还可以用 to_string(INT);&lt;/p>
&lt;h4 id="417">4.17&lt;/h4>
&lt;h5 id="jz46-数字翻译成字符串">JZ.46 数字翻译成字符串&lt;/h5>
&lt;p>自己的思路：感觉是一个标准的 DP 问题。判断两数是否能组合时，要注意一些边界条件上的细节。时间复杂度 $O(n)$。实际上就是青蛙跳台阶的思路。&lt;/p>
&lt;p>2022-04-17 22:10:46，成功AC。这个是刷 LeetCode DP 问题的一个里程碑。标志着你也许能够独立做出一些 DP 问题了。&lt;/p>
&lt;p>初始状态：以 0 结尾的字符串，有1种翻译&lt;/p>
&lt;p>状态：以 i 结尾的字符串，有多少种翻译；~$dp[i] = dp[i-1] + 1（单加一个） + if_combined$~ （i 和 i - 1 是否能够组合在一起）。
应该没有这个 +1，并非叠加，$dp[i] = dp[i-1] + if_combined$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>个人认为关于 DP，有个很关键的地方是，从初始态出发必须能够到达当前状态，他们是有桥梁的，因为每一步都伴随着信息的更新。&lt;/li>
&lt;/ul>
&lt;h5 id="jz47-礼物的最大价值">JZ.47 礼物的最大价值&lt;/h5>
&lt;p>自己的思路：感觉是一个和棋盘/二维数组相关的 DP 问题。边界问题补一层 padding，因为 value 非负，直接初始化为0即可。AC，比较简单的 DP 问题。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，DP，矩阵&lt;/li>
&lt;/ul>
&lt;h5 id="jz48-最长不含重复字符的子字符串">JZ.48 最长不含重复字符的子字符串&lt;/h5>
&lt;p>自己的思路：最自然的是暴力法，遍历字符串，往后找其第一个重复的串，记录长度，时间复杂度 $O(n^2$。第一个思路有问题，这个思路不太行。明天来做，2022-04-17 23:39:50。&lt;/p>
&lt;p>2022-04-18 11:51:19，AC，做了比较久，做了接近一个小时。总算绕通了其中的逻辑。自己用的应该是双指针遍历的方法，用 hash_map 存出现过的字符串，遇到重复时更新左边的指针，以及舍弃掉此重复字符串左边的字符串。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：滑动窗口，字符串，hash&lt;/li>
&lt;/ul>
&lt;h5 id="每日一题-819-最常见的单词">每日一题 819. 最常见的单词&lt;/h5>
&lt;p>自己的思路：没什么思路，直接遍历，hash 表存出现的次数，大写转小写。我记得是有大小写转换的函数的，不过忘记了，手动转一下吧。ASCII 差值搞忘了，好像是32？可以建个表。确实是32，还算记得，不用建表了。AC，逻辑有点不清晰，花了大概30分钟。20年4月做过这道题。&lt;/p>
&lt;h4 id="418">4.18&lt;/h4>
&lt;h5 id="每日一题-386-lexicographical-numbers-">每日一题 386. Lexicographical Numbers ❌&lt;/h5>
&lt;p>自己的思路：要求时间复杂度 $O(n)$，也就是一次遍历。n &amp;lt; 10 时直接返回 1-n，否则标记 1-9，后续遇到 1 开头的数就插入到 1 后面，然后标记，遇到 2 开头的数就插入到 2 后面，然后标记。不过 vector 插入的时间复杂度好像是 $O(n)$，这样的话整体就是 $O(n^2)$ 了。&lt;/p>
&lt;p>15分钟没有思路，上题解。看了一部分评论之后有一个思路，应该将其转换为字符串，这样就无需考虑整数的顺序问题。&lt;/p>
&lt;p>题解：迭代 DFS 的思想。对于数 number，加入数组，判断 $10*number \leq n$ 是否成立，如果成立则加入数组，并继续搜索（DFS）；如果不成立，判断 $number + 1$ 的情况，如果 number 的个位数为9（number 个位数1-9已经全部搜索过了）或者 number + 1 &amp;gt; n（DFS返回条件），则回退到上一层（number /= 10）&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;p>标签：DFS，前缀树&lt;/p>
&lt;h5 id="jz49-丑数-">JZ.49 丑数 ❌&lt;/h5>
&lt;p>自己的思路：已知是一道DP。看题解&lt;/p>
&lt;p>题解：核心思想是后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。在这个基础上可以使用最小堆，每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x2x,3x,5x 也是丑数，因此将 2x, 3x, 5x2x,3x,5x 加入堆，然后去重。&lt;/p>
&lt;p>方法二：DP 三指针。令 $\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)$，被使用到的对应指针++。&lt;/p>
&lt;p>&lt;code>dp[i] = min(min(n2, n3), n5);&lt;/code> 学到了&lt;/p>
&lt;h4 id="419">4.19&lt;/h4>
&lt;h5 id="每日一题-821字符的最短距离">每日一题 821.字符的最短距离&lt;/h5>
&lt;p>自己的思路：第一次遍历记录字符的所有下标，第二次遍历找出当前字符 - 下标集合的最小值。时间复杂度最坏 $O(n^2)$。AC&lt;/p>
&lt;p>更好的思路：两次遍历。从左往右，一边遍历一遍更新字符idx；从右往左再来一次。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>int ans[] = new int(len);&lt;/code> 写法有问题，注意是：&lt;code>int *ans = new int[len]{0};&lt;/code>，一定是指针形式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vector 初始化：&lt;code>vector&amp;lt;int&amp;gt; ans(len);&lt;/code> 以及 &lt;code>vector&amp;lt;int&amp;gt; ans; ans.resize(len);&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz50-第一个只出现一次的字符">JZ.50 第一个只出现一次的字符&lt;/h5>
&lt;p>自己的思路：hash，两次遍历。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这道题有一个比较好奇的地方，map 中元素顺序是否是按加入的顺序；噢，map 似乎是自动排序的，根据 first 排序&lt;/li>
&lt;/ul>
&lt;h5 id="jz51--数组中的逆序对-">JZ.51 数组中的逆序对 ❌&lt;/h5>
&lt;p>自己的思路：这是一个 hard 题，最自然的想法是暴力法，$o(n^2)$，很自然地，超时。换一种思路，DP，dp[i] 代表位置 i 之前有 dp[i] 个大于 nums[i] 的数。看题解&lt;/p>
&lt;p>题解：归并排序和逆序对息息相关，归并排序体现了分治的思想。归并的同时顺便统计信息。&lt;/p>
&lt;p>PS：着题解代码写得&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二分查找，归并排序，分治，树状数组，线段树&lt;/li>
&lt;/ul>
&lt;h5 id="jz50-两个链表的第一个公共节点">JZ.50 两个链表的第一个公共节点&lt;/h5>
&lt;p>自己的思路：题目要求尽量用时间复杂度 $O(n)$，空间复杂度 $O(1)$，&lt;/p></description></item><item><title>tmux: Linux 下终端复用</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</link><pubDate>Wed, 16 Mar 2022 08:56:32 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</guid><description>&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>个人理解：最重要的思想感觉是将 session 和终端分离，这样的话退出终端时不会中断 session 以及里面的任务，session 还是在后台运行。最重要的是，下次进入终端时可以连接 session，使得可以还原上一次退出时的状态，且后台任务不会中断。&lt;/p>
&lt;p>前缀键：Ctrl + B，用&lt;code>&amp;lt;prefix&amp;gt;&lt;/code>表示。比如&lt;code>&amp;lt;prefix&amp;gt; %&lt;/code>表示先按&lt;code>Ctrl&lt;/code>，再按&lt;code>B&lt;/code>键，再&lt;code>%&lt;/code>键，其完成的功能就是竖直分屏。&lt;/p>
&lt;h3 id="01-安装启动退出">0.1 安装、启动、退出&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ sudo apt-get install tmux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux &lt;span style="color:#75715e">#进入 Tmux 窗口，底部状态栏左侧是窗口信息（编号和名称），右侧是系统信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$exit &lt;span style="color:#75715e">#或者 ctrl + d，退出&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="1-基本概念">1. 基本概念&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;h3 id="11-session">1.1 Session&lt;/h3>
&lt;p>会话(session): 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话&lt;/p>
&lt;p>Session 一大特点：打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也随之结束&lt;/p>
&lt;p>基于这个 Motivation，为了解决这种关闭窗口工作丢失的问题，会话和窗口可以解绑。窗口关闭时，会话并不会终止，而是继续运行，有需要的时候（理解为需要交互的时候）再让会话绑定其他窗口。&lt;/p>
&lt;p>窗口(window): 容纳多个窗格&lt;/p>
&lt;p>窗格(pane): 可以在窗口中分成多个窗格&lt;/p>
&lt;h3 id="12-tmux">1.2 Tmux&lt;/h3>
&lt;p>Tmux 就是让会话与窗口解绑的工具&lt;/p>
&lt;ul>
&lt;li>可以在单个窗口中同时访问多个会话。对于同时运行多个命令行程序很有用&lt;/li>
&lt;li>可以让新窗口 接入 已存在的会话&lt;/li>
&lt;li>允许每个会话有多个连接窗口，可以多人实时共享会话&lt;/li>
&lt;li>支持窗口任意的垂直和水平拆分&lt;/li>
&lt;/ul>
&lt;h2 id="1-session">1. Session&lt;/h2>
&lt;h3 id="11-new">1.1 new&lt;/h3>
&lt;p>第一个启动的 Tmux 窗口，编号是&lt;code>0&lt;/code>，第二个窗口的编号是&lt;code>1&lt;/code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。&lt;/p>
&lt;blockquote>
&lt;p>这里指的是不同会话的窗口？&lt;/p>
&lt;/blockquote>
&lt;p>使用编号区分会话，不太直观，更好的方法是为会话起名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>$ tmux new -s &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令新建一个指定名称的会话。&lt;/p>
&lt;h3 id="12-detach">1.2 Detach&lt;/h3>
&lt;p>在 Tmux 窗口中，按下&lt;code>&amp;lt;prefix&amp;gt; d&lt;/code>或者输入&lt;code>tmux detach&lt;/code>命令，就会将当前会话与窗口分离。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ tmux detach
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。&lt;/p>
&lt;h3 id="13-查看会话">1.3 查看会话&lt;/h3>
&lt;p>&lt;code>tmux ls&lt;/code>命令可以查看当前所有的 Tmux 会话。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ tmux ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># or&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux list-session
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="14-attach-kill-switch">1.4 Attach, Kill, Switch&lt;/h3>
&lt;p>&lt;code>tmux attach&lt;/code>命令用于重新接入某个已存在的会话。&lt;/p>
&lt;p>&lt;code>tmux kill-session&lt;/code>命令用于杀死某个会话。&lt;/p>
&lt;p>&lt;code>tmux switch&lt;/code>命令用于切换会话。&lt;/p>
&lt;p>&lt;code>tmux rename-session&lt;/code>命令用于重命名会话。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用会话编号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux attach -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux kill-session -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux switch -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用会话名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux attach -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux kill-session -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux switch -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#重命名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux rename-session -t &lt;span style="color:#ae81ff">0&lt;/span> &amp;lt;new-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-快捷键">2. 快捷键&lt;/h2>
&lt;h3 id="21-session">2.1 Session&lt;/h3>
&lt;p>下面是一些会话相关的快捷键。&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; d&lt;/code>：分离当前会话。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; s&lt;/code>：列出所有会话。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; $&lt;/code>：重命名当前会话。&lt;/li>
&lt;/ul>
&lt;h3 id="22-window">2.2 Window&lt;/h3>
&lt;ul>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; c&lt;/code>：创建一个新窗口，&lt;a href="https://www.zhihu.com/search?q=%E7%8A%B6%E6%80%81%E6%A0%8F&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A261206348%7D">状态栏&lt;/a>会显示多个窗口的信息。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; p&lt;/code>：切换到上一个窗口（按照状态栏上的顺序）。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; n&lt;/code>：切换到下一个窗口。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt;&lt;/code>：切换到指定编号的窗口，其中的``是状态栏上的&lt;a href="https://www.zhihu.com/search?q=%E7%AA%97%E5%8F%A3%E7%BC%96%E5%8F%B7&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A261206348%7D">窗口编号&lt;/a>。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; w&lt;/code>：从列表中选择窗口。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; ,&lt;/code>：窗口重命名。&lt;/li>
&lt;/ul>
&lt;h2 id="3-常用">3. 常用&lt;/h2>
&lt;h3 id="31-翻屏">3.1 翻屏&lt;/h3>
&lt;ul>
&lt;li>进入tmux翻屏模式:先按&lt;code>ctrl ＋ｂ&lt;/code>，松开，然后再按&lt;code>[&lt;/code>&lt;/li>
&lt;li>操作同vim：jkhl上下左右&lt;/li>
&lt;/ul>
&lt;h3 id="32-最简操作">3.2 最简操作&lt;/h3>
&lt;ol>
&lt;li>新建会话&lt;code>tmux new -s my_session&lt;/code>。&lt;/li>
&lt;li>在 Tmux 窗口运行所需的程序。&lt;/li>
&lt;li>按下快捷键 d 将会话分离。&lt;/li>
&lt;li>下次使用时，重新连接到会话&lt;code>tmux attach -t my_session&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="4-设置">4. 设置&lt;/h2>
&lt;h3 id="41-启用鼠标滚轮">4.1 启用鼠标滚轮&lt;/h3>
&lt;p>Ctrl + b，然后输入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ setw mode-mouse on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/261206348">https://zhuanlan.zhihu.com/p/261206348&lt;/a>&lt;/p></description></item><item><title>Vim 中常用的操作</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Wed, 16 Mar 2022 08:54:13 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>&lt;p>&lt;strong>Vim 中常用的操作&lt;/strong>&lt;/p>
&lt;p>复制、删除中，定位的逻辑都是对应的，找最后一行 G，找第一行 1G，找行首 0，找行尾 $&lt;/p>
&lt;h4 id="复制粘贴">复制/粘贴&lt;/h4>
&lt;p>复制&lt;strong>当前行&lt;/strong>之后的内容，&lt;code>yG&lt;/code>&lt;/p>
&lt;p>复制第一行到当前行，&lt;code>y1G&lt;/code>&lt;/p>
&lt;p>复制当前行，&lt;code>dd&lt;/code>；向下复制 10 行，&lt;code>10dd&lt;/code>&lt;/p>
&lt;p>复制游标到行首/行尾，&lt;code>y0&lt;/code>/&lt;code>y$&lt;/code>&lt;/p>
&lt;p>粘贴在光标下/上一行，&lt;code>p&lt;/code>/&lt;code>P&lt;/code>&lt;/p>
&lt;h4 id="删除">删除&lt;/h4>
&lt;p>删除&lt;strong>当前行&lt;/strong>之后的内容&lt;/p>
&lt;ul>
&lt;li>光标定位到某行，&lt;code>:,$d&lt;/code>，&lt;code>dG&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>删除第一行到当前行&lt;/p>
&lt;ul>
&lt;li>&lt;code>1,.d&lt;/code>，&lt;code>d1G&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>删除当前行，&lt;code>dd&lt;/code>；向下删除 10 行，&lt;code>10dd&lt;/code>&lt;/p>
&lt;p>向后/向前删除 10 个字符，&lt;code>10x&lt;/code>/&lt;code>10X&lt;/code>&lt;/p>
&lt;p>删除游标到行首/行尾，&lt;code>d0&lt;/code>/&lt;code>d$&lt;/code>&lt;/p>
&lt;p>恢复上一个动作（类似 Ctrl + Z）,&lt;code>u&lt;/code>&lt;/p>
&lt;p>重做上一个动作（往前恢复），&lt;code>ctrl + r&lt;/code>&lt;/p>
&lt;p>重复上一个动作（再做一次），&lt;code>.&lt;/code>&lt;/p>
&lt;h4 id="跳转移动">跳转/移动&lt;/h4>
&lt;p>跳转到指定&lt;strong>第x行&lt;/strong>，&lt;code>:x&lt;/code>&lt;/p>
&lt;p>跳转到文件最后一行，&lt;code>shift + g&lt;/code>、&lt;code>G&lt;/code>、&lt;code>:$&lt;/code>&lt;/p>
&lt;p>跳转到文件第一行，&lt;code>gg&lt;/code>&lt;/p>
&lt;p>跳转到下一页，&lt;code>ctrl + f (forward)&lt;/code>&lt;/p>
&lt;p>跳转到上一页，&lt;code>ctrl + b (back)&lt;/code>&lt;/p>
&lt;p>向下移动 30 行，&lt;code>30j&lt;/code>，&lt;code>30 &amp;lt;Enter&amp;gt;&lt;/code>&lt;/p>
&lt;p>向右移动 20 个字符，&lt;code>20 &amp;lt;space&amp;gt;&lt;/code>，&lt;!-- raw HTML omitted --> 为空格&lt;/p>
&lt;p>⭐ 移动到当前行首/尾，&lt;code>0 or [home]&lt;/code>/&lt;code>$ or [End]&lt;/code>&lt;/p>
&lt;h4 id="搜索">搜索&lt;/h4>
&lt;p>查找 &lt;code>/&lt;/code>&lt;/p>
&lt;p>统计字符串数量，&lt;code>:%s/GTO://gn&lt;/code>&lt;/p></description></item><item><title>编译运行ISPASS2009、Rodinia、Parboil</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</link><pubDate>Wed, 08 Dec 2021 09:45:02 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</guid><description>&lt;h1 id="ispass">ISPASS&lt;/h1>
&lt;p>Ubuntu20.04下使用GPGPU-Sim运行ISPASS2009benchmark&lt;/p>
&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>之前介绍了安装，现在就尝试跑一下 ISPASS'09 的那篇经典 paper，Analyzing CUDA workloads using a detailed GPU simulator 上的几个 benchamrk. 这篇文章1.现在已经870次引用了，很多工作都使用了其中的 benchmark&lt;/p>
&lt;h2 id="1-安装-cuda-toolkit-and-cuda-sdk">1. 安装 CUDA Toolkit and CUDA SDK&lt;/h2>
&lt;p>CUDA 5之后，SDK 和 Toolkit 都在一个包里面，可以参考 XX 中安装 CUDA 的步骤，在安装时除了 Toolkit 以外再勾选上 &lt;code>CUDA Samples 11.1&lt;/code>。ISPASS'09 benchmark 会用到 build CUDA SDK 时创建的库，所以需要 CUDA SDK。&lt;/p>
&lt;blockquote>
&lt;p>But, it looks like NVIDIA has messed up the webpages a bit, the CUDA Toolkit and the GPU Computing SDK pages point at each other, with neither offering the SDK.&lt;/p>
&lt;/blockquote>
&lt;p>所以看起来是需要切换 CUDA 版本&lt;/p>
&lt;h3 id="11-更换软链接">1.1 更换软链接&lt;/h3>
&lt;p>不过之前环境变量用的 cuda11.1 的地址而非软链接，现在替换成软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /usr/local/cuda &lt;span style="color:#75715e">#删除之前生成的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda &lt;span style="color:#75715e">#生成新的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-check-环境变量的地址">1.2 Check 环境变量的地址&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export CUDA_INSTALL_PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/cuda/toolkit/4.2/cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$CUDA_INSTALL_PATH/bin:$MPI_ROOT/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LD_LIBRARY_PATH&lt;span style="color:#f92672">=&lt;/span>$LD_LIBRARY_PATH:$CUDA_INSTALL_PATH/lib64 &lt;span style="color:#75715e">#这个不用改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export NVIDIA_COMPUTE_SDK_LOCATION&lt;span style="color:#f92672">=&lt;/span>~/cuda/sdk/4.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-查看版本信息">1.3 查看版本信息&lt;/h3>
&lt;p>上述步骤全部没问题就可以弹出版本信息了，&lt;code>source ~/.bashrc&lt;/code> 或者重启终端&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nvcc: NVIDIA &lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Cuda compiler driver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Copyright &lt;span style="color:#f92672">(&lt;/span>c&lt;span style="color:#f92672">)&lt;/span> 2005-2012 NVIDIA Corporation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built on Thu_Apr__5_00:24:31_PDT_2012
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cuda compilation tools, release 4.2, V0.2.1221
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-gcc-g-版本">2. gcc, g++ 版本&lt;/h2>
&lt;p>CUDA 更换为4.2版本后，重新 build 模拟器得知 &lt;code>unsupported GNU version! gcc 4.7 and up are not supported!&lt;/code>。之前在别人的博客也看到需要 4.7 以下版本 gcc，不过当时在 cuda11.1 版本下是可以用 gcc 4.8/5 跑模拟器的。现在需要跑一下 ISPASS'09 benchmark, 所以配置到符合要求的版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#39;deb http://archive.ubuntu.com/ubuntu/ trusty main&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#39;deb http://archive.ubuntu.com/ubuntu/ trusty universe&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install gcc-4.4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 50 &lt;span style="color:#75715e">#设置优先级&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.4 50 &lt;span style="color:#75715e">#设置优先级&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --config gcc &lt;span style="color:#75715e">#输入编号选择gcc/g++版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --config g++ &lt;span style="color:#75715e">#输入编号选择gcc/g++版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gcc -v &lt;span style="color:#75715e">#Check 版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>g++ -v &lt;span style="color:#75715e">#Check 版本&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更换版本后不支持原子操作？编译代码时加上选项 &lt;code>-arch sm_20&lt;/code>&lt;/p>
&lt;h2 id="2-compile-nvidia-sdk-42">2. Compile Nvidia SDK 4.2&lt;/h2>
&lt;ul>
&lt;li>&lt;code>sudo apt-get install libboost-dev libboost-system-dev libboost-filesystem-dev libboost-all-dev mpich2 binutils-gold libcuda1-304&lt;/code>&lt;/li>
&lt;li>&lt;code>sudo gedit ~/cuda/sdk/4.2/C/common/common.mk&lt;/code>, line like “&lt;code>LIB += … ${OPENGLLIB} …. $(RENDERCHECKGLLIB) …&lt;/code>” should have &lt;code>$(RENDERCHECKGLLIB)&lt;/code> moved before &lt;code>${OPENGLLIB}&lt;/code>. There should be 3 lines like this, it may be line 271, 275 and 282.
&lt;ul>
&lt;li>将 line26 &lt;code>CUDA_INSTALL_PATH ?= /home/gpgpu-sim/cuda/toolkit/4.2/cuda&lt;/code> 修改为 &lt;code>CUDA_INSTALL_PATH ?= /home/huweim/cuda/toolkit/4.2/cuda&lt;/code>
&lt;ul>
&lt;li>这一步应该不用了，用软链接代替路径即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>因为这个文件直接拷贝过来的，所以要设置为自己的安装路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>sudo gedit ~/cuda/sdk/4.2/CUDALibraries/common/common_cudalib.mk&lt;/code> and do the same thing.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;code>cd ~/cuda/sdk/4.2&lt;/code>&lt;/li>
&lt;li>Edit Makefile through &lt;code>sudo gedit ./Makefile&lt;/code>. Comment all lines with &lt;code>CUDALibraries&lt;/code> and &lt;code>OpenCL&lt;/code> as we only want the application binaries. You comment by placing &lt;code>#&lt;/code> in the front of the line.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;code>make&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="21-bug">2.1 Bug&lt;/h3>
&lt;p>遇到 bug&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lcudart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lcufft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lXi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lXmu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lglut
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="212-解决">2.1.2 解决&lt;/h4>
&lt;p>建立 cudart 的软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda/lib64/libcudart.so.4.2.9 /usr/lib/libcudart.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda/lib64/libcufft.so.4.2.9 /usr/lib/libcufft.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#下面几个没有太大必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libculas.so.4.2.9 /usr/lib/libculas.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcuspare.so.4.2.9 /usr/lib/libcufspare.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcuinj.so.4.2.9 /usr/lib/libcuinj.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcurand.so.4.2.9 /usr/lib/libcurand.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libnpp.so.4.2.9 /usr/lib/libnpp.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo rm /usr/lib/libculas.so
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt-get install libxi-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install libxmu-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install freeglut3-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-ispass2009-benchmarks">4. ISPASS2009 Benchmarks&lt;/h2>
&lt;ul>
&lt;li>&lt;code>git clone https://github.com/gpgpu-sim/ispass2009-benchmarks.git&lt;/code>, we also upload it to the pan.shanghaitech.&lt;/li>
&lt;li>&lt;code>sudo gedit ~/.bashrc&lt;/code>, add &lt;code>export NVIDIA_COMPUTE_SDK_LOCATION=~/cuda/sdk/4.2&lt;/code>&lt;/li>
&lt;li>&lt;code>cd ispass2009-benchmarks&lt;/code>&lt;/li>
&lt;li>&lt;code>sudo gedit ./Makefile.ispass-2009&lt;/code>
&lt;ul>
&lt;li>comment out line 16 and 28. The AES and WP benchmark does not compiler readily.
&lt;ul>
&lt;li>❗ Note not line 16 to 28, only this two lines&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Change &lt;code>BOOST_LIB&lt;/code> to the following path: &lt;code>/usr/lib/x86_64-linux-gnu/&lt;/code>&lt;/li>
&lt;li>Change &lt;code>BOOST_ROOT&lt;/code> to the following path: &lt;code>/usr/include/boost/&lt;/code>&lt;/li>
&lt;li>Change &lt;code>OPENMPI_BINDIR&lt;/code> to the following path: &lt;code>/usr/bin/&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>sudo gedit ./DG/Makefile&lt;/code>
&lt;ul>
&lt;li>Line 54, change &lt;code>-I/opt/mpich/include&lt;/code> to &lt;code>-I/usr/include/mpich&lt;/code>&lt;/li>
&lt;li>Line 56, append &lt;code>-I/usr/include/mpich&lt;/code> to end of the line&lt;/li>
&lt;li>Line 59-61, add &lt;code>.mpich2&lt;/code> to the end of each line. For example, &lt;code>NEWCC = $(OPENMPI_BINDIR)mpicc.mpich2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>make -f Makefile.ispass-2009&lt;/code>. Note: If you do a &lt;code>make -f Makefile.ispass-2009 clean&lt;/code>, you may have to recompile the SDK.&lt;/li>
&lt;/ul>
&lt;h3 id="41-dg">4.1 DG&lt;/h3>
&lt;p>需要 openmpi 的环境&lt;/p>
&lt;p>Ubuntu20.04下使用GPGPU-Sim运行 Rodinia&lt;/p>
&lt;h1 id="rodinia">Rodinia&lt;/h1>
&lt;h2 id="0-前言-1">0. 前言&lt;/h2>
&lt;p>Rodinia 的类型还是更多，尝试将其编译好&lt;/p>
&lt;h2 id="1-修改路径">1. 修改路径&lt;/h2>
&lt;p>修改 &lt;code>gpu-rodinia-master/common/make.config&lt;/code> 中 CUDA_INSTALL_PATH，CUDA_LIB_DIR，SDK_DIR 为 your own path&lt;/p>
&lt;p>&lt;del>对我来说只用修改 SDK_DIR&lt;/del>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>CUDA_LIB_DIR :&lt;span style="color:#f92672">=&lt;/span> /home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-4020/release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CUDA_LIB_DIR :&lt;span style="color:#f92672">=&lt;/span> /home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-11020/release &lt;span style="color:#75715e">#如果要修改版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SDK_DIR &lt;span style="color:#f92672">=&lt;/span> /home/huweim/cuda/sdk/4.2/C
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="11-sim_v40">1.1 sim_v4.0&lt;/h3>
&lt;p>如果使用 v4.0 版本的模拟器，&lt;del>需要在编译选项中加上 &lt;code>--cudart shared&lt;/code>&lt;/del>，编译选项是针对 nvcc，我们尝试使用 gcc 4.5, nvcc 4.2 来运行，官方文档中说 gpgpu-sim v4.0 是支持 nvcc 4.2 的。&lt;/p>
&lt;p>在 common.mk 中添加对应的架构版本 &lt;code>SM_VERSION := sm_10 sm_11 sm_12 sm_13 sm_20&lt;/code>&lt;/p>
&lt;h2 id="2-data-set">2. Data Set&lt;/h2>
&lt;p>惊喜地发现 data set 是空的，download from &lt;a href="http://lava.cs.virginia.edu/Rodinia/download_links.htm">http://lava.cs.virginia.edu/Rodinia/download_links.htm&lt;/a>&lt;/p>
&lt;p>好家伙一个 G Data Set&lt;/p>
&lt;h2 id="3-进入-cuda-文件夹逐一编译即可">3. 进入 cuda 文件夹逐一编译即可&lt;/h2>
&lt;h3 id="30-找不到--lcuda-大多数文件">3.0 找不到 -lcuda 大多数文件&lt;/h3>
&lt;p>原因就是没找到动态链接库，guess 因为我们没有安装驱动 ✔️&lt;/p>
&lt;p>&lt;del>make.config 中 &lt;code>CUDA_LIB_DIR&lt;/code> 改为 libcudart.so 所在的路径&lt;/del>，需要的是 libcuda.so 而不是 libcudart.so&lt;/p>
&lt;p>❌ &lt;del>去&lt;a href="https://developer.nvidia.com/cuda-toolkit-42-archive">官网&lt;/a>下载驱动&lt;/del>，电脑没有 NVIDIA GPU 无法安装 Driver&lt;/p>
&lt;p>✔️ 去掉 -lcuda 编译选项，出现 &lt;code>undefined reference to symbol '__gxx_personality_v0@@CXXABI_1.3'&lt;/code> 错误时，把 &lt;code>CC = gcc&lt;/code> 更改为 &lt;code>CC = g++&lt;/code>，或者添加编译选项 &lt;code>-lstdc++&lt;/code>&lt;/p>
&lt;p>暂不清楚去掉 -lcuda 编译选项后的影响&lt;/p>
&lt;h3 id="31-kmeans-leukocyte">3.1 kmeans, leukocyte&lt;/h3>
&lt;p>&lt;strong>BUG&lt;/strong>：提示缺少 .o&lt;/p>
&lt;p>&lt;strong>Solution&lt;/strong>：Makefile 这个 [ch] 会读到 .h，从而编译不出 kmeans.o，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">%.o&lt;/span>&lt;span style="color:#f92672">:&lt;/span> %.[ch]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">$(&lt;/span>CC&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>CC_FLAGS&lt;span style="color:#66d9ef">)&lt;/span> $&amp;lt; -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#改成后正确编译
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">%.o&lt;/span>&lt;span style="color:#f92672">:&lt;/span> %.[c]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">$(&lt;/span>CC&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>CC_FLAGS&lt;span style="color:#66d9ef">)&lt;/span> $&amp;lt; -c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kmeans： &lt;code>libgomp.so.1 =&amp;gt; not found&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ apt-get install libgomp1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="32-huffman-srad">3.2 huffman, srad&lt;/h3>
&lt;p>架构版本改成 &lt;code>-arch=sm_20&lt;/code>&lt;/p>
&lt;h3 id="33-hotspot3d">3.3 hotspot3D&lt;/h3>
&lt;p>include 路径改一下&lt;/p>
&lt;h3 id="34-hybridsort">3.4 hybridsort&lt;/h3>
&lt;p>bucketsort.cu:10: fatal error: GL/glew.h: No such file or directory&lt;/p>
&lt;p>看起来是没有 OpenGL&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ sudo apt-get install libglew-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-run">4. Run&lt;/h2>
&lt;h3 id="41-why-these-benchmark-so-slow">4.1 Why these benchmark so slow?&lt;/h3>
&lt;p>streamcluster, leu, fdtd2d 等等&lt;/p>
&lt;p>Rodinia 大多数 benchmark 都跑得很慢，有的在服务器上两三天都没跑完，不知道是数据量太大还是编译过程除了问题？尽管 GPGPU-Sim 可以自行在达到一定的 cycle 数时停止，还是想知道为什么 Rodinia 如此之慢。&lt;/p>
&lt;h1 id="parbiol">Parbiol&lt;/h1>
&lt;h2 id="0-前言-2">0. 前言&lt;/h2>
&lt;p>Ubuntu20.04 下使用 GPGPU-Sim 编译运行 Parboil&lt;/p>
&lt;h2 id="1-下载和修改文件">1. 下载和修改文件&lt;/h2>
&lt;h3 id="11-下载">1.1 下载&lt;/h3>
&lt;p>最好在&lt;a href="http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx">官网&lt;/a>下载后部署，Github 上的文件多了几个 benchmark，但是没有他们的数据集。&lt;/p>
&lt;p>在官网下载好需要的目录，按照 README 中的要求部署，&lt;code>Parboil&lt;/code> 中需要有 4 个目录，&lt;code>benchmarks&lt;/code>，&lt;code>common&lt;/code>，&lt;code>driver&lt;/code>，&lt;code>datasets&lt;/code>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="12-makefileconf">1.2 Makefile.conf&lt;/h3>
&lt;p>进入 common 目录，里面有对应设备的一些 Makefile examples。主要使用的是cuda，check 文件 Makefile.conf.example-nvidia 中的 CUDA 路径，&lt;strong>复制&lt;/strong>并改名为 Makefile.conf。&lt;/p>
&lt;h3 id="13-cuda_lib_path">1.3 CUDA_LIB_PATH&lt;/h3>
&lt;p>修改为 gpgpu-sim 的中的 libcudart.so 路径即可&lt;/p>
&lt;p>&lt;code>CUDA_LIB_PATH=/home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-4020/release/&lt;/code>&lt;/p>
&lt;h2 id="2-data-set-1">2. Data Set&lt;/h2>
&lt;p>download from &lt;a href="http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx">http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx&lt;/a>，在 1.1 的步骤中应该已经下载了，但是在 Github 中不带 data set，如果 data set 不全，使用他的脚本编译可能会报错，所以建议在官网下载。&lt;/p>
&lt;p>包含 11 个 benchmark data set&lt;/p>
&lt;h2 id="3-compile">3. Compile&lt;/h2>
&lt;h3 id="31-bug">3.1 Bug&lt;/h3>
&lt;p>这里就是之前说的 BUG，所以东西都去官网下载就不会有这些 BUG 了。&lt;/p>
&lt;h4 id="311-dataset-不全">3.1.1 Dataset 不全&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;p>16 benchmark src，但是 dataset 只有11个&lt;/p>
&lt;p>✔️ 解决方法，直接去官方网站下载，不在 github 上下载，11 benchmark 对应 11 dataset&lt;/p>
&lt;h4 id="312-gcc">3.1.2 gcc&lt;/h4>
&lt;p>&lt;code>error: identifier &amp;quot;__builtin_ia32_vec_set_v8hi&amp;quot; is undefined&lt;/code>，网上也没有搜索到。
尝试切换一下 gcc 版本，发现只能用 gcc 4.7 及以前的版本。&lt;/p>
&lt;p>✔️ 解决方法，直接去官方网站下载，不在 github 上下载，11 benchmark 对应 11 dataset。这个时候 compile 也没有错误了。&lt;/p>
&lt;h3 id="32-compile-命令">3.2 Compile 命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./parboil compile benchmark_name platform_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./parboil compile bfs cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#bfs 可执行文件在目录 parboil_Dir/benchmarks/bfs/build/cuda_default/bfs&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来逐一编译11个 benchmark 即可&lt;/p>
&lt;h2 id="4-run-1">4. Run&lt;/h2>
&lt;h3 id="41-run-命令">4.1 Run 命令&lt;/h3>
&lt;p>2021-12-05 13:20:02 ✔️ 搞定&lt;/p>
&lt;p>⭐ ​使用 GPGPU-Sim 需要在运行目录下放置 3 个 config 文件&lt;/p>
&lt;p>GPGPU-Sim 配置文件放在 &lt;code>~/Parboil/benchmarks/bfs&lt;/code> 目录下即可，成功运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cp ~/gpgpu-sim_distribution/configs/GTX480/* ~/Parboil/benchmarks/bfs/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./parboil run bfs cuda 1M
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-script">5. Script&lt;/h2>
&lt;h3 id="51-config文件">5.1 Config文件&lt;/h3>
&lt;p>每个 benchmark 目录下复制好3个 GPGPU-Sim 必备的 config 文件，怎么实现并行执行是一个考验。在不改动原来的脚本文件前提下，每次运行都是在 &lt;code>~/Parboil/benchmarks/Benchmark_Name_Dir&lt;/code> 目录下，所以在使用不同的调度策略启动前，需要将对应的 config 文件复制到此目录。
而为了保证并行，需要在其启动后（不可能等待其执行完毕再复制），就复制另一种调度策略的 config 文件。&lt;/p>
&lt;h1 id="polybench">Polybench&lt;/h1>
&lt;h2 id="0-前言-3">0. 前言&lt;/h2>
&lt;p>Ubuntu20.04 下使用 GPGPU-Sim 编译运行 Polybench&lt;/p>
&lt;h2 id="1-40-sim">1. 4.0 sim&lt;/h2>
&lt;p>在 CUDA/utilities/common.mk 中，&lt;code>nvcc&lt;/code> 后面加上 &amp;ndash;cudart shared&lt;/p>
&lt;h1 id="tango">Tango&lt;/h1>
&lt;p>CUDA Code 似乎和 parboil 类似，都是读取当前目录下的 data 文件夹，因此需要在 tango 的目录中去运行，写一下脚本。&lt;/p>
&lt;p>2022-03-18 14:32:07，确实如此，否则会出现 &lt;code>File Not Found&lt;/code>&lt;/p>
&lt;h1 id="cuda-sdk">CUDA SDK&lt;/h1>
&lt;h2 id="0-前言-4">0. 前言&lt;/h2>
&lt;p>CUDA Samples 似乎没有放置在 toolkit 里面，需要单独安装使用&lt;/p>
&lt;h2 id="1-排坑">1. 排坑&lt;/h2>
&lt;p>实际没有链接到 CUDA 4.2，而是自己装的 CUDA 11.1 版本，所以报错&lt;/p>
&lt;p>先尝试修改一下环境变量，简单地修改环境变量是不行的。切换 CUDA 版本还需要修改软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /usr/local/cuda &lt;span style="color:#75715e">#删除之前创建的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda11.4 /usr/local/cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nvcc -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Python处理输出log信息并绘图</title><link>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</link><pubDate>Wed, 08 Dec 2021 09:05:41 +0800</pubDate><guid>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。&lt;/p>
&lt;p>需要两个绘图工具&lt;/p>
&lt;ul>
&lt;li>对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等&lt;/li>
&lt;li>对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等&lt;/li>
&lt;/ul>
&lt;h1 id="1-正则表达式">1. 正则表达式&lt;/h1>
&lt;h2 id="11-实例">1.1 实例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">read_string&lt;/span>(file,metrics):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output&lt;span style="color:#f92672">=&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> it_metrics &lt;span style="color:#f92672">in&lt;/span> metrics:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;gpu_ipc&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34; =(\s+)(\d+\.\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Stall&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;:(\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34; = (\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i,line &lt;span style="color:#f92672">in&lt;/span> enumerate(open(get_file_path()&lt;span style="color:#f92672">+&lt;/span>file)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> match &lt;span style="color:#f92672">in&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>finditer(pattern, line):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;gpu_ipc&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>list(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>list(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>float(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(output_part))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_sum&lt;span style="color:#f92672">+=&lt;/span>output_part
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[it_metrics]&lt;span style="color:#f92672">=&lt;/span>output_sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> output
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。&lt;/p>
&lt;p>&lt;code>for i,line in enumerate(open(file))&lt;/code> 遍历 log 的每一行，一定要加上 &lt;code>i&lt;/code> 否则会报错。&lt;/p>
&lt;p>&lt;code>match.group(1)&lt;/code> 每次会返回一个整数，这个时候整数是元组的形式，所以需要先转化为 list，然后转化为 float 类型，这个时候便可以用于算术运算。&lt;/p>
&lt;h3 id="111-group">1.1.1 group&lt;/h3>
&lt;ul>
&lt;li>似乎有点理解这个匹配了，对于 &lt;code>gpu_ipc&lt;/code>，\s+ 匹配的是至少一个空格，实际匹配的是多个空格，如果使用 group(1) 就会返回这个元组&lt;/li>
&lt;li>我们想要的是 \d+，所以返回第二个元组，再将其转化为 float 即可&lt;/li>
&lt;li>2021-10-28 20:11:01：搞定，小数部分也能保留&lt;/li>
&lt;/ul>
&lt;h2 id="12-字符串开头结尾匹配">1.2 字符串开头/结尾匹配&lt;/h2>
&lt;p>检查字符串开头或结尾的一个简单方法是使用 &lt;code>str.startswith()&lt;/code> 或者是 &lt;code>str.endswith()&lt;/code> 方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> filename &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;spam.txt&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> filename&lt;span style="color:#f92672">.&lt;/span>endswith(&lt;span style="color:#e6db74">&amp;#39;.txt&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2-文件操作">2. 文件操作&lt;/h1>
&lt;h2 id="21-python-os-文件目录方法">2.1 Python OS 文件/目录方法&lt;/h2>
&lt;p>&lt;strong>os&lt;/strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示&lt;/p>
&lt;p>&lt;code>os.listdir(path)&lt;/code>，返回path指定的文件夹包含的文件或文件夹的名字的列表。&lt;/p>
&lt;h1 id="3-绘图">3. 绘图&lt;/h1>
&lt;h2 id="31-并列柱状图">3.1 并列柱状图&lt;/h2>
&lt;p>绘制并列柱状图与堆叠柱状图类似，都是绘制多组柱体，只需要控制好每组柱体的位置和大小即可。例如：&lt;/p>
&lt;p>❗ 注意设置柱状图宽度不可忽略，否则无法正常显示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#66d9ef">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> matplotlib.pyplot &lt;span style="color:#66d9ef">as&lt;/span> plt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total_width, n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.8&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>width &lt;span style="color:#f92672">=&lt;/span> total_width &lt;span style="color:#f92672">/&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">-&lt;/span> (total_width &lt;span style="color:#f92672">-&lt;/span> width) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x, a, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x &lt;span style="color:#f92672">+&lt;/span> width, b, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;b&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> width, c, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>legend()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>show()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h1 id="4-调试">4. 调试&lt;/h1>
&lt;h2 id="41-调试时需要输入">4.1 调试时需要输入&lt;/h2>
&lt;h1 id="5--">5. (), [],&lt;/h1>
&lt;h2 id="51--元组">5.1 () 元组&lt;/h2>
&lt;p>代表tuple元祖数据类型，元祖是一种不可变序列。创建方法很简单，大多数时候都是小括号括起来的。&lt;/p>
&lt;h2 id="52--列表">5.2 [] 列表&lt;/h2>
&lt;p>代表list列表数据类型，列表是一种可变序列。创建方法既简单又特别。&lt;/p>
&lt;h2 id="53--字典">5.3 {} 字典&lt;/h2>
&lt;p>代表dict字典数据类型，字典是Python中唯一内建的映射类型。字典中的值没有特殊的顺序，但都是存储在一个特定的键（key）下。键可以是数字、字符串甚至是元祖。&lt;/p>
&lt;h3 id="531-字典">5.3.1 字典&lt;/h3>
&lt;p>字典的每个键值 &lt;strong>key=&amp;gt;value&lt;/strong> 对用冒号 &lt;strong>:&lt;/strong> 分割，每个键值对之间用逗号 &lt;strong>,&lt;/strong> 分割，整个字典包括在花括号 &lt;strong>{}&lt;/strong> 中 ,格式如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>d &lt;span style="color:#f92672">=&lt;/span> {key1 : value1, key2 : value2 }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相当于是键值对索引，key 只能是 &lt;code>字符串，数字或元组&lt;/code>&lt;/p>
&lt;ul>
&lt;li>python 中单引号和双引号字符串没有区别&lt;/li>
&lt;/ul>
&lt;h3 id="532-用到了字典排序字典转化为-list">5.3.2 用到了字典排序、字典转化为 list&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#按键(key)排序:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_lrr_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_gto_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_cory_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_lrr&lt;span style="color:#f92672">=&lt;/span>list(y_lrr_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_gto&lt;span style="color:#f92672">=&lt;/span>list(y_gto_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_cory&lt;span style="color:#f92672">=&lt;/span>list(y_cory_dict)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Linux任务调度</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 29 Nov 2021 23:00:09 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>记录一下 &lt;code>Linux&lt;/code> 中 &lt;code>fg&lt;/code>、&lt;code>bg&lt;/code>、&lt;code>jobs&lt;/code>、&lt;code>&amp;amp;&lt;/code>、&lt;code>ctrl + z&lt;/code> 等相关指令对任务进程的操作。&lt;/p>
&lt;p>也正好借此机会学习一下进程（process）的概念&lt;/p>
&lt;h1 id="1-process">1. Process&lt;/h1>
&lt;h2 id="10-进程类型">1.0 进程类型&lt;/h2>
&lt;ul>
&lt;li>前台进程（交互式进程）
&lt;ul>
&lt;li>这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能/服务的一部分自动启动。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>后台进程&lt;/li>
&lt;/ul>
&lt;h2 id="11-并发执行">1.1 并发执行&lt;/h2>
&lt;p>To run commands concurrently you can use the &lt;code>&amp;amp;&lt;/code> command separator&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>~$ command1 &amp;amp; command2 &amp;amp; command3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will start &lt;code>command1&lt;/code>, then runs it in the background. The same with &lt;code>command2&lt;/code>. Then it starts &lt;code>command3&lt;/code> normally.&lt;/p>
&lt;blockquote>
&lt;p>这样的话 command3 是在前台运行&lt;/p>
&lt;/blockquote>
&lt;p>The output of all commands will be garbled together, but if that is not a problem for you, that would be the solution.&lt;/p>
&lt;p>If you want to have a separate look at the output later, you can pipe the output of each command into &lt;code>tee&lt;/code>, which lets you specify a file to mirror the output to.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-bsh" data-lang="bsh">~$ command1 | tee 1.log &amp;amp; command2 | tee 2.log &amp;amp; command3 | tee 3.log
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>这样可以分别在对应的 log 中查看不同 command output，我也是这么做的&lt;/p>
&lt;p>加&amp;amp;的作用其实就是将命令放到后台执行&lt;/p>
&lt;/blockquote>
&lt;h3 id="111-终止并发执行的后台进程">1.1.1 终止并发执行的后台进程&lt;/h3>
&lt;ul>
&lt;li>方法一： 通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>kill %num&lt;/code>&lt;/li>
&lt;li>方法二： 通过 &lt;code>ps&lt;/code> 命令查看任务的进程号（&lt;code>PID&lt;/code>，假设为 &lt;code>pid&lt;/code>），然后执行：&lt;code>kill pid&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="12-进程及性能分析">1.2 进程及性能分析&lt;/h2>
&lt;h3 id="121-进程状态">1.2.1 进程状态&lt;/h3>
&lt;ul>
&lt;li>R： &lt;strong>RUNNING &amp;amp; RUNNABLE&lt;/strong>，正在运行或在运行队列中等待&lt;/li>
&lt;li>S：&lt;strong>INTERRRUPTABLE_SLEEP&lt;/strong>，休眠中, 受阻, 在等待某个条件的形成或接受到 signal&lt;/li>
&lt;li>D：&lt;strong>UNINTERRUPTABLE_SLEEP&lt;/strong>，不可中断（usually IO）&lt;/li>
&lt;li>T：&lt;strong>STOPPED&lt;/strong>，ctrl + z 进入这个状态&lt;/li>
&lt;li>Z：&lt;strong>ZOMBIE&lt;/strong>，进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放&lt;/li>
&lt;/ul>
&lt;h3 id="122-查看进程状态-ps">1.2.2 查看进程状态 ps&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ps -aux &lt;span style="color:#75715e">#显示所有包含其他使用者的行程 &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>%CPU&lt;/strong>：该 process 使用掉的 CPU 资源百分比&lt;/p>
&lt;p>&lt;strong>%MEM&lt;/strong>：该 process 所占用的物理内存百分比&lt;/p>
&lt;p>&lt;strong>TTY&lt;/strong> ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。&lt;/p>
&lt;p>&lt;strong>STAT&lt;/strong>：该程序目前的状态，主要的状态参考 &lt;strong>1.2进程状态&lt;/strong>&lt;/p>
&lt;p>&lt;strong>START&lt;/strong>：该 process 被触发启动的时间&lt;/p>
&lt;p>&lt;strong>TIME&lt;/strong> ：该 process 实际使用 CPU 运作的时间&lt;/p>
&lt;h3 id="123-性能分析-top">1.2.3 性能分析 top&lt;/h3>
&lt;h5 id="信息查看实例">信息查看实例&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>top - 19:39:49 up &lt;span style="color:#ae81ff">77&lt;/span> days, 8:54, &lt;span style="color:#ae81ff">0&lt;/span> users, load average: 5.00, 5.00, 5.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 系统当前时间；开机到现在77days 8h 54 mins；0 users 在线；系统1分钟、5分钟、15分钟的CPU负载信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tasks: &lt;span style="color:#ae81ff">13&lt;/span> total, &lt;span style="color:#ae81ff">1&lt;/span> running, &lt;span style="color:#ae81ff">12&lt;/span> sleeping, &lt;span style="color:#ae81ff">0&lt;/span> stopped, &lt;span style="color:#ae81ff">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%Cpu&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span>: 20.9 us, 0.0 sy, 0.0 ni, 79.1 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %sy：内核占用CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %ni：改变过优先级的进程占用CPU的百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %id：空闲CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %wa：等待I/O的CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %hi：CPU硬中断时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %si：CPU软中断时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MiB Mem : 48192.1 total, 25777.1 free, 2605.3 used, 19809.7 buff/cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MiB Swap: 19530.0 total, 19491.7 free, 38.2 used. 45002.0 avail Mem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="查看单个进程使用cpu情况">查看单个进程使用CPU情况&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ top -p pid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ps -aux &lt;span style="color:#75715e">#这个好像更加方便一点&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-为什么top查看只有1-running其他sleeping">1.3 为什么top查看只有1 running，其他sleeping?&lt;/h2>
&lt;h5 id="stackoverflow回答">Stackoverflow回答&lt;/h5>
&lt;p>There is no correlation between CPU usage as reported by &lt;code>top&lt;/code> and process state. The &lt;a href="http://linux.die.net/man/1/top">man page&lt;/a> says (&lt;em>emphasis&lt;/em> mine):&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>%CPU&lt;/strong> &amp;ndash; CPU usage&lt;/p>
&lt;p>The task&amp;rsquo;s share of the elapsed CPU time &lt;em>since the last screen update&lt;/em>, expressed as a percentage of total CPU time.&lt;/p>
&lt;/blockquote>
&lt;p>So, your process indeed used a huge amount of processor time since the last screen update. It is sleeping, yes, but that&amp;rsquo;s because the currently running process is &lt;code>top&lt;/code> itself (which makes sense, since it&amp;rsquo;s currently updating the screen).&lt;/p>
&lt;h5 id="理解">理解&lt;/h5>
&lt;p>这个1 running 就是 top process 本身，其他的 process 其实也是在运行的。每次 top 面板更新时活跃 process 正好是 top，所以 only 1 running。但是查看详细信息可以看到其实是在运行的。&lt;/p>
&lt;h1 id="2-进程调度">2. 进程调度&lt;/h1>
&lt;h2 id="21-基本用法">2.1. 基本用法&lt;/h2>
&lt;h3 id="211--和-jobs-指令">2.1.1 &lt;code>&amp;amp;&lt;/code> 和 &lt;code>jobs&lt;/code> 指令&lt;/h3>
&lt;p>&lt;code>&amp;amp;&lt;/code> 用在一个命令的最后，可以把这个命令转换为&lt;strong>后台运行&lt;/strong>的任务进程。&lt;/p>
&lt;p>&lt;code>jobs&lt;/code> 查看当前终端有多少在后台运行的进程。&lt;/p>
&lt;ul>
&lt;li>&lt;code>jobs&lt;/code> 命令执行的结果，&lt;code>＋&lt;/code> 表示是一个当前的作业，&lt;code>-&lt;/code> 减号表示是一个当前作业之后的一个作业。&lt;/li>
&lt;li>&lt;code>jobs -l&lt;/code> 选项可显示所有任务的进程号 &lt;code>pid&lt;/code>&lt;/li>
&lt;li>&lt;code>jobs&lt;/code> 的状态可以是 &lt;code>running&lt;/code>，&lt;code>stopped&lt;/code>，&lt;code>terminated&lt;/code>。但是如果任务进程被终止了（&lt;code>kill&lt;/code>），当前的终端环境中也就删除了任务的进程标识；也就是说 &lt;strong>jobs 命令显示的是当前 shell 环境中后台正在运行或者被挂起的任务进程信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="213-fg-和-bg-指令">2.1.3 &lt;code>fg&lt;/code> 和 &lt;code>bg&lt;/code> 指令&lt;/h3>
&lt;p>&lt;code>fg&lt;/code> 将后台任务进程调至&lt;strong>前台&lt;/strong>继续运行，如果后台中有多个任务进程，可以用 &lt;code>fg %num&lt;/code> 将选中的任务进程调至前台。&lt;/p>
&lt;p>&lt;code>bg&lt;/code> 将挂起的任务进程重新启动运行，如果有多个暂停的任务进程，可以用 &lt;code>bg %num&lt;/code> 将选中的任务进程启动运行。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>%num&lt;/code> 是通过 &lt;code>jobs&lt;/code> 命令查到的后台正在执行的任务的序号（不是 &lt;code>pid&lt;/code>）&lt;/p>
&lt;/blockquote>
&lt;p>❗ 使用 ispass_run.sh 的时候最好使用 &lt;code>fg&lt;/code>，如果使用 &lt;code>bg&lt;/code> 则无法再次挂起，&lt;del>猜测是因为&lt;/del>，原因是 &lt;code>ctrl + z&lt;/code> 是用于挂起前台进程，使用 &lt;code>stop&lt;/code> 将其挂起即可&lt;/p>
&lt;blockquote>
&lt;p>使用 stop 2，好像也无法将其挂起？&lt;/p>
&lt;/blockquote>
&lt;h2 id="22-进程的挂起">2.2. 进程的挂起&lt;/h2>
&lt;h3 id="221-后台进程的挂起">2.2.1 后台进程的挂起&lt;/h3>
&lt;ul>
&lt;li>在 &lt;code>solaris&lt;/code> 中通过 &lt;code>stop&lt;/code> 命令执行，通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>stop %num&lt;/code>&lt;/li>
&lt;li>在 &lt;code>redhat&lt;/code> 中，不存在 &lt;code>stop&lt;/code> 命令，可通过执行命令 &lt;code>kill -stop PID&lt;/code>，将进程挂起&lt;/li>
&lt;/ul>
&lt;h3 id="222-前台进程的挂起-ctrlz">2.2.2 前台进程的挂起 ctrl+z&lt;/h3>
&lt;p>&lt;code>ctrl + z&lt;/code>：可以将一个正在s前台执行的任务放到后台运行，并且挂起&lt;/p>
&lt;h2 id="23-挂起进程重新运行-bg-fg">2.3. 挂起进程重新运行 bg, fg&lt;/h2>
&lt;ul>
&lt;li>通过 &lt;code>bg %num&lt;/code> 即可将挂起的任务进程的状态由 &lt;code>stopped&lt;/code> 改为 &lt;code>running&lt;/code>，仍在后台运行&lt;/li>
&lt;li>通过 &lt;code>fg %num&lt;/code> 即可将挂起的任务进程转为前台执行&lt;/li>
&lt;/ul>
&lt;h2 id="24-进程的终止">2.4. 进程的终止&lt;/h2>
&lt;h3 id="241-后台进程的终止-kill-killall">2.4.1 后台进程的终止 kill, killall&lt;/h3>
&lt;ul>
&lt;li>方法一： 通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>kill %num&lt;/code>&lt;/li>
&lt;li>方法二： 通过 &lt;code>ps&lt;/code> 命令查看任务的进程号（&lt;code>PID&lt;/code>，假设为 &lt;code>pid&lt;/code>），然后执行：&lt;code>kill pid&lt;/code>&lt;/li>
&lt;li>&lt;code>killall CMD&lt;/code>：通过进程名 kill 感觉比根据 pid 方便很多&lt;/li>
&lt;/ul>
&lt;h3 id="242-前台进程的终止-ctrlc">2.4.2 前台进程的终止 ctrl+c&lt;/h3>
&lt;p>执行 &lt;code>ctrl+c&lt;/code> 即可终止前台执行任务进程&lt;/p>
&lt;blockquote>
&lt;p>假设要后台运行 &lt;code>xmms&lt;/code>，可通过命令：&lt;code>xmms &amp;amp;&lt;/code>。但万一你运行程序时忘记使用 &lt;code>&amp;amp;&lt;/code> 了，又不想重新执行，你可以先使用 &lt;code>ctrl+z&lt;/code> 挂起任务进程，然后敲入&lt;code>bg&lt;/code> 命令，这样任务进程就在后台继续运行了。&lt;/p>
&lt;/blockquote>
&lt;h1 id="3-查看cpu信息">3. 查看CPU信息&lt;/h1>
&lt;ul>
&lt;li>查看物理CPU个数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;physical id&amp;#34;&lt;/span>| sort| uniq| wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>查看每个物理CPU中core的个数(即核数)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;cpu cores&amp;#34;&lt;/span>| uniq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>查看逻辑CPU的个数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;processor&amp;#34;&lt;/span>| wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="4-why-jobs-看不到后台-process">4. Why &lt;code>jobs&lt;/code> 看不到后台 process&lt;/h1>
&lt;h2 id="41-关闭终端造成孤儿进程">4.1 关闭终端造成孤儿进程&lt;/h2>
&lt;blockquote>
&lt;p>jobs是查看当前后台作业（进程），是获取本次bash下的后台作业。
当本次终端退出后，后台作业变成&lt;strong>孤儿进程&lt;/strong>，孤儿进程有系统父进程接管。
当再次连接终端时，&lt;strong>原作业&lt;/strong>与&lt;strong>当前终端&lt;/strong>，不存在关系父子关系，故看不到进程。
但是原作业，会在系统中一致运行，直到完成或被停止。
这就是为什么终端退出后，jobs看不到的原因了&lt;/p>
&lt;/blockquote>
&lt;h2 id="42-nohup">4.2 nohup&lt;/h2>
&lt;h3 id="421-">4.2.1 &amp;amp;&lt;/h3>
&lt;p>守护进程貌似跟nohup + &amp;amp;方式启动的进程差不多。都可以实现与终端的无关联。&lt;/p>
&lt;p>&amp;amp; 可以让进程在后台运行，ctrl + C 无法终端，对 SIGINT 信号免疫，但是直接关闭 shell 后进程会消失。&amp;amp; 后台没有那么硬 :)，对 SIGHUP 信号不免疫&lt;/p>
&lt;h3 id="422-nohup--作用">4.2.2 nohup 作用&lt;/h3>
&lt;p>nohup 的作用是忽略 SIGHUP 信号，也就是不挂断地运行&lt;/p>
&lt;p>&amp;amp;和nohup没有半毛钱的关系， 要让进程真正不受shell中Ctrl C和shell关闭的影响， 那该怎么办呢？ 那就用nohup ./start.sh &amp;amp;吧， 两全其美。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/">https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/machangwei-8/p/10391440.html">https://www.cnblogs.com/machangwei-8/p/10391440.html&lt;/a>&lt;/p></description></item></channel></rss>