<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cory Code</title><link>https://huweim.github.io/</link><description>Recent content on Cory Code</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 19 Apr 2022 18:34:28 +0800</lastBuildDate><atom:link href="https://huweim.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>About</title><link>https://huweim.github.io/about/</link><pubDate>Thu, 08 Jul 2021 17:46:31 +0800</pubDate><guid>https://huweim.github.io/about/</guid><description>&lt;p>oh man, I love computer science and coding.&lt;/p>
&lt;p>一个计算机体系结构方向的学生，喜欢体系结构，喜欢编程，喜欢篮球。目前的课题主要关注 GPU/GPGPU。&lt;/p>
&lt;p>不确定自己是否喜欢折腾，是否喜欢新鲜事物，是否擅长编程。希望在一步一步探索中找到自己真正感兴趣的事情，或者确定这就是自己真正感兴趣的事情。&lt;/p></description></item><item><title>CSAPP阅读笔记</title><link>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E6%95%99%E6%9D%90_csapp%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>最近刚把 adaptive 调度的一部分工作写成了文章，在 SOCC DDL（4.14） 投了出去。之后会准备oneflow面试，如果可以拿下这份远程实习，对工程能力和并行计算优化方面会有更好的优化。因此，希望可以好好准备一下oneflow二面。准备的方式就是浏览一遍CSAPP，一方面是复习体系结构中的一些知识，另一方面再构建一下对整个计算机结构，操作系统，C语言的了解和认识。&lt;/p>
&lt;h2 id="01-知识点挖坑">0.1 知识点挖坑&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>浮点数的表示&lt;/p>
&lt;/li>
&lt;li>
&lt;p>流水线的设计（第四章）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="12">1.2&lt;/h2>
&lt;p>预处理：把 # 开头的一些代码替换成对应的内容，比如 &lt;code>#include&amp;lt;stdio.gh&amp;gt;&lt;/code>, &lt;code>#define&lt;/code>，或者是之前见过的，别人写代码时用到的宏定义来代替 for 循环等操作。hello.c -&amp;gt; hello.i&lt;/p>
&lt;p>编译器：得到汇编语言，也就是各种指令。生成 hello.s (s 代表 assembly？)&lt;/p>
&lt;p>汇编阶段：translate assembly to machine code.&lt;/p>
&lt;p>链接：合并，比如 hello 程序调用了 printf 函数，which is in &lt;code>printf.o&lt;/code>，链接器（ld）负责做这种合并&lt;/p>
&lt;p>大型项目往往会出现和链接器相关的错误。比如你定义了2个名字相同的全局变量，静态库和动态库区别？第七章会介绍&lt;/p>
&lt;h3 id="141-系统的硬件组成">1.4.1 系统的硬件组成&lt;/h3>
&lt;p>这里有描述架构和微架构的区别&lt;/p>
&lt;blockquote>
&lt;p>指令集架构描述的是每条机器代码指令的效果；微体系结构（微架构）描述的是处理器实际上是如何实现的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="141-运行-hello-程序">1.4.1 运行 hello 程序&lt;/h3>
&lt;p>DMA，data 不通过处理器，直接从磁盘到达主存&lt;/p>
&lt;h2 id="15-cache-至关重要">1.5 Cache 至关重要&lt;/h2>
&lt;p>cache，SRAM&lt;/p>
&lt;h2 id="17-os管理硬件">1.7 OS管理硬件&lt;/h2>
&lt;p>两个基本功能：防止硬件被失控的应用程序滥用；向application提供简单一致的机制来控制复杂而大不相同的低级硬件设备&lt;/p>
&lt;p>PS: 硬件设备的架构、配置各不相同，而OS正是这样的一个接口。&lt;/p>
&lt;h3 id="171-进程process">1.7.1 进程（process）&lt;/h3>
&lt;p>OS 跟踪 进程 运行需要的所有状态信息，这种状态称为&lt;strong>上下文&lt;/strong>，包括 PC，register file。&lt;/p>
&lt;p>上下文切换：OS 决定把控制权转移到另一个进程，进行上下文切换&lt;/p>
&lt;p>PS：从微架构来理解，其实就是执行的下一条指令PC以及数据（来自register file）换掉了，换成了OS层面的另一个进程。&lt;/p>
&lt;h3 id="172-线程">1.7.2 线程&lt;/h3>
&lt;p>这个是OS中的线程概念，一个进程由多个线程的执行单元组成&lt;/p>
&lt;h3 id="173-虚拟内存-">1.7.3 虚拟内存 ⭐&lt;/h3>
&lt;p>抽象概念，为每个进程提供独占DRAM的假象。&lt;/p>
&lt;p>&amp;ldquo;&lt;img src="D:%5CShanghaiTech%5C2022-Spring%5CCSAPP%5CNote%5CImg%5CVirtual_Memory.png" alt=""> align=left&amp;rdquo;&lt;/p>
&lt;p>从下到上（低地址向高地址）：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>代码和数据： 所有进程代码都是从同一固定地址开始。之后是存放全局变量的位置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>堆：malloc, free 这种标准库函数来进行申请，程序员来管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>共享库：存放C标准库，数学库。第七章动态链接部分会介绍。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>栈：编译器管理，实现函数调用&lt;/p>
&lt;/li>
&lt;li>
&lt;p>内核虚拟内存：application 无法直接调用，必须调用kernel来执行&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="191-amdahls-law">1.9.1 Amdahl&amp;rsquo;s Law&lt;/h3>
&lt;p>HPC，并行加速&lt;/p>
&lt;h2 id="21-信息存储">2.1 信息存储&lt;/h2>
&lt;p>浮点数：以2为基数的科学计数法。&lt;/p>
&lt;h3 id="212-字数据大小">2.1.2 字数据大小&lt;/h3>
&lt;p>字长（word size）决定虚拟地址空间的最大大小。对于字长 $w$，虚拟地址的范围为 0~$2^w-1$。近几年64位字长的机器比较多，32位字长使得虚拟地址空间为4GB。大多数64位机器可以运行32位机器编译的程序，向后兼容性。&lt;/p>
&lt;h3 id="213-寻址和字节顺序">2.1.3 寻址和字节顺序&lt;/h3>
&lt;p>这里面比较重要的知识是大端小端。&lt;/p>
&lt;p>知识前提：多字节对象（比如一个int）被存储为连续的字节序列。假设一个 int 型变量 x，取地址为 0x100，int 32bit，4 字节，实际上他的 4 个字节存储在 0x100, 0x101, 0x102, 0x103，这个是还未对齐到 cache line 的，每个字节的地址。&lt;/p>
&lt;p>假设 x = 0x01234567&lt;/p>
&lt;p>小端就是最低有效字节（67）在 0x100 地址处&lt;/p>
&lt;p>&amp;ldquo;&lt;img src="D:%5CShanghaiTech%5C2022-Spring%5CCSAPP%5CNote%5CImg%5CByte_address.png" alt=""> align=left&amp;rdquo;&lt;/p>
&lt;p>反汇编（disassembler）：确定可执行文件所表示的指令序列。&lt;/p>
&lt;p>typedef 给数据命名，主要是改善代码可读性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>int_pointer;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>int_pointer ip;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不过这个*为什么是和 int_pointer 挨在一起的？&lt;/p>
&lt;h3 id="217-位运算">2.1.7 位运算&lt;/h3>
&lt;p>这个自己编程时用的比较少&lt;/p>
&lt;p>与运算：$&amp;amp;$&lt;/p>
&lt;p>或运算：$|$&lt;/p>
&lt;p>NOT，取反：$~$ &lt;code>~0x41&lt;/code>&lt;/p>
&lt;h2 id="22">2.2&lt;/h2>
&lt;p>介绍一些补码，无符号数，有符号数&lt;/p>
&lt;p>2.3 阐述整数运算&lt;/p>
&lt;h2 id="24-浮点数">2.4 浮点数&lt;/h2>
&lt;h3 id="242-ieee浮点表示">2.4.2 IEEE浮点表示&lt;/h3>
&lt;p>尾数（significand）：一个二进制小数&lt;/p>
&lt;p>阶码（exponent）：浮点数加权。&lt;/p>
&lt;h1 id="3-程序的机器级表示">3. 程序的机器级表示&lt;/h1>
&lt;h3 id="321-机器级代码">3.2.1 机器级代码&lt;/h3>
&lt;p>大概讲一讲汇编代码，指令的编码格式，执行流程，关于控制的条件码&lt;/p>
&lt;h2 id="37-过程">3.7 过程&lt;/h2>
&lt;p>运行时栈&lt;/p>
&lt;h3 id="374-栈上的局部存储">3.7.4 栈上的局部存储&lt;/h3>
&lt;p>有时，寄存器不足够存放所有的本地数据，对于GPU会把这部分数据放入local memory&lt;/p>
&lt;h3 id="3101-理解指针">3.10.1 理解指针&lt;/h3>
&lt;h1 id="4-处理器体系结构">4. 处理器体系结构&lt;/h1>
&lt;h2 id="41-y86-65-指令集体系结构">4.1 Y86-65 指令集体系结构&lt;/h2>
&lt;p>介绍指令集架构，指令，RISC，CISC&lt;/p>
&lt;h2 id="42-逻辑设计和硬件控制语言-hcl">4.2 逻辑设计和硬件控制语言 HCL&lt;/h2>
&lt;p>最常用的是 Verilog，描述电路的语言。&lt;/p>
&lt;p>设计逻辑门，组合逻辑电路，布尔表达式，存储器，时钟（CLK）&lt;/p>
&lt;p>很多的逻辑门组合成一个网，就能构建计算块(computational block)，称为组合电路(combinational circuits)。构建这些网有两条限制：&lt;/p>
&lt;ul>
&lt;li>两个或多个逻辑门的输出不能连接在一起。否则它们可能会使线上的信号矛盾，可能会导致一个不合法的电压或电路故障&lt;/li>
&lt;li>这个网必须是无环的。也就是在网中不能有路径经过一系列的门而形成一个回路，这样的回路会导致该网络计算的函数有歧义。&lt;/li>
&lt;/ul>
&lt;h2 id="43-y86-65-的顺序实现">4.3 Y86-65 的顺序实现&lt;/h2>
&lt;p>介绍了几个 pipeline stage, fetch, decode, excute, memory, write back, PC update&lt;/p>
&lt;h2 id="44-流水线的通用原理">4.4 流水线的通用原理&lt;/h2>
&lt;p>介绍流水线如何缩短执行所需的 cycle&lt;/p>
&lt;p>流水线会有一些&lt;strong>局限性&lt;/strong>：不同逻辑单元的时钟周期并非完全一致的。流水线过深会造成收益下降。&lt;/p>
&lt;h2 id="45-y86-64-的流水线实现">4.5 Y86-64 的流水线实现&lt;/h2>
&lt;p>设计分支预测，data hazard, control hazard, structure hazard。主要是关于几个 hazard，以及处理方式，比如 stall, forward（转发）。&lt;/p>
&lt;p>什么是结构危害？&lt;/p>
&lt;p>当硬件不能在重叠执行中同时支持所有可能的指令组合时，资源冲突就会引起&lt;strong>结构性危险&lt;/strong>。在现代处理器中，结构性危害主要发生在不常用的特殊功能单元中（例如浮点除法或其他复杂的长期运行指令）。这个没有 data hazard and control hazard 常见。&lt;/p>
&lt;p>还涉及异常处理&lt;/p>
&lt;h3 id="458-流水线控制逻辑">4.5.8 流水线控制逻辑&lt;/h3>
&lt;p>发现特殊控制条件，流水线控制机制，控制逻辑实现&lt;/p>
&lt;h3 id="459-性能分析">4.5.9 性能分析&lt;/h3>
&lt;p>其实就是 IPC 和 CPI&lt;/p>
&lt;h2 id="5-优化程序性能">5. 优化程序性能&lt;/h2>
&lt;p>编写高效的程序：适当的算法和数据结构；编写编译器能够有效优化以转换成高效可执行代码的源码，这一点就要求比较了解和编译器相关的知识；利用并行性。&lt;/p>
&lt;h2 id="51-优化编译器的能力和局限性">5.1 优化编译器的能力和局限性&lt;/h2>
&lt;p>&lt;code>-O2 -O3&lt;/code> 级别的优化可以进一步提高程序的性能，但是也可能增加程序的规模。&lt;/p>
&lt;p>阻碍优化的因素：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>阐述了两个指针可能指向同一个内存位置的情况，这个被称为&lt;strong>内存别名使用&lt;/strong>(memory aliasing)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>函数调用，函数可能会有副作用（改变全局程序状态的一部分）&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>大部分编译器不会判断函数是否偶副作用。可以用 inline function 替换来优化函数调用&lt;/p>
&lt;p>gcc不是最好的编译器，但对于大部分人已经足够用。&lt;/p>
&lt;h2 id="52-表示程序性能">5.2 表示程序性能&lt;/h2>
&lt;blockquote>
&lt;p>我们引入度量标准每元素的周期数(Cycles Per Element, CPE)作为一种表示性能并指导我们改进代码的方法。处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用千兆赫兹(GHz)，即十亿周期每秒来表示。CPE 越小越好。&lt;/p>
&lt;/blockquote>
&lt;h2 id="54-消除循环的低效率">5.4 消除循环的低效率&lt;/h2>
&lt;p>最常见的就是把函数调用放到 loop 之外，比如我之前编程时很喜欢写&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> vec.size(); i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样会大量调用 size() function，可以做如下优化&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> len &lt;span style="color:#f92672">=&lt;/span> vec.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> len; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上的代码移动(code motion)是一种优化。这类优化包括识别要执行多次(例如在循环里)但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。&lt;/p>
&lt;h2 id="55-减少过程调用">5.5 减少过程调用&lt;/h2>
&lt;blockquote>
&lt;p>过程调用会代码相当大的开销，而且妨碍大多数形式的程序优化。我们可以直接访问数组，而不是利用函数调用并加上边界检查。&lt;/p>
&lt;/blockquote>
&lt;p>也就是说去掉不必要的一些边界检查。&lt;/p>
&lt;h2 id="56-消除不必要的内存引用">5.6 消除不必要的内存引用&lt;/h2>
&lt;p>比如无需每次都把结果写入 dest，可以使用一个临时变量，消除不必要的存储器引用&lt;/p>
&lt;h2 id="57-理解现代处理器">5.7 理解现代处理器&lt;/h2>
&lt;p>提到了 superscaler，OoO，分支预测。大概是介绍这类技术&lt;/p>
&lt;h2 id="58-循环展开">5.8 循环展开&lt;/h2>
&lt;blockquote>
&lt;p>循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。其思想是在一次迭代中访问数组并做乘法，这样得到的程序需要更少的迭代，从而降低循环的开销。&lt;/p>
&lt;/blockquote>
&lt;p>PS：这个应该是和最基础的并行思想想结合。&lt;/p>
&lt;h2 id="59-提高并行性">5.9 提高并行性&lt;/h2>
&lt;p>多个积累变量；重新结合变换；这就涉及到 SIMD&lt;/p>
&lt;h2 id="511-一些限制因素">5.11 一些限制因素&lt;/h2>
&lt;p>寄存器溢出；分支预测和预测错误处罚；Amdahl定律&lt;/p>
&lt;h2 id="512-理解内存性能">5.12 理解内存性能&lt;/h2>
&lt;p>这个就是研究 load/store 的影响，也就是 cache&lt;/p>
&lt;h2 id="513-应用性能提高技术">5.13 应用：性能提高技术&lt;/h2>
&lt;p>高级设计：为遇到的问题选择适当的算法和数据结构。&lt;/p>
&lt;p>基本编码原则：消除连续的函数调用；消除不必要的内存引用；&lt;/p>
&lt;p>低级优化：展开循环；SIMD；&lt;/p>
&lt;h2 id="514-确认和消除性能瓶颈">5.14 确认和消除性能瓶颈&lt;/h2>
&lt;p>也就是常说的 profiling 技术，code profiler。&lt;/p>
&lt;p>最基础的就是插入工具代码，确定程序的各个部分需要多少时间。&lt;/p>
&lt;h1 id="6-存储器层次结构memory-system">6. 存储器层次结构（memory system）&lt;/h1>
&lt;h2 id="61-存储技术">6.1 存储技术&lt;/h2>
&lt;p>RAM，Random-Access-Memory，分为 SRAM，DRAM。&lt;/p>
&lt;p>SRAM：每个 bit 存在一个双稳态（bitstable）存储器单元。只有两个稳定的配置（configuration）或者状态（state）&lt;/p>
&lt;p>DRAM：DRAM相比SRAM，对干扰非常敏感。内存系统必须周期性地读出，然后重写来刷新每一位。&lt;/p>
&lt;p>NVM（Non-Volatile Memory）：闪存（flash memory），新型的基于闪存的磁盘驱动器，SSD（Solid State Disk）&lt;/p>
&lt;p>Cache 的一些基本信息。&lt;/p>
&lt;h1 id="7-链接">7. 链接&lt;/h1>
&lt;p>链接：将各种代码和数据和数据片段收集并组合成为一个单一文件的过程，这个文件可以被&lt;strong>加载&lt;/strong>（复制）到内存并执行。链接可以执行与 compile time, load time, run time.&lt;/p>
&lt;p>PS：链接在大型工程项目编译时应该很重要，可以避免对一些源代码文件的重复编译。&lt;/p>
&lt;p>大多数编译系统提供编译驱动程序（compiler driver），为用户根据需求调用语言预处理器、编译器、汇编器和链接器。&lt;/p>
&lt;h2 id="72-静态链接">7.2 静态链接&lt;/h2>
&lt;p>为了创建可执行文件，链接器必须完成两个主要任务：&lt;/p>
&lt;ul>
&lt;li>符号解析（symbol resolution），将一个符号引用和一个符号定义结合起来&lt;/li>
&lt;li>重定位（relocation），编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义域一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指向这个存储器位置，从而重定位这些节。&lt;/li>
&lt;/ul>
&lt;p>目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些则包含程序数据，而其他的则包含指导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。&lt;/p>
&lt;h2 id="73-目标文件">7.3 目标文件&lt;/h2>
&lt;p>目标文件有三种形式：&lt;/p>
&lt;ul>
&lt;li>可重定位目标文件，包含二进制文件和代码，其形式在编译时和其他可重定位目标文件合并起来，创建一个可执行目标文件&lt;/li>
&lt;li>可执行目标文件，其形式可被拷贝到存储器并执行&lt;/li>
&lt;li>共享目标文件，一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到存储器并链接。&lt;/li>
&lt;/ul>
&lt;p>编译器和汇编器生成可重定位目标文件（包括共享目标文件），链接器生成可执行目标文件&lt;/p>
&lt;h2 id="710-动态共享链接库">7.10 动态共享链接库&lt;/h2>
&lt;p>共享库(shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接(dynamic linking)，是由一个叫做动态链接器的程序来执行的。&lt;/p>
&lt;p>共享库也称为共享目标(shared object)，在 Unix 系统中通常用 .so 后缀来表示。微软的操作系统大量地利用了共享库，它们称为 DLL。&lt;/p>
&lt;p>动态链接库和静态链接库的区别：&lt;/p>
&lt;p>关于静态库&lt;/p>
&lt;ul>
&lt;li>
&lt;p>静态库对函数库的链接是放在编译时期完成的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>程序在运行时与函数库再无瓜葛，移植方便。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>为什么需要动态库？&lt;/strong>&lt;/p>
&lt;p>空间浪费是静态库的一个问题。&lt;/p>
&lt;p>另一个问题是静态库对程序的更新、部署和发布页会带来麻烦。如果静态库liba.lib更新了，所以使用它的应用程序都需要重新编译、发布给用户（对于玩家来说，可能是一个很小的改动，却导致整个程序重新下载，全量更新）。&lt;/p>
&lt;p>&lt;strong>动态库特点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例，规避了空间浪费问题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，增量更新。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="8-异常控制流">8. 异常控制流&lt;/h1>
&lt;p>这部分后面有需要再看&lt;/p>
&lt;blockquote>
&lt;p>处理器按照一定的序列的地址执行对应的指令，从这一个地址过渡到下一个地址成为控制转移，这样的控制转移序序列称为处理器的控制流（flow control）&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>系统必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。当子进程终止时，创造这些子进程的父进程必须得到通知。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>线代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流(Exceptional Control Flow, ECF)。异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文转换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到另一个进程，而接受者会将控制突然转移到它的一个信号处理程序。一个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。&lt;/p>
&lt;/blockquote>
&lt;h1 id="9-虚拟内存">9. 虚拟内存&lt;/h1>
&lt;p>虚拟内存这一块工作，以及请求到下级缓存之后的知识完全不solid，这也间接导致了商汤，平头哥的面试出现重大问题。在和 Xia 的交流中，这是一个潜在的研究方向。既是补短板，也是打基础。&lt;/p>
&lt;h1 id="91-物理和虚拟寻址">9.1 物理和虚拟寻址&lt;/h1>
&lt;p>物理寻址：理解为类似直接映射的方式。&lt;/p>
&lt;p>虚拟寻址：请求中包含的是一个 VA（virtual memory），经过 MMU 进行 address translation 后得到 PA（physical address），此时去 Main memory 寻址。&lt;/p>
&lt;h1 id="93-虚拟内存作为缓存的工具">9.3 虚拟内存作为缓存的工具&lt;/h1>
&lt;p>VM 系统将虚拟内存分割为大小固定的块，称为虚页（virtual page, VP）。类似地，物理内存被分割为物理页（physical page, PP）。&lt;/p>
&lt;p>在任意时刻，虚拟页面的集合部分都分为三个不相交的子集：&lt;/p>
&lt;ul>
&lt;li>未分配的：VM 系统还未分配(或者创建)的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。&lt;/li>
&lt;li>缓存的：当前缓存在物理存储器中的已分配页。&lt;/li>
&lt;li>未缓存的：没有缓存在物理存储器中的已分配页。&lt;/li>
&lt;/ul>
&lt;h3 id="931-dram高速缓存的组织结构">9.3.1 DRAM高速缓存的组织结构&lt;/h3>
&lt;p>在存储层次结构中，DRAM缓存的位置对于他的组织结构有很大的影响。DRAM 缓存的组织结构完全是由巨大的不命中开销（large overhead）驱动的。&lt;/p>
&lt;p>因为大的不命中处罚和访问第一字节的开销，虚拟页往往很大，典型地是4KB-2MB。&lt;/p>
&lt;p>由于大的不命中处罚，DRAM 缓存是全相连的，也就是说，任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的出发也非常高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM 缓存使用了更复杂精密的替换算法。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(write back)，而不是直写。&lt;/p>
&lt;p>PS：也就是说虚拟页采用的是写回的替换策略。&lt;/p>
&lt;h3 id="932-页表">9.3.2 页表&lt;/h3>
&lt;p>同任何缓存一样，虚拟存储器系统必须有某种方法来判定一个虚拟页是否存放在 DRAM 中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理存储器中选择一个牺牲页，并将虚拟页从磁盘拷贝到 DRAM 中，替换这个牺牲页。&lt;/p>
&lt;p>PS：这个和 cache 的逻辑其实是类似的。页是访问的最小单位&lt;/p>
&lt;p>这些功能是由许多软硬件联合提供的，包括操作系统软、MMU(存储器管理单元)中的地址翻译硬件和一个存放在物理存储器中叫做页表(page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。&lt;/p>
&lt;p>下图展示了一个页表的基本组织结构。&lt;strong>页表&lt;/strong>就是一个页表条目(Page Table Entry, PTE)的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="933-页命中">9.3.3 页命中&lt;/h3>
&lt;h3 id="934-缺页">9.3.4 缺页&lt;/h3>
&lt;p>在虚拟存储器的习惯说法中，DRAM不命中称为缺页（page fault）。缺页异常调用内核中缺页异常处理程序，该程序会选择一个牺牲页。在磁盘和存储器之间传送页的活动叫做交换(swapping)或者页面调度(paging)。&lt;/p>
&lt;p>PS：那就和 cache miss, cache replacement 类似。DRAM 提供不了，需要找 disk 去要数据&lt;/p>
&lt;h3 id="936-局部性再次搭救">9.3.6 局部性再次搭救&lt;/h3>
&lt;p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序往往在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集(resident set)。&lt;/p>
&lt;p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做颠簸（thrashing），这时页面将不断的换进换出。&lt;/p>
&lt;p>PS：这些概念和 cache 都是类似的。&lt;/p>
&lt;h2 id="96-address-translation">9.6 Address Translation&lt;/h2>
&lt;p>虚拟地址有两段信息，&lt;strong>虚拟页号&lt;/strong> 以及 &lt;strong>虚拟页偏移量&lt;/strong>，通过虚拟页号查询&lt;strong>页表&lt;/strong>得到物理页号，物理页偏移和虚拟页偏移对应。&lt;/p>
&lt;h3 id="962-利用tlb加速地址翻译">9.6.2 利用TLB加速地址翻译&lt;/h3>
&lt;p>TLB 是什么？TLB是一个小的、虚拟地址的缓存，其中每一行都保存着一个由单个PTE组成的块。TLB通常有高度的相连性。&lt;/p>
&lt;p>PS：也就是快速地查找 虚拟页表 到 物理页表 的映射。&lt;/p>
&lt;p>下图的描述很清晰，仔细去看 1,2,3 过程。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="963-多级页表">9.6.3 多级页表&lt;/h3>
&lt;p>PS：这个是平头哥面试过程中没有回答出来的部分。对于页表概念的空白，一部分原因应该是对OS的掌握不够。&lt;/p>
&lt;p>为什么需要用到多级页表？得先了解一级页表的缺陷，一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。&lt;/p>
&lt;p>假设虚拟地址空间为32位（即4GB），每个页面映射4KB以及每条页表项占4B：&lt;/p>
&lt;ul>
&lt;li>一级页表：进程需要1M个页表entry（4GB / 4KB = 1M, 2^20个页表项），即页表（每个进程都有一个页表）占用4MB（1M * 4B = 4MB）的内存空间。&lt;/li>
&lt;li>二级页表：一级页表映射4MB（2^22）、二级页表映射4KB，则需要1K个一级页表项（4GB / 4MB = 1K, 2^10个一级页表项）、每个一级页表项对应1K个二级页表项（4MB / 4KB = 1K），这样页表占用4.004MB（1K * 4B + 1K * 1K * 4B = 4.004MB）的内存空间。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>多级页表的内存空间占用反而变大了。但是二级页表可以不存在，二级页表可以存在但不存在主存。&lt;/p>
&lt;p>做个简单的计算，假设只有20%的一级页表项被用到了，那么页表占用的内存空间就只有0.804MB（1K * 4B + 0.2 * 1K * 1K * 4B = 0.804MB），对比单级页表的4M是不是一个巨大的节约？&lt;/p>
&lt;p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在主存中的页表承担的职责是将虚拟地址翻译成物理地址；假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有1M个页表项来映射，而二级页表则最少只需要1K个页表项（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。&lt;/p>
&lt;/blockquote>
&lt;p>PS：讲一下个人理解。每个process有4GB虚拟地址空间，因为程序的虚拟地址可能是4GB中的任意一个字节。一级页表覆盖了整个4GB的虚拟地址空间，但是如果某个一级页表没有被用到，那么就无需创建这个页表项对应的二级页表，可以在需要时再创建二级页表。&lt;/p>
&lt;h2 id="99-动态内存分配">9.9 动态内存分配&lt;/h2>
&lt;p>这部分和OS以及编程中的内存管理相关。&lt;/p>
&lt;p>显式分配：比如malloc, free, new, delete&lt;/p>
&lt;p>隐式分配：分配器检测一个已分配的块何时不再被程序所使用，那么就释放这个块。&lt;/p>
&lt;p>垃圾回收（GC, Garbage Collection）：自动释放未使用的已分配的块。一些高级语言会依赖于GC来释放已分配的块，比如 Lisp, ML, JAVA&lt;/p>
&lt;h1 id="10-系统级io">10. 系统级IO&lt;/h1>
&lt;p>将一些输入输出，打开/读取文件，重定向&lt;/p>
&lt;h1 id="11-网络编程">11. 网络编程&lt;/h1>
&lt;p>IP, Socket, Web 服务器, HTTP。&lt;/p>
&lt;p>PS：这部分自己不是很熟&lt;/p>
&lt;h1 id="12-并发编程">12. 并发编程&lt;/h1>
&lt;p>竞争，死锁&lt;/p></description></item><item><title>Paper写作 如何写文章</title><link>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E5%A6%82%E4%BD%95%E5%86%99%E6%96%87%E7%AB%A0/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>终于要开始写作了，先动笔把内容填上去，再一步一步地修正。&lt;/p>
&lt;p>自己的想法，摆几篇领域内的经典文章，尤其是相关的，比如前人做的各种调度算法，模仿他们的introduction，关键是要把你自己的动机和故事写上去。&lt;/p>
&lt;p>摆一篇你熟悉的老师的文章，模仿他的风格。&lt;/p>
&lt;h1 id="1-准备工作">1. 准备工作&lt;/h1>
&lt;h2 id="11-论文框架">1.1 论文框架&lt;/h2>
&lt;p>参考 SoCC 的篇幅要求，大概4-6页，参考自己读过的几篇经典的文章，大概可以分为 &lt;strong>Introduction, Background, Baseline Architecture, Adaptive Scheduling, Evaluation, Related Work, Result&lt;/strong>&lt;/p>
&lt;h2 id="12-过往-writing">1.2 过往 Writing&lt;/h2>
&lt;p>找一下之前在研究生论文写作课程中的评价，对自己的写作水平要有数。&lt;/p>
&lt;ul>
&lt;li>还存在一些基本的语法错误。除了自己注意以外，可以使用 Grammarly 之类的工具检查&lt;/li>
&lt;li>HW1，语法错误和格式错误；遣词有些不合理，因为有的源于中文翻译，like &amp;ldquo;people group&amp;rdquo;&lt;/li>
&lt;li>英文表达有待提高，中式英文和介词滥用会影响文章质量&lt;/li>
&lt;li>在HW2中把总结性的话写到了方法介绍的part&lt;/li>
&lt;li>HW3 中，结构组织的还不错，调研充分。&lt;/li>
&lt;/ul>
&lt;h2 id="13-经验结合自己经历">1.3 经验结合自己经历&lt;/h2>
&lt;p>第一遍太注重遣词造句，确实会卡很久，半天都憋不出一段内容，很多经验文章也强调了这点。因此第一遍就按照列好的大纲和逻辑，直白地把自己的内容写出来，之后再去反复修改即可。&lt;/p>
&lt;h1 id="2-如何模仿">2. 如何模仿&lt;/h1>
&lt;p>准备了一些优秀的论文，如何模仿他们的写作方法。&lt;/p>
&lt;h5 id="视频">视频&lt;/h5>
&lt;p>&lt;a href="https://www.zhihu.com/zvideo/1418154868939227136">https://www.zhihu.com/zvideo/1418154868939227136&lt;/a>&lt;/p>
&lt;ul>
&lt;li>目标是 C 会，那么就模仿顶会的写作和框架&lt;/li>
&lt;li>论文一定是修改出来的，反复修改&lt;/li>
&lt;li>抄下来，背下来，经典句式和表达&lt;/li>
&lt;/ul>
&lt;h1 id="3-通用表达学习模仿">3. 通用表达学习/模仿&lt;/h1>
&lt;p>2022-04-11 12:59:07，目前自己写完了大概的初稿，由于词汇量的匮乏和写作水平低下，很多时候会用大量重复的句子表达类似的意思（比如出现了 N 次的 some researchers，比如 LRR exceeds GTO），如果整体结构一成不变也是不行的，现在记录一些别人文章中的经典表达。&lt;/p>
&lt;h5 id="性能提升">性能提升&lt;/h5>
&lt;p>LRR scheduling policy far &lt;strong>outperforms&lt;/strong> GTO, by up to 78% in $conv2$ and 56.7% in $conv3$.&lt;/p>
&lt;p>GTO scheduler &lt;strong>exceeds&lt;/strong> LRR in kernel $conv1$ of ResNet and AlexNet&lt;/p>
&lt;p>MT-prefetching &lt;strong>improves performance&lt;/strong> on average by 16%&lt;/p>
&lt;p>&lt;strong>provide 33% average performance improvement&lt;/strong> compared to the commonly-employed round-robin warp scheduling policy&lt;/p>
&lt;h5 id="分析图片对于xxx">分析图片，对于XXX&lt;/h5>
&lt;p>For example,&lt;/p>
&lt;p>For CifarNet,&lt;/p>
&lt;p>As a result,&lt;/p>
&lt;p>Both the ResNet and AlexNet&lt;/p>
&lt;h1 id="5-一些阅读总结">5. 一些阅读总结&lt;/h1>
&lt;p>&lt;strong>Academic tips:&lt;/strong> &lt;a href="http://taoxie.cs.illinois.edu/advice/">advice collection by Professor Tao Xie&lt;/a>. 有很多有用的关于研究、写作的建议。&lt;/p>
&lt;h5 id="why-i-gave-your-paper-a-strong-reject">Why I gave your paper a Strong Reject&lt;/h5>
&lt;p>&lt;strong>The abstract and intro suck&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这部分有语法错误就很扣分了&lt;/li>
&lt;li>必须在摘要和介绍中描述你的方法和实验结果&lt;/li>
&lt;li>花更多时间在前两页 paper，剩下的只是backup up你在前两页说的东西&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Diving into your solution before defining the problem&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简单地说，就是 motivate the wok&lt;/li>
&lt;li>不要一上来就一大堆细节，先把问题讲清楚&lt;/li>
&lt;li>描述 目标，限制，提供细节的应用（NN，性能差异）；tell that 之前的解决方案 doesn&amp;rsquo;t work&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Focusing the paper on the mundane implementation details, rather than the ideas&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>审稿人只在意你的 idea&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Writing a bunch of wordy bullshit that doesn&amp;rsquo;t mean anything&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简洁而具体&lt;/li>
&lt;li>bad idea 不会因为 sound fancy 而被接收&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Overcomplicating the problem so you get a chance to showcase some elaborate technical approach&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>有时作者会将问题复杂化，以此展示自己的解决方案&lt;/li>
&lt;li>如果将问题简化，那么 beautiful design 可能就不那么必要了&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Figures with no descriptive captions&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>理想情况下，图片的caption需要总结图片的内容和数据含义&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Cursory and naive treatment of related work&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>应该讨论相关工作，和你的方法进行对比，而不是简单地列出一堆 reference&lt;/li>
&lt;li>尊重相关工作。 如果您认为这是错误的，请说出来，并说明原因。 如果您正在建立其他人的好想法，请给予他们应有的信任。 正如我的博士生导师曾经告诉我的那样，站在巨人的肩膀上，而不是他们的脚趾上。&lt;/li>
&lt;/ul>
&lt;h5 id="导师教给我的英文论文写作经验">导师教给我的英文论文写作经验&lt;/h5>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/158599066">https://zhuanlan.zhihu.com/p/158599066&lt;/a>&lt;/p>
&lt;ul>
&lt;li>一些没有把握的词语/搭配，copy扔进google里看有没有人曾经使用过&lt;/li>
&lt;/ul>
&lt;h5 id="容易陷入的误区">容易陷入的误区&lt;/h5>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/dcy9w-KjP3TgFKikQbn02w">https://mp.weixin.qq.com/s/dcy9w-KjP3TgFKikQbn02w&lt;/a>&lt;/p>
&lt;ol>
&lt;li>不列大纲，上来就开干。我发现很多认识的大佬都会把每一章节甚至每一段大概要写什么，论点是什么会先列上，这样写起来事半功倍。&lt;/li>
&lt;li>第一遍初稿就极度追求完美，写的每一句话都斟酌很久，精心选词。第一遍如果过于注重语法与修饰，很容易写到崩溃，写了一周都没把前两章写完。一般来说，第一遍只要能把自己要写的大概内容表达清楚即可，甚至有些句子是由单蹦的词语组成也没事，后面一遍遍修改。&lt;/li>
&lt;li>作图草率，稀里哗啦随便画。现在很多reviewer极度缺乏耐心，你图做的不好看基本就被判死刑了。&lt;/li>
&lt;li>自己孤军奋战，不会借助外力。&lt;strong>正如前面选题、读文献、实现idea一样，写论文也要学会借助外力&lt;/strong>。起了草稿之后，多多“骚扰”师兄师姐提意见，让他们帮忙修改（当然你要挂人家名字），然后差不太多了再找老师修改。&lt;/li>
&lt;/ol>
&lt;h5 id="人大赵鑫老师如何以初学者角度写好一篇国际学术论文">【人大赵鑫老师】如何以初学者角度写好一篇国际学术论文？&lt;/h5>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw">https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw&lt;/a>&lt;/p>
&lt;p>画图非常重要，图不行就不要投论文了。&lt;/p>
&lt;p>摘要和结论放在最后写&lt;/p>
&lt;h1 id="6-实际写作感受和总结">6. 实际写作感受和总结&lt;/h1>
&lt;ul>
&lt;li>第一句话可以先概括，尤其是展示图片，然后再开始叙述&lt;/li>
&lt;/ul>
&lt;p>Therefore, 6 bits is needed for each warp and 4 warps need 24 bits in total. 2022-04-13 23:38:34，太漂亮了这一句，忍不住记录一下&lt;/p>
&lt;h1 id="61-词汇">6.1 词汇&lt;/h1>
&lt;p>同义替换的正式语句一定要多收集，多掌握，甚至背诵。&lt;/p>
&lt;h1 id="62-基本格式">6.2 基本格式&lt;/h1>
&lt;p>引用格式：这个是投稿的当天（2022-04-14）娄老师发现的。我之间从 google scholar 上粘贴下来的，实际上自己把需要的信息模板整理好，引用时去找对应的信息就行了，尤其是会议和期刊。（已整理）&lt;/p>
&lt;p>其他：比如 &lt;code>etc. et al.&lt;/code>，要注意后面带一个 &lt;code>.&lt;/code>。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://www.zhihu.com/question/22790506">https://www.zhihu.com/question/22790506&lt;/a> 如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文? By Terafer&lt;/p>
&lt;p>&lt;a href="https://www.zhihu.com/question/22790506/answer/990626321">https://www.zhihu.com/question/22790506/answer/990626321&lt;/a> 如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文? By Dr.Evil&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw">https://mp.weixin.qq.com/s/Kb9Vnl3gpYWsOC-AY1TjTw&lt;/a> 【人大赵鑫老师】如何以初学者角度写好一篇国际学术论文？&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/158599066">https://zhuanlan.zhihu.com/p/158599066&lt;/a> 导师教给我的英文论文写作经验 By Joy Chu
​&lt;/p></description></item><item><title>Paper写作 文章添加引用</title><link>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</link><pubDate>Tue, 19 Apr 2022 18:34:28 +0800</pubDate><guid>https://huweim.github.io/post/%E5%86%99%E4%BD%9C_%E6%96%87%E7%AB%A0%E6%B7%BB%E5%8A%A0%E5%BC%95%E7%94%A8/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>2022-04-10 22:59:52，折腾了一个小时搞定，纠结了很久顺序的问题，其实文末的引用是 bib 自动生成的。粘贴一篇比较好的教程&lt;/p>
&lt;h1 id="1-模板">1. 模板&lt;/h1>
&lt;p>就用 IEEE Conference 模板即可&lt;/p>
&lt;pre tabindex="0">&lt;code>https://www.ieee.org/content/dam/ieee-org/ieee/web/org/pubs/conference-latex-template_10-17-19.zip
&lt;/code>&lt;/pre>&lt;h2 id="11-代码替换">1.1 代码替换&lt;/h2>
&lt;blockquote>
&lt;p>对于 LATEX，我们一般在谷歌学术或者知网导出 &lt;code>BibTex&lt;/code> 格式的参考文献，而 IEEE 会议模版默认使用的参考文献为 &lt;code>\bibitem&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>在同级目录下新建文件 &lt;code>ref.bib&lt;/code>，用来存放需要引用的文章信息&lt;/p>
&lt;p>模板代码替换&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\begin&lt;/span>{thebibliography}{00}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&amp;#39;&amp;#39; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&amp;#39;&amp;#39; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b4} K. Elissa, ``Title of paper if known,&amp;#39;&amp;#39; unpublished.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b5} R. Nicole, ``Title of paper with only first word capitalized,&amp;#39;&amp;#39; J. Name Stand. Abbrev., in press.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&amp;#39;&amp;#39; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibitem&lt;/span>{b7} M. Young, The Technical Writer&amp;#39;s Handbook. Mill Valley, CA: University Science, 1989.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\end&lt;/span>{thebibliography}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接替换为&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibliographystyle&lt;/span>{IEEEtran}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">\bibliography&lt;/span>{references}{}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="12-bib-文件">1.2 bib 文件&lt;/h2>
&lt;p>在 &lt;code>ref.bib&lt;/code> 中添加一篇参考文献&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@article{creswell2018generative,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={Generative adversarial networks: An overview},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Creswell, Antonia and White, Tom and Dumoulin, Vincent and Arulkumaran, Kai and Sengupta, Biswa and Bharath, Anil A},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> journal={IEEE Signal Processing Magazine},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume={35},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number={1},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages={53--65},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2018},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={IEEE}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-正文中引用">1.3 正文中引用&lt;/h2>
&lt;p>原来不是手动输入框框 []，通过代码 &lt;code>\cite{creswell2018generative}&lt;/code> 来引用，LaTex 会自动编号参考文献（原来不是手动地在后面添加）&lt;/p>
&lt;h1 id="2-编译">2. 编译&lt;/h1>
&lt;p>还有关键的一步，编译需要选择 &lt;code>PDFLaTex ——&amp;gt;BibTex——&amp;gt;PDFLaTex——&amp;gt;PDFLaTex&lt;/code>&lt;/p>
&lt;h1 id="3-引用模板">3. 引用模板&lt;/h1>
&lt;h2 id="31-会议">3.1 会议&lt;/h2>
&lt;p>需要 author, booktile 填一下会议的名称，如果加了缩写，那么所有引用都加上缩写，个人喜欢加上缩写。Proceedings of the 是自己手动添加的，后面跟上会议名称即可，根据别人的引用情况，去掉了类似于“第几届”，“IEEE”之类的信息&lt;/p>
&lt;p>title 填写文章标题，&lt;strong>需要注意的是如果有大写&lt;/strong>，需要用 &lt;code>{}&lt;/code> 括起来，这个 CAWA 其实是一个典型，甚至第一次提交（2022-04-14 16:47:01）忘记了大写 GPGPU，而最开始别人标题中的大写没有生效，后来发现是 {} 的原因&lt;/p>
&lt;p>address 最好加上，正式一点，搜一下这个会议就能查到了。year 和 page 是一定要有的。page 要注意有些 bibtex 没有给完整，只有一页，需要自己去核对一下。&lt;/p>
&lt;p>以目前的了解（2022-04-14 20:10:36），其他信息应该不作要求&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@INPROCEEDINGS{7284091,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>author={Lee, Shin-Ying and Arunkumar, Akhil and Wu, Carole-Jean},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>booktitle={Proceedings of the International Symposium on Computer Architecture (ISCA)},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>title={{CAWA}: Coordinated warp scheduling and Cache Prioritization for critical warp acceleration of GPGPU workloads},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>address={Portland, OR, USA},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>year={2015},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>volume={},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>number={},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pages={515-527}, doi={10.1145/2749469.2750418}}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="32-期刊">3.2 期刊&lt;/h2>
&lt;p>title, author, pages, year 等信息和会议类似。&lt;/p>
&lt;p>journal 填写期刊名称就行，根据全局的情况加上缩写。不过这个 Computing in Science &amp;amp; Engineering 的缩写为 Computing Sci. Eng.，感觉比较相似我就没加，之后核对一下。&lt;/p>
&lt;p>volume, number 是期刊区别于会议的信息，要正确填写。期刊一般没有 address&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@article{stone2010opencl,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={{OpenCL}: A parallel programming standard for heterogeneous computing systems},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Stone, John E and Gohara, David and Shi, Guochun},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> journal={Computing in Science &lt;span style="color:#66d9ef">\&amp;amp;&lt;/span> Engineering},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> volume={12},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> number={3},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2010},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pages={66-73},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={NIH Public Access}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="33-书籍">3.3 书籍&lt;/h2>
&lt;p>除了这些信息，可能还需要别的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@book{farber2011cuda,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title={{CUDA} application design and development},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author={Farber, Rob},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year={2011},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> publisher={Elsevier}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="34-技术报告">3.4 技术报告&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-latex" data-lang="latex">&lt;span style="display:flex;">&lt;span>@TECHREPORT{Krizhevsky09learningmultiple,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> author = {Alex Krizhevsky},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> title = {Learning multiple layers of features from tiny images},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> institution = {},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> year = {2009}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://blog.51cto.com/u_13977270/3398538">https://blog.51cto.com/u_13977270/3398538&lt;/a> IEEE 会议论文的参考文献&lt;/p></description></item><item><title>Hugo 文件结构</title><link>https://huweim.github.io/post/blog_hugo_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link><pubDate>Tue, 19 Apr 2022 18:10:17 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>配置博客的代码高亮&lt;/p>
&lt;h1 id="1-文件夹结构">1. 文件夹结构&lt;/h1>
&lt;p>其中，&lt;code>config.toml&lt;/code> 是网站的配置文件，Hugo还可使用 &lt;code>config.yaml&lt;/code> 或者 &lt;code>config.json&lt;/code> 进行配置。&lt;/p>
&lt;p>&lt;code>content&lt;/code> 文件夹中存放所有的网站内容，可在此文件夹中建立其他子文件夹，即为子模块。&lt;/p>
&lt;p>&lt;code>layouts&lt;/code> 文件夹存放 &lt;code>.html&lt;/code> 格式的模板。模板确定了静态网站渲染的样式。&lt;/p>
&lt;p>&lt;code>themes&lt;/code> 文件夹存放网站使用的theme主题模板。&lt;/p>
&lt;p>&lt;code>static&lt;/code> 文件夹存放未来网站使用的静态内容，比如图片、css、JavaScript等。当Hugo生成静态网站时，该文件夹中的所有内容会原封不动的被复制。&lt;/p>
&lt;p>&lt;code>archetypes&lt;/code> 文件夹存放网站预设置的文件模板头部，当使用 &lt;code>hugo new&lt;/code> 时即可生成一个带有该头部的实例。&lt;/p>
&lt;p>&lt;code>data&lt;/code> 文件夹用来存储Hugo生成网站时应用的配置文件。配置文件可以是YAML，JSON或者TOML格式。&lt;/p>
&lt;h2 id="11-post">1.1 Post&lt;/h2>
&lt;pre tabindex="0">&lt;code>---
date: &amp;#34;2021-07-08T19:38:26+08:00&amp;#34;
draft: false
title: &amp;#34;Blog&amp;#34;
---
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>其中，&lt;code>date&lt;/code> 说明该博客建立时间，&lt;code>draft&lt;/code> 说明这篇是否是草稿，若是草稿，在无特别指明情况下并不会生成静态网页，&lt;code>title&lt;/code> 表明该文件显示的标题。&lt;/p>
&lt;p>在同样文件夹下，建立其他 &lt;code>.md&lt;/code> 文件，同样也是有相似的文件头部。该博客的文件名应和 &lt;code>title&lt;/code> 一致，但要注意 &lt;code>title&lt;/code> 中的空格或者 &lt;code>+&lt;/code> 作为文件名时应该替换成&lt;code>-&lt;/code>， 不然会报找不到404网页。文件内容在这块区域下面，使用markdown语法。&lt;/p>
&lt;/blockquote></description></item><item><title>Hugo 文章扉页设置</title><link>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E6%89%89%E9%A1%B5%E8%AE%BE%E7%BD%AE/</link><pubDate>Tue, 19 Apr 2022 18:10:17 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E6%89%89%E9%A1%B5%E8%AE%BE%E7%BD%AE/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>描述如何设置和自定义一篇 post 的页面内容和标签&lt;/p>
&lt;p>这个在英文中的描述应该是 扉页 front matter&lt;/p>
&lt;h1 id="1原型">1、原型&lt;/h1>
&lt;p>原型是创建新页面内容（运行&lt;code>hugo new&lt;/code>命令）时使用的模板，预先配置格式：例如md文件的&lt;strong>扉页&lt;/strong>（ front matter）、其它格式等。原型文件应该存放在&lt;strong>archetypes&lt;/strong>目录内。&lt;/p>
&lt;p>原型（&lt;strong>archetypes/default.md&lt;/strong>）内的扉页貌似不能进行日期格式转换：&lt;/p>
&lt;ul>
&lt;li>date属性只能是&lt;code>date: {{ .Date }}&lt;/code>，因为之后的日期格式转换&lt;a href="https://gohugo.io/functions/format/#hugo-date-and-time-templating-reference">基于此date属性&lt;/a>。若&lt;code>date: {{.Date.Format &amp;quot;2006-01-02&amp;quot;}}&lt;/code>，将会触发错误：Error: Failed to process archetype file “default.md”:: template: default:3:19: executing “default” at &amp;lt;.Date.format&amp;gt;: can&amp;rsquo;t evaluate field format in type string&lt;/li>
&lt;/ul>
&lt;h2 id="11-archetypesdefaultmd">1.1 archetypes/default.md&lt;/h2>
&lt;p>default.md：将md文件构建为HTML的页面文件（type：缺省）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;{{ replace .Name &amp;#34;&lt;/span>-&lt;span style="color:#e6db74">&amp;#34; &amp;#34;&lt;/span> &lt;span style="color:#e6db74">&amp;#34; | title }}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: {{ &lt;span style="color:#ae81ff">.Date }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;komantao&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierDisplayName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;komantao&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierEmail&lt;/span>: &lt;span style="color:#ae81ff">komantao@hotmail.com&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">url&lt;/span>: {{ &lt;span style="color:#ae81ff">replace .Dir &amp;#34;\\&amp;#34; &amp;#34;/&amp;#34; }}{{ replace .Name &amp;#34;-&amp;#34; &amp;#34; &amp;#34; | title }}.html&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">draft&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;文章描述&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">keywords&lt;/span>: [&lt;span style="color:#ae81ff">keyword1, keyword2, keyword3]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: [&lt;span style="color:#ae81ff">标签1, 标签2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: [&lt;span style="color:#ae81ff">分类1, 分类2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">首页描述。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="3扉页">3、扉页&lt;/h1>
&lt;p>扉页（ front matter）用来配置文章的标题、时间、链接、分类等元信息，提供给模板调用。可使用的格式有：yaml格式（默认格式，使用3个减号-）、toml格式（使用3个加号+）、json格式（使用大括号{}）。除了网站主页外，其它内容文件都需要扉页来识别文件类型和编译文件。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章标题&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">menuTitle&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章标题在菜单栏中显示的名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;xxx&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">keywords&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;Hugo&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;keyword&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 关键字描述&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;2018-08-20&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 文章创建日期&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: [ &lt;span style="color:#e6db74">&amp;#34;tag1&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;tag2&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 自定义标签&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: [&lt;span style="color:#e6db74">&amp;#34;cat1&amp;#34;&lt;/span>,&lt;span style="color:#e6db74">&amp;#34;cat2&amp;#34;&lt;/span>] &lt;span style="color:#75715e"># 自定义分类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">weight&lt;/span>: &lt;span style="color:#ae81ff">20&lt;/span> &lt;span style="color:#75715e"># 自定义此页面在章节中的排序优先级（按照数字的正序排序）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">disableToc&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;false&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 若值为false（缺省值）时，此页面启用TOC&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">pre&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义menu标题的前缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">post&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义menu标题的后缀&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">chapter&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># 若值为true（缺省值）时，将此页面设置为章节（chapter）&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">hidden&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># 若值为true（缺省值）时，此页面在menu中隐藏&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierDisplayName&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义修改者的名称，显示在页脚中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">LastModifierEmail&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#75715e"># 自定义修改者的Email，显示在页脚中&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">draft&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span> &lt;span style="color:#75715e"># true，表示草稿，Hugo将不渲染草稿&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#75715e"># 重置permalink，默认使用文件名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">type&lt;/span>: &lt;span style="color:#75715e"># type与layout参数将改变Hugo寻找该文章模板的顺序&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">layout&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>weight属性&lt;/p>
&lt;ul>
&lt;li>缺省时按照date属性的倒序排序（新日期排在前面）&lt;/li>
&lt;li>设置时，自定义此页面在章节中的排序（按照数字值的正序排序，数字小的排在前面，若数字值相同，则按照date属性的倒序排序）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>pre属性&lt;/p>
&lt;p>在菜单栏中的标题前添加前缀：可为数字、文字、图标（&lt;a href="https://fontawesome.com/v4.7.0/icons/">&lt;strong>Font Awesome&lt;/strong>&lt;/a>库）等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">+++&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">title = &amp;#34;Github repo&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">pre = &amp;#34;&amp;lt;i class=&amp;#39;fab fa-github&amp;#39;&amp;gt;&amp;lt;/i&amp;gt; &amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">+++&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>menuTitle属性&lt;/p>
&lt;ul>
&lt;li>缺省时调用title属性作为此页面在menu中显示的名称&lt;/li>
&lt;li>设置时，自定义此页面在menu中显示的名称&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://kuang.netlify.app/blog/hugo.html">https://kuang.netlify.app/blog/hugo.html&lt;/a>&lt;/p></description></item><item><title>LeetCode刷题记录</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 16 Mar 2022 08:59:50 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_leetcode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</guid><description>&lt;h4 id="关键字检索">关键字检索&lt;/h4>
&lt;ul>
&lt;li>查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。&lt;/li>
&lt;li>知识点：题目所涉及到的大概知识点。&lt;/li>
&lt;li>分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针&lt;/li>
&lt;li>第一遍顺序过剑指Offer，第二遍根据类型和短板刷。&lt;/li>
&lt;/ul>
&lt;h4 id="短板总结">短板总结&lt;/h4>
&lt;ul>
&lt;li>短板：二叉树，矩阵，DFS，BFS&lt;/li>
&lt;/ul>
&lt;p>2022-04-15 17:28:42，BFS，DFS，二叉树 稍微熟练了一些；目前的短板&lt;/p>
&lt;ul>
&lt;li>DP，堆，矩阵&lt;/li>
&lt;/ul>
&lt;h3 id="常见-bug">常见 BUG&lt;/h3>
&lt;h5 id="1-itoa">1. itoa&lt;/h5>
&lt;p>gcc error : undefined reference to `itoa'&lt;/p>
&lt;p>原因：itoa is a non-standard function which is supported by some compilers. Going by the error, it&amp;rsquo;s not supported by your compiler. Your best bet is to use snprintf() instead.&lt;/p>
&lt;h3 id="311">3.11&lt;/h3>
&lt;h4 id="查缺补漏">查缺补漏&lt;/h4>
&lt;ul>
&lt;li>二叉树建树&lt;/li>
&lt;li>二叉树后序遍历&lt;/li>
&lt;/ul>
&lt;h3 id="311-1">3.11&lt;/h3>
&lt;h5 id="jz03">JZ.03&lt;/h5>
&lt;p>3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；&lt;/p>
&lt;p>第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)&lt;/p>
&lt;p>第三种原地Hash，鸽巢原理。源于一个条件 &lt;code>element value &amp;lt; nums.size()&lt;/code>，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector 可以用下标索引&lt;/li>
&lt;li>标签：hash，排序，数组&lt;/li>
&lt;/ul>
&lt;h5 id="jz04-二维数组中的查找-">JZ.04 二维数组中的查找 ❌&lt;/h5>
&lt;p>感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)&lt;/p>
&lt;p>并非 DP，没有秒这题；主要是思路上的解法而非常规算法&lt;/p>
&lt;blockquote>
&lt;p>从右上角开始比较，比它大就往下数一行，比它小就往左数一列&lt;/p>
&lt;p>二分查找也是解法之一&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二维 vector 能否用下标索引？
&lt;ul>
&lt;li>可以&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>标签：数组，二分查找，分治，矩阵&lt;/li>
&lt;/ul>
&lt;h5 id="jz05-替换空格">JZ.05 替换空格&lt;/h5>
&lt;p>简单的字符串替换，被 string 和 char，&amp;quot;&amp;quot; 和 &amp;rsquo;&amp;rsquo; 的一些知识卡了一会儿。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>字符串裁剪 &lt;code>str.substr(pos, len)&lt;/code>，&lt;/li>
&lt;li>⚠️ 字符串比较；string 可以直接用 &lt;code>==&lt;/code>，但是注意 s[0] 是 char 型；所以 &lt;code>s[0] == &amp;quot; &amp;quot;&lt;/code> 会报错，应该是 &lt;code>s[0] == ' '&lt;/code>；或者 &lt;code>strcmp(s[0], ' ');&lt;/code>&lt;/li>
&lt;li>注意 &amp;quot;&amp;quot; 和 ''&lt;/li>
&lt;li>❗ 为什么不能用 strcmp？
&lt;ul>
&lt;li>用 &lt;code>strcmp(string , string)&lt;/code> 会就报错；使用 &lt;code>strcmp(char [], char[])&lt;/code> 就可以了；有什么区别？&lt;/li>
&lt;li>string 是一个 managed type，不用担心有多长；char[] 分配的长度固定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz06-反转链表">&lt;strong>JZ.06 反转链表&lt;/strong>&lt;/h5>
&lt;p>从尾到头打印链表，单链表&lt;/p>
&lt;p>自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$&lt;/p>
&lt;p>也可以使用 递归&lt;/p>
&lt;p>⚠️ 注意边界条件，基本每次 case 都会有&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>单向链表；指针；vector&lt;/li>
&lt;li>标签：栈，链表，递归，双指针&lt;/li>
&lt;/ul>
&lt;h3 id="313">3.13&lt;/h3>
&lt;h5 id="jz07-重建二叉树-">JZ.07 重建二叉树 ❌&lt;/h5>
&lt;p>二叉树和链表的数据结构要记住。&lt;/p>
&lt;p>如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解&lt;/p>
&lt;p>In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。&lt;/p>
&lt;p>❌ 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。&lt;/p>
&lt;p>pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>前序遍历列表：第一个元素永远是 【根节点 (root)】&lt;/li>
&lt;li>中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】&lt;/li>
&lt;li>做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end&lt;/li>
&lt;li>标签：数组，hash，分治，二叉树&lt;/li>
&lt;/ul>
&lt;h5 id="jz09-用两个栈实现队列">JZ.09 用两个栈实现队列&lt;/h5>
&lt;p>自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。&lt;/p>
&lt;p>更好的思路：其实不用再把 stack_2 中全部倒回 stack_1&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？&lt;code>stack&amp;lt;int&amp;gt; stk; queue&amp;lt;int&amp;gt; q;&lt;/code>&lt;/li>
&lt;li>两个栈实现队列&lt;/li>
&lt;li>标签：栈，队列&lt;/li>
&lt;/ul>
&lt;h5 id="jz10-斐波那契数列-dp">JZ.10 斐波那契数列 DP&lt;/h5>
&lt;p>自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归&lt;/p>
&lt;p>更好的思路：这题可以用 DP，没有想到。&lt;/p>
&lt;p>现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；&lt;/p>
&lt;p>转移方程：$dp[i+1] = dp[i] + dp[i-1]$&lt;/p>
&lt;p>初始状态：$dp[0] = 0; dp[1] = 1$&lt;/p>
&lt;p>返回值：$dp[n]$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路&lt;/li>
&lt;li>标签：DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz11-青蛙跳台阶">JZ.11 青蛙跳台阶&lt;/h5>
&lt;p>自己的思路：hash 递归；DP&lt;/p>
&lt;p>和上一题很类似，写的是优化空间后的 DP，&lt;/p>
&lt;p>✔️ 要求自己写一个常规的 DP 加深理解&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz11-旋转数组的最小数字-">JZ.11 旋转数组的最小数字 ❌&lt;/h5>
&lt;blockquote>
&lt;p>这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的&lt;/p>
&lt;/blockquote>
&lt;p>确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：二分查找，数组&lt;/li>
&lt;li>查缺补漏：二分查找熟练度不够&lt;/li>
&lt;/ul>
&lt;h3 id="314">3.14&lt;/h3>
&lt;h5 id="jz12-矩阵中的路径-">JZ.12 矩阵中的路径 ❌&lt;/h5>
&lt;p>自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$&lt;/p>
&lt;p>题解 DFS，DFS 已经非常生疏了&lt;/p>
&lt;p>看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>典型的矩阵搜索问题&lt;/li>
&lt;/ul>
&lt;h5 id="jz13-机器人运动范围">JZ.13 机器人运动范围&lt;/h5>
&lt;p>这个也是算法设计课程中出现的考试题目。&lt;/p>
&lt;p>自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。&lt;/p>
&lt;p>写错了一句 &lt;code>tag[i][j] == -1;&lt;/code>，报错居然是 &lt;code>stackoverflow&lt;/code>，要注意尽量一次写出 bug-free code。&lt;/p>
&lt;p>题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>和上一题类似，也是矩阵，DFS还是可以用。&lt;/li>
&lt;li>标签：&lt;strong>DP&lt;/strong>，BFS，DFS；DP 体现在哪？了解 DP 的解法&lt;/li>
&lt;/ul>
&lt;h5 id="jz14-i-剪绳子-">JZ.14-I 剪绳子 ❌&lt;/h5>
&lt;p>自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$&lt;/p>
&lt;p>更好的思路：&lt;/p>
&lt;p>&lt;strong>DP&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>求长度为 n 的绳子剪掉后的乘积，从 &amp;lt;n 的绳子转移而来&lt;/li>
&lt;li>&lt;code>dp数组&lt;/code> 记录 &lt;code>0到n&lt;/code> 的绳子的最大乘积，初始化 &lt;code>dp[2] = 1&lt;/code>&lt;/li>
&lt;li>剪掉第一段，长度为 j，j &amp;gt; 1&lt;/li>
&lt;li>剪了第一段，剩下长度为 &lt;code>(i - j)&lt;/code> 可以剪或者不剪。不剪的话 &lt;code>length = j * (i - j)&lt;/code>；剪了的话 &lt;code>length = j * dp[i - j]&lt;/code>；&lt;code>max(j * (i - j), j * dp[i - j])&lt;/code>&lt;/li>
&lt;li>遍历 j，$j \in [2, i)$，取最大值。&lt;/li>
&lt;/ul>
&lt;p>难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。&lt;/p>
&lt;p>&lt;strong>2022-03-16 10:38:06&lt;/strong>，尝试写一下 DP 解法 ✔️。DP 和自己的思路性能差不多。&lt;/p>
&lt;p>&lt;strong>贪心&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>均值不等式思想；n &amp;gt; 4 时，尽可能把绳子分为长度为 3 的小段，进行乘加。&lt;/li>
&lt;/ul>
&lt;h3 id="316">3.16&lt;/h3>
&lt;h5 id="jz14-ii-剪绳子">JZ.14-II 剪绳子&lt;/h5>
&lt;p>在 I 的基础上加了一个答案取模，取模对于加法没有影响，~~但是会影响乘法的计算结果。~~并没有，那么这题在考察什么？&lt;/p>
&lt;p>这个题目就是考察贪心的解法，如果继续用 DP，应该会超时&lt;/p>
&lt;h5 id="jz15-二进制中1的个数">JZ.15 二进制中1的个数&lt;/h5>
&lt;p>考察位运算。&lt;/p>
&lt;p>自己的思路：比较基础的 $/2%2$ 进行二进制化，时间复杂度 $O(logn)$，可以AC。bitset&lt;/p>
&lt;p>更好的思路：$n&amp;amp;(n-1)$，$n-1:$ 二进制数字 $n$ 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1；$n&amp;amp;(n - 1):$ 二进制数字 $n$ 最右边的 1 变成 0 ，其余不变。时间复杂度 $O(M)$，M 为 1 的数量&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：位运算&lt;/li>
&lt;/ul>
&lt;h5 id="jz16-数值的整数次方-">JZ.16 数值的整数次方 ❌&lt;/h5>
&lt;p>自己的思路：计算 $pow(x, n)$，naive 直接乘 $n$ 次，时间复杂度 $O(n)$，会超时，因此需要的不是 $O(n)$ 的解法。好像和复杂度没有关系，注意 $n$ 的范围，涉及越界的问题。&lt;/p>
&lt;blockquote>
&lt;p>&lt;del>我认为这个应该就是考察 INT 型表示范围的细节，尤其是 $n = 0 - n$ 这种写法会越界&lt;/del>。看来并非如此&lt;/p>
&lt;/blockquote>
&lt;p>处理了越界仍然会超时，用 $x$ 的范围去换 $n$ 的范围。这样并没有降低时间复杂度的数量级，304 case 全过但是仍然超时。因此猜测 $O(n)$​ 的解法 A 不了。加了一个判断 &lt;code>if(x &amp;lt; 0.000005) return x * init_x;&lt;/code> 后 AC 了，因为输出只保留到小数点后 5 位，有点取巧，虽然 AC 但是可能没有满足这道题的考察意图。⚠️ 这个取巧做法不能算真正的 AC。&lt;/p>
&lt;p>&lt;strong>更好的解法&lt;/strong>：确实有 $O(logn)$ 的解法，&lt;strong>快速幂&lt;/strong>。快速幂也就是在循环中递归地使用你只用了一次的降幂操作，每次可以降幂的时候，$x *= x, n &amp;raquo;= 1$，这样将复杂度降至 $O(logn)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>$(-3) % 2$，余数是 1 还是 -1？答案：余数是 -1&lt;/li>
&lt;li>标签：递归，数学&lt;/li>
&lt;/ul>
&lt;h5 id="jz17-打印从1到最大的n位数">JZ.17 打印从1到最大的n位数&lt;/h5>
&lt;p>自己的思路：遍历，时间复杂度 $O(10^n)$，直接 A，意义在哪？评论区有人说原题目是要考虑大数越界问题的。因此，这道题的本意应该是考察字符串和整型数字的转换。&lt;/p>
&lt;p>先放一下&lt;/p>
&lt;blockquote>
&lt;p>若不考虑大数问题，则十分简单一个从1到最大数的循环即可。 若考虑大数问题，则首先需要将数字转成字符串避免溢出，然后全排列字符串的第0位到第n-1位。 存储结果时需去掉字符串前几位的0(0099没有意义，应为99)再放入结果。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：数组（越界，大数），字符串&lt;/li>
&lt;/ul>
&lt;h5 id="jz18-删除链表的节点">JZ.18 删除链表的节点&lt;/h5>
&lt;p>自己的思路：最简单的单链表删除，时间复杂度 $O(n)$，AC。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：链表&lt;/li>
&lt;/ul>
&lt;h5 id="jz20-表示数值的字符串">JZ.20 表示数值的字符串&lt;/h5>
&lt;p>这个题是有实用性的，也许在某些爬虫提取数据的时候会用到。&lt;/p>
&lt;p>自己的思路：就是用条件判断筛选出不合规的情况 &lt;code>return false&lt;/code>，第一次以为空格直接删除就行，提交后发现空格不能出现在有效符号的中间。&lt;/p>
&lt;p>提交 23 次 AC，基本就是看着 case 补条件，完全没有周全考虑，没有使用正则表达式思想。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：字符串，有限状态机&lt;/li>
&lt;/ul>
&lt;h5 id="jz21-调整数组顺序使奇数位于偶数前面">JZ.21 调整数组顺序使奇数位于偶数前面&lt;/h5>
&lt;p>自己的思路：两次遍历，$O(n)$，AC，有没有复杂度更低的解法？&lt;/p>
&lt;p>题解的思路：也是 $O(n)$ 复杂度，但只用遍历一次，双指针，类似快排的思路。分别从左右开始遍历，然后交换。稍快一点。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：数组，双指针，排序&lt;/li>
&lt;/ul>
&lt;h5 id="jz22-链表中倒数第k个节点">JZ.22 链表中倒数第k个节点&lt;/h5>
&lt;p>自己的思路：打印倒数的节点，所以遍历两次，第一次确定链表长度 L，L - k 次 next 就可以找到目标结果，然后返回，AC，时间复杂度 $O(n)$&lt;/p>
&lt;p>更好的解法：双指针，无需统计链表的长度。前指针先走 $k$ 步，然后共同移动，前指针到终点时返回后指针即可，时间复杂度 $O(n)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：链表，双指针&lt;/li>
&lt;/ul>
&lt;h5 id="jz24-反转链表">JZ.24 反转链表&lt;/h5>
&lt;p>自己的思路：一次遍历，forward 指针在前，head 自己在后，一遍遍历一边调整，AC，时间复杂度 O(n)。&lt;/p>
&lt;p>❌ 注意边界条件，注意条件判断时写了 &lt;code>if(head-&amp;gt;next == NULL || head == NULL)&lt;/code>，报错。因为当 head==NULL，是找不到 head-&amp;gt;next，自己写代码不要忽略边界和细节。&lt;/p>
&lt;p>题解：除双指针，还有递归的解法，时间空间都是 $O(n)$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：递归，链表&lt;/li>
&lt;li>关于递归，心中要有明确的终止条件的概念。&lt;/li>
&lt;/ul>
&lt;h5 id="jz25-合并两个递增排序的链表">JZ.25 合并两个递增排序的链表&lt;/h5>
&lt;p>自己的思路：非常基础的算法题，一次遍历，其中一个链表完成遍历后直接接过去。最初出现错误的原因：遍历的时候 &lt;code>l2 = l2-&amp;gt;next&lt;/code>，忘记保存头结点。&lt;/p>
&lt;p>一开始的合并写法没有 AC，逻辑有点混乱了，后来直接换了一种写法，新建了一个链表，比较耗费空间，时间复杂度 $O(m+n)$，空间复杂度 $O(m+n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：递归，链表&lt;/li>
&lt;li>引入 &lt;strong>伪头结点&lt;/strong> 合并链表是本题的最优解&lt;/li>
&lt;/ul>
&lt;h4 id="317">3.17&lt;/h4>
&lt;h5 id="jz26-树的子结构-">JZ.26 树的子结构 ❌&lt;/h5>
&lt;p>又到了短板，二叉树相关的题目。&lt;/p>
&lt;p>自己的思路：是否会有一段完全相同的中序遍历？中序遍历能否唯一确定？手写中序遍历 DFS，大概的还记得，有些地方比如 visied，还有判断条件（only care left）疏忽了，但是很快能想起来。Value 还存在负数，那么只能前序也 check 一次了。&lt;/p>
&lt;p>check 了一次前序一次中序，但是还是 AC 不了，说明一开始的思路可能有点问题。写出了前序和中序，但是没法 AC，思路是错的。&lt;/p>
&lt;p>更好的解法：遍历 A 树中的每个节点 $n_A$，判断以 $n_A$ 为根节点的字数是否包含 B。状态一般，没有自己手写题解，之后再熟悉一遍。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：树，DFS&lt;/li>
&lt;/ul>
&lt;h5 id="jz27-二叉树的镜像">JZ.27 二叉树的镜像&lt;/h5>
&lt;p>自己的思路：简单递归。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，由递归栈的深度决定.&lt;/p>
&lt;h5 id="jz28-对称的二叉树-">JZ.28 对称的二叉树 ⚠️&lt;/h5>
&lt;p>自己的思路：一开始直接指针指向 root，翻转二叉树，比较，忽略了只是指针指向了 root，没有保留翻转前的树。后来分别使用递归建树、翻转、比较，AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>更好的思路：一次递归，无需求镜像。递归地比较左右子树是否相等即可&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这个题用到和复习的知识点比较多，包括建树。翻转二叉树，比较&lt;/li>
&lt;li>标签：二叉树，BFS，DFS&lt;/li>
&lt;/ul>
&lt;h5 id="jz29-顺时针打印矩阵">JZ.29 顺时针打印矩阵&lt;/h5>
&lt;p>自己的思路：没考虑算法，用循环每次 push 边界上的几组数，然后不断地更新边界条件，直到所有数都 push 进去。注意边界条件。AC，时间复杂度 $o(mn)$，空间复杂度 $O(mn)$。&lt;/p>
&lt;p>题解：和 K 神题解的思想差不多。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，矩阵，模拟&lt;/li>
&lt;/ul>
&lt;h5 id="jz30-包含-min-的栈">JZ.30 包含 min 的栈&lt;/h5>
&lt;p>自己的思路：用 vector 实现，push 的时候对比一下记录 min 即可，关于 vector 的指定 index 删除有点忘记了。&lt;code>v.erase(pos)&lt;/code>。噢，不过突然想起 stack 是先进后出，那么直接 &lt;code>v.pop_back()&lt;/code> 删掉最后一个即可。不过为了更加造轮子，还是不用 STL 了吧，用数组好了。&lt;/p>
&lt;p>还有一个细节，还需要额外保存一个次小值，当 min pop 时需要用次小值顶上。次小值还不够，应该用一个数组记录不同 stack size 时的 min，空间换时间。&lt;/p>
&lt;p>❗ 细节：栈空时要重置 min。&lt;/p>
&lt;p>题解：很多题解都是用辅助栈，不过这题个人主要是尝试用数组求解。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>关于 vector 的指定 index 删除。&lt;code>v.erase(pos)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h5 id="jz31-栈的-push-pop-顺序">JZ.31 栈的 push, pop 顺序&lt;/h5>
&lt;p>也是经典的算法考题，给一个 push 顺序和 pop 顺序，判断 pop 顺序是否有可能是该 push 顺序下的一个 pop 结果。&lt;/p>
&lt;p>自己的思路：插 pop，给出所有可能性然后对比，这样复杂度有点太夸张了。加一点数学思路来优化，假设 push 序列是顺序的，如果 4 pop，那么 4 之后 &amp;lt;4 的元素出栈时一定不可能是升序，比如 1，2，3；推理到元素 i 出栈，之后 $&amp;lt;i$ 的元素出栈序列一定是降序排列。&lt;/p>
&lt;p>不一定是顺序输入，所以可能需要用 hash 转换一下。hash 转换得费点脑子，找找经典的理解方法。注意细节，mmax 更换时 slide_min 便作废了。AC，时间复杂度 $O(n)$，空间复杂度 $O(n)$，用了额外的 hash 空间排序。&lt;/p>
&lt;p>题解：这个题其实蛮有意思，题解完全是另一种做法，自己是利用一些数学/算法上的特征解的。根据 push 序列模拟入栈操作，当栈顶元素 &lt;code>top() == popped[i]&lt;/code> 时出栈元素，i++，push 操作完成观察栈是否空即可。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：栈，数组，模拟&lt;/li>
&lt;li>自己使用到了 hash 思想；栈的基本知识；栈空时调用 s.top() 会报错&lt;/li>
&lt;/ul>
&lt;h5 id="jz32-ii-从上到下打印二叉树">JZ.32-II 从上到下打印二叉树&lt;/h5>
&lt;p>自己的思路：线序遍历，根据 height 来决定 push 到哪一行。其中遇到了 vector 初始化的问题，不初始化没办法直接 &lt;code>v[height].push_back(root-&amp;gt;val)&lt;/code>，先根据上限 &lt;code>v.resize(1000)&lt;/code>，遍历结束后根据深度 &lt;code>v.resize(height+1);&lt;/code> 即可。时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二维 vector 初始化
&lt;ul>
&lt;li>&lt;code>v.resize(4); v[0].resize(4);&lt;/code>&lt;/li>
&lt;li>&lt;code>vector&amp;lt;vecotr&amp;lt;int&amp;gt;&amp;gt; v(m, vector&amp;lt;int&amp;gt;(n, 0))&lt;/code>; m 行 n 列全部初始化为0&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz32-iii-从上到下打印二叉树">JZ.32-III 从上到下打印二叉树&lt;/h5>
&lt;p>和上题区别在于，第一层从左到右打印，第二层从右到左打印，没法先序遍历直接解。&lt;/p>
&lt;p>自己的思路：vector 是否自带 reverse？正好复习一下，&lt;code>reverse(v.begin(), v.end());&lt;/code>，AC。&lt;/p>
&lt;p>不过有评论说这是经典面试0分方法 😓，那认真学习下题解思路。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：树，BFS&lt;/li>
&lt;li>reverse()&lt;/li>
&lt;/ul>
&lt;h4 id="318">3.18&lt;/h4>
&lt;p>2022-03-17 22:45:21，先把两道树的题方法搞了。贪心和 DP 是薄弱点，后期要加强。&lt;/p>
&lt;h4 id="319">3.19&lt;/h4>
&lt;h5 id="606-construct-string-from-binary-tree-每日一题">606. Construct String from Binary Tree 每日一题&lt;/h5>
&lt;p>这道题中文描述简直是 bullshit，还没给范围，之后直接看英文好了。这道题应该是简单吗？虽然确实不太难但是东西还蛮多，涉及先序遍历，数字转字符串等等。&lt;/p>
&lt;p>自己的思路：先序遍历，数字转字符串，可以省略空子树的括号，省略右子树为空仅有左子树时的括号。时间复杂度 $O(n)$&lt;/p>
&lt;p>&lt;strong>彩蛋&lt;/strong>：2020.04.02 AC过，当时直接用的 &lt;code>to_string()&lt;/code>，记一下这个函数。不知道当时是不是看的题解，那个时候写的解法更好一点~&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>树，DFS，字符串&lt;/li>
&lt;/ul>
&lt;h4 id="320">3.20&lt;/h4>
&lt;h5 id="jz33-二叉搜索树的后序遍历-">JZ.33 二叉搜索树的后序遍历 ❌&lt;/h5>
&lt;p>一开始看题目描述蒙了，没有理解其意思。原来是忽略了二叉搜索树这个条件，太久没有接触到所以生疏了，也就是左孩子 value 小于当前节点，右孩子 value 大于当前节点。&lt;/p>
&lt;p>自己的思路：后序遍历建树，后序遍历不能唯一确定，不过二叉搜索树好像是完全二叉树？这点得确认一下，先按照这个假设。然后判断建好的树是否满足搜索树的概念。&lt;/p>
&lt;p>注意：循环中，&lt;code>it&lt;/code> 不能回到 begin，因为 begin 位置上可能还有之前跳过的数字，留在当前位置即可。出现了意料之外的 case，所以搜索树不一定是完全二叉树？确实如此。&lt;/p>
&lt;p>题解思路：遍历顺序 左右根。这个思路之前有想过。后续遍历区间$[i,j]$，遍历划分左右子树区间，找到第一个大于 root 的元素 index $m$，左子树区间 $[i, m-1]$，右子树区间 $[m,j-1]$，递归判断子树的合法性即可。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector：可以使用迭代器作为 &lt;code>v.erase(pos)&lt;/code> 中的 pos 进行删除；删除后 &lt;code>v.size()&lt;/code> 会发生变化.&lt;/li>
&lt;li>二叉搜索树的概念，正是因为记错了所以思路出现了问题。&lt;/li>
&lt;li>后续遍历的性质，左右根，左右子树的区间&lt;/li>
&lt;li>标签：栈，树，二叉搜索树，递归，单调栈&lt;/li>
&lt;/ul>
&lt;h4 id="326">3.26&lt;/h4>
&lt;h5 id="jz-19-正则表达式匹配-">JZ. 19 正则表达式匹配 ❌&lt;/h5>
&lt;p>自己的思路：考虑所有情况，硬配。写了一个多小时还是考虑不全所有情况，这是一种冗余分类的思路，还没有概括完所有情况。遂看题解，发现原来这也能DP。&lt;/p>
&lt;p>题解的思路：拆分子问题&lt;/p>
&lt;ul>
&lt;li>B 的最后一个字符为正常字符串， 比较 $A_{n-1}$ 和 $B_{m-1}$，如果相等则继续比较 $A_{0..n-2}$ 和 $B_{0..m-2}$，不相等则返回 false&lt;/li>
&lt;li>如果 B 的最后一个字符串为 &lt;code>.&lt;/code>，则比较 $A_{0..n-2}$ 和 $B_{0..m-2}$&lt;/li>
&lt;li>如果 B 的最后一个字符串为 &lt;code>*&lt;/code>，则 $B_{m-2} = c$ 可以重复0次或多次
&lt;ul>
&lt;li>case 1：$A_{n-1}$ 是0个c，舍弃 B 中的 &lt;code>c*&lt;/code>，比较 $A_{0..n-1}$ 和 $B_{0..m-3}$&lt;/li>
&lt;li>case 2：$A_{n-1}$ 是多个c中的最后一个，比较 $A_{0..n-2}$ 和 $B_{0..m-1}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>转移方程&lt;/strong>&lt;/p>
&lt;p>$f[i][j]$ 代表 A 的前 $i$ 个和 B 的前 $j$ 个能否匹配&lt;/p>
&lt;ul>
&lt;li>对于前两种情况可以进行合并，$f[i][j] = f[i-1][j-1]$
&lt;ul>
&lt;li>第三种情况，$f[i][j] = f[i][j-2]$，case 2: $f[i][j] = f[i-1][j]$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>初始条件&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>空串和空正则可以匹配，$f[0][0] = true$&lt;/li>
&lt;li>空串和非空正则，需要判断&lt;/li>
&lt;li>非空串和空正则，不匹配，$f[1][0]&amp;hellip;f[n-1][0]=false$&lt;/li>
&lt;li>非空串和非空正则，需要判断&lt;/li>
&lt;/ul>
&lt;p>看题解后自己写：没有正确理解，不是倒着来的，本质上还是正常动态规划的求解过程。用的是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; j&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不需要双指针同步推进&lt;/p>
&lt;p>2022-03-27 10:22:03，有点绕，之后再来一遍，看懂了再自己写&lt;/p>
&lt;h5 id="jz-35-复杂链表的复制">JZ. 35 复杂链表的复制&lt;/h5>
&lt;p>自己的思路：先通过&lt;del>递归遍历原链表&lt;/del>，修改了一下，实际无需递归，直接遍历即可。此时 random 指针还没有赋值。第二次遍历复制链表，用 traver_cpoy 指针一一为每个节点找 random 指针应该指向的节点。怎么找？双指针一同遍历 init 链表和 copy 链表，当 init 链表到达当前节点的 random 后停止，copy 指针也跟着停止，此时 copy 指针的位置就是 traver_copy 指针节点的 random 节点。AC，时间复杂度 $O(n^2)$。&lt;/p>
&lt;p>更好的思路：hash map 映射，这个能够加深对于 hash 的应用上的理解。第一次遍历构造新节点时，以 hash 的形式存下 init 和 copy 对应节点的指针 &lt;code>map&amp;lt;*Node, *Node&amp;gt; hash_m&lt;/code>，第二次遍历构造 copy 链表的 random，init 指向 &lt;code>head-&amp;gt;random&lt;/code>，通过 &lt;code>head-&amp;gt;random&lt;/code> 以及 hash，可以查找到 copy random &lt;code>hash_m[head-&amp;gt;random]&lt;/code>，&lt;code>copy-&amp;gt;random = hash_m[head-&amp;gt;random]&lt;/code>。时间复杂度 $O(n)$，空间复杂度 $O(n)$。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>注意复制链表需要新建节点，&lt;code>Node* tmp = new Node(val);&lt;/code>，不然指针连接到之前的链表上，就违背了复制的意图。&lt;/li>
&lt;li>原来这个就是&lt;strong>深拷贝&lt;/strong>的一个例子&lt;/li>
&lt;li>标签：hash，链表&lt;/li>
&lt;/ul>
&lt;h5 id="jz-36-二叉搜索树与双向链表">JZ. 36 二叉搜索树与双向链表&lt;/h5>
&lt;p>自己的思路：刚学的 hash 的思想似乎可以用上。中序遍历把节点的指针存入数组 &lt;code>vector&amp;lt;Node*&amp;gt; ans&lt;/code>，此时 ans 中的指针是有序的。遍历 ans 数组，重新调整节点 &lt;code>left&lt;/code> 和 &lt;code>right&lt;/code> 指针的指向即可。AC。&lt;/p>
&lt;p>和题解思路一致&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>栈，DFS，二叉树，双向链表&lt;/li>
&lt;li>主要是利用了 二叉搜索树 中序遍历后有序的性质&lt;/li>
&lt;/ul>
&lt;h5 id="jz37-序列化二叉树">JZ.37 序列化二叉树&lt;/h5>
&lt;p>序列化函数：也就是将二叉树以 string 的形式存起来。反序列化函数：将 string 构造为二叉树&lt;/p>
&lt;p>自己的思路：想到的还是 hash 的形式，把节点的指针存下来。得到了中序和前序遍历的序列，然后就是根据中序和前序遍历建树&lt;/p>
&lt;p>2022-03-31 22:13:41 的思路：有什么东西不重复呢？一开始想到了随机数，但是其实还有有风险，地址应该是不重复的。注意索引越界的问题&lt;/p>
&lt;p>建树：注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。忘了加参数 inorder_left 和 inorder_right&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>整型转字符串：&lt;code>itoa(int num, char* str, int radix)&lt;/code>&lt;/li>
&lt;li>字符串，&lt;code>char str = 'a'; str += 1&lt;/code>，可以直接加整型，此时 &lt;code>str = 'b';&lt;/code>&lt;/li>
&lt;li>map 如何通过 value 查找 key&lt;/li>
&lt;/ul>
&lt;h4 id="331">3.31&lt;/h4>
&lt;h5 id="728-自除数-每日一题">728. 自除数 每日一题&lt;/h5>
&lt;p>每日打卡，简单题，没什么亮点。&lt;/p>
&lt;h4 id="43">4.3&lt;/h4>
&lt;h5 id="每日一题">每日一题&lt;/h5>
&lt;h5 id="jz38-字符串的排序-">JZ.38 字符串的排序 ❌&lt;/h5>
&lt;p>自己的思路：双重循环，swap，set来去重。时间复杂度 $O(n^2)$。❌这种方法覆盖不了所有情况。20分钟没有思路&lt;/p>
&lt;p>题解的思路：递归回溯填空位的思想。递归回去时，使用过的字符串标记也会回溯。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>❗ 本以为把 visit 数组当做参数传进去，return 的时候自动回溯，没想到也需要手动回溯。&lt;/li>
&lt;li>突然想起来，要用引用传参。也不全是，只是突然想起来引用传参这个知识点。&lt;/li>
&lt;/ul>
&lt;h5 id="jz39-数组中出现次数超过一半的数字">JZ.39 数组中出现次数超过一半的数字&lt;/h5>
&lt;p>自己的思路：这个题之前应该是遇到过。最直接的方法就是遍历然后填充 hash 表，之后简单地判断，时间复杂度 $O(n)$，空间复杂度 $O(n)$。印象中有时间复杂度更低的解法，分治的思想之类的。想起来是排序之后找中间那个元素，&lt;del>时间复杂度 $O(logn)$&lt;/del>,oh，原来排序的时间复杂度是 $O(nlogn)$&lt;/p>
&lt;h5 id="jz40-最小的k个数-">JZ.40 最小的k个数 ❌&lt;/h5>
&lt;p>自己的思路：排序后遍历，这样做没有意义，直接看题解。&lt;/p>
&lt;p>题解：基于快排的特点。快排时每次都能把 pivot 放在他最终的位置。当结束一次快排，pivot 正好在 $index_k$ 时，返回数组的前 $k$ 个数即可。&lt;/p>
&lt;p>对快排特点的应用。&lt;/p>
&lt;p>❌ 忘记了快排的写法，这个题卡了1个小时的原因，在于你完全不会手写快排。如同上次蔚来面试答不出快排一样。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>看了题解之后还是折腾了1个小时；完全是因为快排写错了。&lt;/li>
&lt;/ul>
&lt;h4 id="44">4.4&lt;/h4>
&lt;h5 id="307-">307 ❌&lt;/h5>
&lt;p>线段树、树状数组踩坑，明天来学习&lt;/p>
&lt;p>自己的思路：用一个 hash，&lt;code>hash[i]&lt;/code> 存的是数组前 &lt;code>i+1&lt;/code> 个元素之和，查找时复杂度为 $O(1)$，update 时复杂度为 $O(n)$，这个级别的复杂度达不到要求，需要更好的方法。遂看题解。&lt;/p>
&lt;p>题解思路：分块处理，把时间复杂度优化到 $O(\sqrt{n})$；线段树，其实就是把一个完整的区间划分，左右子树分别是根节点的子区间。树节点保存的值为区间内的元素和，线段树看下图会很清晰。首先根据区间建树，用堆来存储更好。递归回退的时候计算每个节点的 val（也就是区间和），这个思路值得学习。&lt;/p>
&lt;p>2022-04-05 14:17:41，做得一团 bullshit，又浪费了一个小时，坑还是剩下，不要抄代码强行提交，先去写论文了。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>vector 还可以不使用 push，直接 index 吗？&lt;/li>
&lt;/ul>
&lt;h4 id="45">4.5&lt;/h4>
&lt;h5 id="762">762&lt;/h5>
&lt;p>自己的思路：判断质数函数一个，对于整数&lt;code>num&lt;/code>，从 2 遍历到 &lt;code>num/2&lt;/code>，没有整除就是质数，时间复杂度 $O(n)$；统计 bit 为1数量的函数，移位并计数，时间复杂度 $O（logn）$。AC&lt;/p>
&lt;h5 id="5-最长回文子串">5. 最长回文子串&lt;/h5>
&lt;p>经典DP&lt;/p>
&lt;p>自己的思路：秒不了，想不出DP，直接题解。&lt;/p>
&lt;p>题解：中心扩散法，这个比较好理解，主要是来学习DP。&lt;/p>
&lt;blockquote>
&lt;p>动态规划就是为了减少重复计算的问题。动态规划听起来很高大上。其实说白了就是空间换时间，将计算结果暂存起来，避免重复计算。&lt;/p>
&lt;/blockquote>
&lt;h5 id="每日-310-最小高度树">每日 310. 最小高度树&lt;/h5>
&lt;p>自己的思路：就是找一个节点，遍历所有节点的深度最小。建表之后dfs，写出了dfs解法，超时，需要优化。还是超时，遂先放弃。&lt;/p>
&lt;h4 id="415">4.15&lt;/h4>
&lt;h5 id="jz41-数据流中的中位数">JZ.41 数据流中的中位数&lt;/h5>
&lt;p>自己的思路：这道题的瓶颈在于排序，无论是插入时排序，还是找中位数时排序，如果每次 call 都进行一次排序，一定会超时。也许需要一颗平衡二叉排序树，把插入时排序的开销降低到 $O(logn)$。&lt;/p>
&lt;p>以为需要建堆，看题解之后AC。但是直接用的现成的优先队列，并且是看的题解，这道题几乎没有自己想的部分。&lt;/p>
&lt;p>题解：大顶堆，小顶堆。小顶堆 A 保存较大的一半数据（size = m），大顶堆 B 保存较小的一般数据（size = n）。插入时优先插入到 A，即：&lt;/p>
&lt;p>m = n，把新元素加到 A：把新元素 num 插入 B，再将 B 的堆顶插入 A。查找：返回 A 和 B 的堆顶之和 / 2&lt;/p>
&lt;p>m != n，把新元素加到 B：把新元素 num 插入 A，再将 A 的堆顶插入 B。返回 A 的堆顶&lt;/p>
&lt;p>为什么用优先队列实现大顶堆？什么事优先队列？优先队列是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;p>C++中的优先队列实现。不过要注意，直接用现成的轮子，建堆的过程其实还是不会的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>priority_queue&lt;span style="color:#f92672">&amp;lt;&lt;/span>Type, Container, Functional&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//升序队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>priority_queue &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,greater&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> q;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//降序队列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>priority_queue &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>,vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>,less&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span>q;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>堆（优先队列），数据流，排序，双指针&lt;/li>
&lt;/ul>
&lt;h5 id="jz42-连续子数组的最大和">JZ.42 连续子数组的最大和&lt;/h5>
&lt;p>自己的思路：经典的DP来了，练习DP的机会来了。这个似乎就是那位同学说的商汤2面的编程题。dp[i] 存放以 index i 为右边界的数组的最大和。&lt;/p>
&lt;p>2022-04-15 18:03:47，果然没有想出来，和我自己想的不太一样。写 dp 方程的时候没考虑到需要连续这一特性。要接受自己的愚蠢，看答案。&lt;/p>
&lt;p>思路绕进去了，一直在想 dp[i] 小于0不一定不能加；实际上自己想的是 nums[i] 小于0不一定不能加。而 dp[i] 如果小于0，说明以 i 为右边界的数组的连续子数组最大和为负数，故可以直接舍弃。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，分治，DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz43-1n-整数中-1-出现的次数">JZ.43 1～n 整数中 1 出现的次数&lt;/h5>
&lt;p>自己的思路：首先尝试暴力的方法，遍历，把int转为char，统计1的数量。itoa 还是用不了，找到了替代，sprintf。暴力法必然超时，打表应该是通过的方法之一，这样需要预处理。没有使用打表的方式，以10000为步长来计算。一次AC，nice（2022-04-15 20:44:01），虽然这道题可能算不上困难。&lt;/p>
&lt;ul>
&lt;li>递归，数学规律，DP&lt;/li>
&lt;/ul>
&lt;h5 id="jz44-数字序列中某一位的数字-">JZ.44 数字序列中某一位的数字 ❌&lt;/h5>
&lt;p>自己的思路：实际上就是构造这个序列化字符串。这个字符串长度大于n时跳出即可。承接上一题，还是继续使用 sprintf。atoi 格式忘记了。&lt;/p>
&lt;p>2022-04-16 19:50:05，先放一放，往后做&lt;/p>
&lt;h4 id="416">4.16&lt;/h4>
&lt;h5 id="jz45-把数组排成最小的数-">JZ.45 把数组排成最小的数 ❌&lt;/h5>
&lt;p>自己的思路：排序后遍历，因为数字都是100以内，先拼接小的即可，拼接22之前先拼接2，拼接33之前先拼接3。晕，看错条件了，说的是 nums 长度小于 100。&lt;/p>
&lt;p>没有A，看题解了。这道题也是有一些数学的规律，自定义字符串的排序规则。字符串排序规则，若 $x + y &amp;gt; y + x$，说明 y 应该放在左边。&lt;/p>
&lt;p>除了 sprinft，还可以用 to_string(INT);&lt;/p>
&lt;h4 id="417">4.17&lt;/h4>
&lt;h5 id="jz46-数字翻译成字符串">JZ.46 数字翻译成字符串&lt;/h5>
&lt;p>自己的思路：感觉是一个标准的 DP 问题。判断两数是否能组合时，要注意一些边界条件上的细节。时间复杂度 $O(n)$。实际上就是青蛙跳台阶的思路。&lt;/p>
&lt;p>2022-04-17 22:10:46，成功AC。这个是刷 LeetCode DP 问题的一个里程碑。标志着你也许能够独立做出一些 DP 问题了。&lt;/p>
&lt;p>初始状态：以 0 结尾的字符串，有1种翻译&lt;/p>
&lt;p>状态：以 i 结尾的字符串，有多少种翻译；~$dp[i] = dp[i-1] + 1（单加一个） + if_combined$~ （i 和 i - 1 是否能够组合在一起）。
应该没有这个 +1，并非叠加，$dp[i] = dp[i-1] + if_combined$&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>个人认为关于 DP，有个很关键的地方是，从初始态出发必须能够到达当前状态，他们是有桥梁的，因为每一步都伴随着信息的更新。&lt;/li>
&lt;/ul>
&lt;h5 id="jz47-礼物的最大价值">JZ.47 礼物的最大价值&lt;/h5>
&lt;p>自己的思路：感觉是一个和棋盘/二维数组相关的 DP 问题。边界问题补一层 padding，因为 value 非负，直接初始化为0即可。AC，比较简单的 DP 问题。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>数组，DP，矩阵&lt;/li>
&lt;/ul>
&lt;h5 id="jz48-最长不含重复字符的子字符串">JZ.48 最长不含重复字符的子字符串&lt;/h5>
&lt;p>自己的思路：最自然的是暴力法，遍历字符串，往后找其第一个重复的串，记录长度，时间复杂度 $O(n^2$。第一个思路有问题，这个思路不太行。明天来做，2022-04-17 23:39:50。&lt;/p>
&lt;p>2022-04-18 11:51:19，AC，做了比较久，做了接近一个小时。总算绕通了其中的逻辑。自己用的应该是双指针遍历的方法，用 hash_map 存出现过的字符串，遇到重复时更新左边的指针，以及舍弃掉此重复字符串左边的字符串。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>标签：滑动窗口，字符串，hash&lt;/li>
&lt;/ul>
&lt;h5 id="每日一题-819-最常见的单词">每日一题 819. 最常见的单词&lt;/h5>
&lt;p>自己的思路：没什么思路，直接遍历，hash 表存出现的次数，大写转小写。我记得是有大小写转换的函数的，不过忘记了，手动转一下吧。ASCII 差值搞忘了，好像是32？可以建个表。确实是32，还算记得，不用建表了。AC，逻辑有点不清晰，花了大概30分钟。20年4月做过这道题。&lt;/p>
&lt;h4 id="418">4.18&lt;/h4>
&lt;h5 id="每日一题-386-lexicographical-numbers-">每日一题 386. Lexicographical Numbers ❌&lt;/h5>
&lt;p>自己的思路：要求时间复杂度 $O(n)$，也就是一次遍历。n &amp;lt; 10 时直接返回 1-n，否则标记 1-9，后续遇到 1 开头的数就插入到 1 后面，然后标记，遇到 2 开头的数就插入到 2 后面，然后标记。不过 vector 插入的时间复杂度好像是 $O(n)$，这样的话整体就是 $O(n^2)$ 了。&lt;/p>
&lt;p>15分钟没有思路，上题解。看了一部分评论之后有一个思路，应该将其转换为字符串，这样就无需考虑整数的顺序问题。&lt;/p>
&lt;p>题解：迭代 DFS 的思想。对于数 number，加入数组，判断 $10*number \leq n$ 是否成立，如果成立则加入数组，并继续搜索（DFS）；如果不成立，判断 $number + 1$ 的情况，如果 number 的个位数为9（number 个位数1-9已经全部搜索过了）或者 number + 1 &amp;gt; n（DFS返回条件），则回退到上一层（number /= 10）&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;p>标签：DFS，前缀树&lt;/p>
&lt;h5 id="jz49-丑数-">JZ.49 丑数 ❌&lt;/h5>
&lt;p>自己的思路：已知是一道DP。看题解&lt;/p>
&lt;p>题解：核心思想是后面的丑数一定由前面的丑数乘以2，或者乘以3，或者乘以5得来。在这个基础上可以使用最小堆，每次取出堆顶元素 xx，则 xx 是堆中最小的丑数，由于 2x, 3x, 5x2x,3x,5x 也是丑数，因此将 2x, 3x, 5x2x,3x,5x 加入堆，然后去重。&lt;/p>
&lt;p>方法二：DP 三指针。令 $\textit{dp}[i]=\min(\textit{dp}[p_2] \times 2, \textit{dp}[p_3] \times 3, \textit{dp}[p_5] \times 5)$，被使用到的对应指针++。&lt;/p>
&lt;p>&lt;code>dp[i] = min(min(n2, n3), n5);&lt;/code> 学到了&lt;/p>
&lt;h4 id="419">4.19&lt;/h4>
&lt;h5 id="每日一题-821字符的最短距离">每日一题 821.字符的最短距离&lt;/h5>
&lt;p>自己的思路：第一次遍历记录字符的所有下标，第二次遍历找出当前字符 - 下标集合的最小值。时间复杂度最坏 $O(n^2)$。AC&lt;/p>
&lt;p>更好的思路：两次遍历。从左往右，一边遍历一遍更新字符idx；从右往左再来一次。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>int ans[] = new int(len);&lt;/code> 写法有问题，注意是：&lt;code>int *ans = new int[len]{0};&lt;/code>，一定是指针形式&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vector 初始化：&lt;code>vector&amp;lt;int&amp;gt; ans(len);&lt;/code> 以及 &lt;code>vector&amp;lt;int&amp;gt; ans; ans.resize(len);&lt;/code>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h5 id="jz50-第一个只出现一次的字符">JZ.50 第一个只出现一次的字符&lt;/h5>
&lt;p>自己的思路：hash，两次遍历。&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这道题有一个比较好奇的地方，map 中元素顺序是否是按加入的顺序；噢，map 似乎是自动排序的，根据 first 排序&lt;/li>
&lt;/ul>
&lt;h5 id="jz51--数组中的逆序对-">JZ.51 数组中的逆序对 ❌&lt;/h5>
&lt;p>自己的思路：这是一个 hard 题，最自然的想法是暴力法，$o(n^2)$，很自然地，超时。换一种思路，DP，dp[i] 代表位置 i 之前有 dp[i] 个大于 nums[i] 的数。看题解&lt;/p>
&lt;p>题解：归并排序和逆序对息息相关，归并排序体现了分治的思想。归并的同时顺便统计信息。&lt;/p>
&lt;p>PS：着题解代码写得&lt;/p>
&lt;p>&lt;strong>知识点&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>二分查找，归并排序，分治，树状数组，线段树&lt;/li>
&lt;/ul>
&lt;h5 id="jz50-两个链表的第一个公共节点">JZ.50 两个链表的第一个公共节点&lt;/h5>
&lt;p>自己的思路：题目要求尽量用时间复杂度 $O(n)$，空间复杂度 $O(1)$，&lt;/p></description></item><item><title>tmux: Linux 下终端复用</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</link><pubDate>Wed, 16 Mar 2022 08:56:32 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%B8%8B%E7%BB%88%E7%AB%AF%E5%A4%8D%E7%94%A8_tmux/</guid><description>&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>个人理解：最重要的思想感觉是将 session 和终端分离，这样的话退出终端时不会中断 session 以及里面的任务，session 还是在后台运行。最重要的是，下次进入终端时可以连接 session，使得可以还原上一次退出时的状态，且后台任务不会中断。&lt;/p>
&lt;p>前缀键：Ctrl + B，用&lt;code>&amp;lt;prefix&amp;gt;&lt;/code>表示。比如&lt;code>&amp;lt;prefix&amp;gt; %&lt;/code>表示先按&lt;code>Ctrl&lt;/code>，再按&lt;code>B&lt;/code>键，再&lt;code>%&lt;/code>键，其完成的功能就是竖直分屏。&lt;/p>
&lt;h3 id="01-安装启动退出">0.1 安装、启动、退出&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ sudo apt-get install tmux
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux &lt;span style="color:#75715e">#进入 Tmux 窗口，底部状态栏左侧是窗口信息（编号和名称），右侧是系统信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$exit &lt;span style="color:#75715e">#或者 ctrl + d，退出&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="1-基本概念">1. 基本概念&lt;/h2>
&lt;!-- raw HTML omitted -->
&lt;h3 id="11-session">1.1 Session&lt;/h3>
&lt;p>会话(session): 建立一个 tmux 工作区会话，会话可以长期驻留，重新连接服务器不会丢失，我们只需重新 tmux attach 到之前的工作区就可以恢复会话&lt;/p>
&lt;p>Session 一大特点：打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也随之结束&lt;/p>
&lt;p>基于这个 Motivation，为了解决这种关闭窗口工作丢失的问题，会话和窗口可以解绑。窗口关闭时，会话并不会终止，而是继续运行，有需要的时候（理解为需要交互的时候）再让会话绑定其他窗口。&lt;/p>
&lt;p>窗口(window): 容纳多个窗格&lt;/p>
&lt;p>窗格(pane): 可以在窗口中分成多个窗格&lt;/p>
&lt;h3 id="12-tmux">1.2 Tmux&lt;/h3>
&lt;p>Tmux 就是让会话与窗口解绑的工具&lt;/p>
&lt;ul>
&lt;li>可以在单个窗口中同时访问多个会话。对于同时运行多个命令行程序很有用&lt;/li>
&lt;li>可以让新窗口 接入 已存在的会话&lt;/li>
&lt;li>允许每个会话有多个连接窗口，可以多人实时共享会话&lt;/li>
&lt;li>支持窗口任意的垂直和水平拆分&lt;/li>
&lt;/ul>
&lt;h2 id="1-session">1. Session&lt;/h2>
&lt;h3 id="11-new">1.1 new&lt;/h3>
&lt;p>第一个启动的 Tmux 窗口，编号是&lt;code>0&lt;/code>，第二个窗口的编号是&lt;code>1&lt;/code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。&lt;/p>
&lt;blockquote>
&lt;p>这里指的是不同会话的窗口？&lt;/p>
&lt;/blockquote>
&lt;p>使用编号区分会话，不太直观，更好的方法是为会话起名。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>$ tmux new -s &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令新建一个指定名称的会话。&lt;/p>
&lt;h3 id="12-detach">1.2 Detach&lt;/h3>
&lt;p>在 Tmux 窗口中，按下&lt;code>&amp;lt;prefix&amp;gt; d&lt;/code>或者输入&lt;code>tmux detach&lt;/code>命令，就会将当前会话与窗口分离。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ tmux detach
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。&lt;/p>
&lt;h3 id="13-查看会话">1.3 查看会话&lt;/h3>
&lt;p>&lt;code>tmux ls&lt;/code>命令可以查看当前所有的 Tmux 会话。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ tmux ls
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># or&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux list-session
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="14-attach-kill-switch">1.4 Attach, Kill, Switch&lt;/h3>
&lt;p>&lt;code>tmux attach&lt;/code>命令用于重新接入某个已存在的会话。&lt;/p>
&lt;p>&lt;code>tmux kill-session&lt;/code>命令用于杀死某个会话。&lt;/p>
&lt;p>&lt;code>tmux switch&lt;/code>命令用于切换会话。&lt;/p>
&lt;p>&lt;code>tmux rename-session&lt;/code>命令用于重命名会话。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用会话编号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux attach -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux kill-session -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux switch -t &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用会话名称&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux attach -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux kill-session -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux switch -t &amp;lt;session-name&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#重命名&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ tmux rename-session -t &lt;span style="color:#ae81ff">0&lt;/span> &amp;lt;new-name&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-快捷键">2. 快捷键&lt;/h2>
&lt;h3 id="21-session">2.1 Session&lt;/h3>
&lt;p>下面是一些会话相关的快捷键。&lt;/p>
&lt;ul>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; d&lt;/code>：分离当前会话。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; s&lt;/code>：列出所有会话。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; $&lt;/code>：重命名当前会话。&lt;/li>
&lt;/ul>
&lt;h3 id="22-window">2.2 Window&lt;/h3>
&lt;ul>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; c&lt;/code>：创建一个新窗口，&lt;a href="https://www.zhihu.com/search?q=%E7%8A%B6%E6%80%81%E6%A0%8F&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A261206348%7D">状态栏&lt;/a>会显示多个窗口的信息。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; p&lt;/code>：切换到上一个窗口（按照状态栏上的顺序）。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; n&lt;/code>：切换到下一个窗口。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt;&lt;/code>：切换到指定编号的窗口，其中的``是状态栏上的&lt;a href="https://www.zhihu.com/search?q=%E7%AA%97%E5%8F%A3%E7%BC%96%E5%8F%B7&amp;amp;search_source=Entity&amp;amp;hybrid_search_source=Entity&amp;amp;hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A261206348%7D">窗口编号&lt;/a>。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; w&lt;/code>：从列表中选择窗口。&lt;/li>
&lt;li>&lt;code>&amp;lt;prefix&amp;gt; ,&lt;/code>：窗口重命名。&lt;/li>
&lt;/ul>
&lt;h2 id="3-常用">3. 常用&lt;/h2>
&lt;h3 id="31-翻屏">3.1 翻屏&lt;/h3>
&lt;ul>
&lt;li>进入tmux翻屏模式:先按&lt;code>ctrl ＋ｂ&lt;/code>，松开，然后再按&lt;code>[&lt;/code>&lt;/li>
&lt;li>操作同vim：jkhl上下左右&lt;/li>
&lt;/ul>
&lt;h3 id="32-最简操作">3.2 最简操作&lt;/h3>
&lt;ol>
&lt;li>新建会话&lt;code>tmux new -s my_session&lt;/code>。&lt;/li>
&lt;li>在 Tmux 窗口运行所需的程序。&lt;/li>
&lt;li>按下快捷键 d 将会话分离。&lt;/li>
&lt;li>下次使用时，重新连接到会话&lt;code>tmux attach -t my_session&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="4-设置">4. 设置&lt;/h2>
&lt;h3 id="41-启用鼠标滚轮">4.1 启用鼠标滚轮&lt;/h3>
&lt;p>Ctrl + b，然后输入&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ setw mode-mouse on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/261206348">https://zhuanlan.zhihu.com/p/261206348&lt;/a>&lt;/p></description></item><item><title>Vim 中常用的操作</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</link><pubDate>Wed, 16 Mar 2022 08:54:13 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_vim%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E6%93%8D%E4%BD%9C/</guid><description>&lt;p>&lt;strong>Vim 中常用的操作&lt;/strong>&lt;/p>
&lt;p>复制、删除中，定位的逻辑都是对应的，找最后一行 G，找第一行 1G，找行首 0，找行尾 $&lt;/p>
&lt;h4 id="复制粘贴">复制/粘贴&lt;/h4>
&lt;p>复制&lt;strong>当前行&lt;/strong>之后的内容，&lt;code>yG&lt;/code>&lt;/p>
&lt;p>复制第一行到当前行，&lt;code>y1G&lt;/code>&lt;/p>
&lt;p>复制当前行，&lt;code>dd&lt;/code>；向下复制 10 行，&lt;code>10dd&lt;/code>&lt;/p>
&lt;p>复制游标到行首/行尾，&lt;code>y0&lt;/code>/&lt;code>y$&lt;/code>&lt;/p>
&lt;p>粘贴在光标下/上一行，&lt;code>p&lt;/code>/&lt;code>P&lt;/code>&lt;/p>
&lt;h4 id="删除">删除&lt;/h4>
&lt;p>删除&lt;strong>当前行&lt;/strong>之后的内容&lt;/p>
&lt;ul>
&lt;li>光标定位到某行，&lt;code>:,$d&lt;/code>，&lt;code>dG&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>删除第一行到当前行&lt;/p>
&lt;ul>
&lt;li>&lt;code>1,.d&lt;/code>，&lt;code>d1G&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>删除当前行，&lt;code>dd&lt;/code>；向下删除 10 行，&lt;code>10dd&lt;/code>&lt;/p>
&lt;p>向后/向前删除 10 个字符，&lt;code>10x&lt;/code>/&lt;code>10X&lt;/code>&lt;/p>
&lt;p>删除游标到行首/行尾，&lt;code>d0&lt;/code>/&lt;code>d$&lt;/code>&lt;/p>
&lt;p>恢复上一个动作（类似 Ctrl + Z）,&lt;code>u&lt;/code>&lt;/p>
&lt;p>重做上一个动作（往前恢复），&lt;code>ctrl + r&lt;/code>&lt;/p>
&lt;p>重复上一个动作（再做一次），&lt;code>.&lt;/code>&lt;/p>
&lt;h4 id="跳转移动">跳转/移动&lt;/h4>
&lt;p>跳转到指定&lt;strong>第x行&lt;/strong>，&lt;code>:x&lt;/code>&lt;/p>
&lt;p>跳转到文件最后一行，&lt;code>shift + g&lt;/code>、&lt;code>G&lt;/code>、&lt;code>:$&lt;/code>&lt;/p>
&lt;p>跳转到文件第一行，&lt;code>gg&lt;/code>&lt;/p>
&lt;p>跳转到下一页，&lt;code>ctrl + f (forward)&lt;/code>&lt;/p>
&lt;p>跳转到上一页，&lt;code>ctrl + b (back)&lt;/code>&lt;/p>
&lt;p>向下移动 30 行，&lt;code>30j&lt;/code>，&lt;code>30 &amp;lt;Enter&amp;gt;&lt;/code>&lt;/p>
&lt;p>向右移动 20 个字符，&lt;code>20 &amp;lt;space&amp;gt;&lt;/code>，&lt;!-- raw HTML omitted --> 为空格&lt;/p>
&lt;p>⭐ 移动到当前行首/尾，&lt;code>0 or [home]&lt;/code>/&lt;code>$ or [End]&lt;/code>&lt;/p>
&lt;h4 id="搜索">搜索&lt;/h4>
&lt;p>查找 &lt;code>/&lt;/code>&lt;/p>
&lt;p>统计字符串数量，&lt;code>:%s/GTO://gn&lt;/code>&lt;/p></description></item><item><title>编译运行ISPASS2009、Rodinia、Parboil</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</link><pubDate>Wed, 08 Dec 2021 09:45:02 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cbenchmarkispassrodiniaparboil/</guid><description>&lt;h1 id="ispass">ISPASS&lt;/h1>
&lt;p>Ubuntu20.04下使用GPGPU-Sim运行ISPASS2009benchmark&lt;/p>
&lt;h2 id="0-前言">0. 前言&lt;/h2>
&lt;p>之前介绍了安装，现在就尝试跑一下 ISPASS'09 的那篇经典 paper，Analyzing CUDA workloads using a detailed GPU simulator 上的几个 benchamrk. 这篇文章1.现在已经870次引用了，很多工作都使用了其中的 benchmark&lt;/p>
&lt;h2 id="1-安装-cuda-toolkit-and-cuda-sdk">1. 安装 CUDA Toolkit and CUDA SDK&lt;/h2>
&lt;p>CUDA 5之后，SDK 和 Toolkit 都在一个包里面，可以参考 XX 中安装 CUDA 的步骤，在安装时除了 Toolkit 以外再勾选上 &lt;code>CUDA Samples 11.1&lt;/code>。ISPASS'09 benchmark 会用到 build CUDA SDK 时创建的库，所以需要 CUDA SDK。&lt;/p>
&lt;blockquote>
&lt;p>But, it looks like NVIDIA has messed up the webpages a bit, the CUDA Toolkit and the GPU Computing SDK pages point at each other, with neither offering the SDK.&lt;/p>
&lt;/blockquote>
&lt;p>所以看起来是需要切换 CUDA 版本&lt;/p>
&lt;h3 id="11-更换软链接">1.1 更换软链接&lt;/h3>
&lt;p>不过之前环境变量用的 cuda11.1 的地址而非软链接，现在替换成软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /usr/local/cuda &lt;span style="color:#75715e">#删除之前生成的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda &lt;span style="color:#75715e">#生成新的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-check-环境变量的地址">1.2 Check 环境变量的地址&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export CUDA_INSTALL_PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/cuda/toolkit/4.2/cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$CUDA_INSTALL_PATH/bin:$MPI_ROOT/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LD_LIBRARY_PATH&lt;span style="color:#f92672">=&lt;/span>$LD_LIBRARY_PATH:$CUDA_INSTALL_PATH/lib64 &lt;span style="color:#75715e">#这个不用改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export NVIDIA_COMPUTE_SDK_LOCATION&lt;span style="color:#f92672">=&lt;/span>~/cuda/sdk/4.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="13-查看版本信息">1.3 查看版本信息&lt;/h3>
&lt;p>上述步骤全部没问题就可以弹出版本信息了，&lt;code>source ~/.bashrc&lt;/code> 或者重启终端&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nvcc: NVIDIA &lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Cuda compiler driver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Copyright &lt;span style="color:#f92672">(&lt;/span>c&lt;span style="color:#f92672">)&lt;/span> 2005-2012 NVIDIA Corporation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built on Thu_Apr__5_00:24:31_PDT_2012
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cuda compilation tools, release 4.2, V0.2.1221
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-gcc-g-版本">2. gcc, g++ 版本&lt;/h2>
&lt;p>CUDA 更换为4.2版本后，重新 build 模拟器得知 &lt;code>unsupported GNU version! gcc 4.7 and up are not supported!&lt;/code>。之前在别人的博客也看到需要 4.7 以下版本 gcc，不过当时在 cuda11.1 版本下是可以用 gcc 4.8/5 跑模拟器的。现在需要跑一下 ISPASS'09 benchmark, 所以配置到符合要求的版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#39;deb http://archive.ubuntu.com/ubuntu/ trusty main&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo add-apt-repository &lt;span style="color:#e6db74">&amp;#39;deb http://archive.ubuntu.com/ubuntu/ trusty universe&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt install gcc-4.4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.4 50 &lt;span style="color:#75715e">#设置优先级&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.4 50 &lt;span style="color:#75715e">#设置优先级&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --config gcc &lt;span style="color:#75715e">#输入编号选择gcc/g++版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo update-alternatives --config g++ &lt;span style="color:#75715e">#输入编号选择gcc/g++版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gcc -v &lt;span style="color:#75715e">#Check 版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>g++ -v &lt;span style="color:#75715e">#Check 版本&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>更换版本后不支持原子操作？编译代码时加上选项 &lt;code>-arch sm_20&lt;/code>&lt;/p>
&lt;h2 id="2-compile-nvidia-sdk-42">2. Compile Nvidia SDK 4.2&lt;/h2>
&lt;ul>
&lt;li>&lt;code>sudo apt-get install libboost-dev libboost-system-dev libboost-filesystem-dev libboost-all-dev mpich2 binutils-gold libcuda1-304&lt;/code>&lt;/li>
&lt;li>&lt;code>sudo gedit ~/cuda/sdk/4.2/C/common/common.mk&lt;/code>, line like “&lt;code>LIB += … ${OPENGLLIB} …. $(RENDERCHECKGLLIB) …&lt;/code>” should have &lt;code>$(RENDERCHECKGLLIB)&lt;/code> moved before &lt;code>${OPENGLLIB}&lt;/code>. There should be 3 lines like this, it may be line 271, 275 and 282.
&lt;ul>
&lt;li>将 line26 &lt;code>CUDA_INSTALL_PATH ?= /home/gpgpu-sim/cuda/toolkit/4.2/cuda&lt;/code> 修改为 &lt;code>CUDA_INSTALL_PATH ?= /home/huweim/cuda/toolkit/4.2/cuda&lt;/code>
&lt;ul>
&lt;li>这一步应该不用了，用软链接代替路径即可&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>因为这个文件直接拷贝过来的，所以要设置为自己的安装路径&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>sudo gedit ~/cuda/sdk/4.2/CUDALibraries/common/common_cudalib.mk&lt;/code> and do the same thing.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;code>cd ~/cuda/sdk/4.2&lt;/code>&lt;/li>
&lt;li>Edit Makefile through &lt;code>sudo gedit ./Makefile&lt;/code>. Comment all lines with &lt;code>CUDALibraries&lt;/code> and &lt;code>OpenCL&lt;/code> as we only want the application binaries. You comment by placing &lt;code>#&lt;/code> in the front of the line.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;ul>
&lt;li>&lt;code>make&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="21-bug">2.1 Bug&lt;/h3>
&lt;p>遇到 bug&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lcudart
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lcufft
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lXi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lXmu
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>/usr/bin/ld: cannot find -lglut
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="212-解决">2.1.2 解决&lt;/h4>
&lt;p>建立 cudart 的软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda/lib64/libcudart.so.4.2.9 /usr/lib/libcudart.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda/lib64/libcufft.so.4.2.9 /usr/lib/libcufft.so
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#下面几个没有太大必要&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libculas.so.4.2.9 /usr/lib/libculas.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcuspare.so.4.2.9 /usr/lib/libcufspare.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcuinj.so.4.2.9 /usr/lib/libcuinj.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libcurand.so.4.2.9 /usr/lib/libcurand.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /usr/local/cuda/lib64/libnpp.so.4.2.9 /usr/lib/libnpp.so&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo rm /usr/lib/libculas.so
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo apt-get install libxi-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install libxmu-dev
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo apt-get install freeglut3-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-ispass2009-benchmarks">4. ISPASS2009 Benchmarks&lt;/h2>
&lt;ul>
&lt;li>&lt;code>git clone https://github.com/gpgpu-sim/ispass2009-benchmarks.git&lt;/code>, we also upload it to the pan.shanghaitech.&lt;/li>
&lt;li>&lt;code>sudo gedit ~/.bashrc&lt;/code>, add &lt;code>export NVIDIA_COMPUTE_SDK_LOCATION=~/cuda/sdk/4.2&lt;/code>&lt;/li>
&lt;li>&lt;code>cd ispass2009-benchmarks&lt;/code>&lt;/li>
&lt;li>&lt;code>sudo gedit ./Makefile.ispass-2009&lt;/code>
&lt;ul>
&lt;li>comment out line 16 and 28. The AES and WP benchmark does not compiler readily.
&lt;ul>
&lt;li>❗ Note not line 16 to 28, only this two lines&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Change &lt;code>BOOST_LIB&lt;/code> to the following path: &lt;code>/usr/lib/x86_64-linux-gnu/&lt;/code>&lt;/li>
&lt;li>Change &lt;code>BOOST_ROOT&lt;/code> to the following path: &lt;code>/usr/include/boost/&lt;/code>&lt;/li>
&lt;li>Change &lt;code>OPENMPI_BINDIR&lt;/code> to the following path: &lt;code>/usr/bin/&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>sudo gedit ./DG/Makefile&lt;/code>
&lt;ul>
&lt;li>Line 54, change &lt;code>-I/opt/mpich/include&lt;/code> to &lt;code>-I/usr/include/mpich&lt;/code>&lt;/li>
&lt;li>Line 56, append &lt;code>-I/usr/include/mpich&lt;/code> to end of the line&lt;/li>
&lt;li>Line 59-61, add &lt;code>.mpich2&lt;/code> to the end of each line. For example, &lt;code>NEWCC = $(OPENMPI_BINDIR)mpicc.mpich2&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>make -f Makefile.ispass-2009&lt;/code>. Note: If you do a &lt;code>make -f Makefile.ispass-2009 clean&lt;/code>, you may have to recompile the SDK.&lt;/li>
&lt;/ul>
&lt;h3 id="41-dg">4.1 DG&lt;/h3>
&lt;p>需要 openmpi 的环境&lt;/p>
&lt;p>Ubuntu20.04下使用GPGPU-Sim运行 Rodinia&lt;/p>
&lt;h1 id="rodinia">Rodinia&lt;/h1>
&lt;h2 id="0-前言-1">0. 前言&lt;/h2>
&lt;p>Rodinia 的类型还是更多，尝试将其编译好&lt;/p>
&lt;h2 id="1-修改路径">1. 修改路径&lt;/h2>
&lt;p>修改 &lt;code>gpu-rodinia-master/common/make.config&lt;/code> 中 CUDA_INSTALL_PATH，CUDA_LIB_DIR，SDK_DIR 为 your own path&lt;/p>
&lt;p>&lt;del>对我来说只用修改 SDK_DIR&lt;/del>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>CUDA_LIB_DIR :&lt;span style="color:#f92672">=&lt;/span> /home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-4020/release
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CUDA_LIB_DIR :&lt;span style="color:#f92672">=&lt;/span> /home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-11020/release &lt;span style="color:#75715e">#如果要修改版本&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SDK_DIR &lt;span style="color:#f92672">=&lt;/span> /home/huweim/cuda/sdk/4.2/C
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="11-sim_v40">1.1 sim_v4.0&lt;/h3>
&lt;p>如果使用 v4.0 版本的模拟器，&lt;del>需要在编译选项中加上 &lt;code>--cudart shared&lt;/code>&lt;/del>，编译选项是针对 nvcc，我们尝试使用 gcc 4.5, nvcc 4.2 来运行，官方文档中说 gpgpu-sim v4.0 是支持 nvcc 4.2 的。&lt;/p>
&lt;p>在 common.mk 中添加对应的架构版本 &lt;code>SM_VERSION := sm_10 sm_11 sm_12 sm_13 sm_20&lt;/code>&lt;/p>
&lt;h2 id="2-data-set">2. Data Set&lt;/h2>
&lt;p>惊喜地发现 data set 是空的，download from &lt;a href="http://lava.cs.virginia.edu/Rodinia/download_links.htm">http://lava.cs.virginia.edu/Rodinia/download_links.htm&lt;/a>&lt;/p>
&lt;p>好家伙一个 G Data Set&lt;/p>
&lt;h2 id="3-进入-cuda-文件夹逐一编译即可">3. 进入 cuda 文件夹逐一编译即可&lt;/h2>
&lt;h3 id="30-找不到--lcuda-大多数文件">3.0 找不到 -lcuda 大多数文件&lt;/h3>
&lt;p>原因就是没找到动态链接库，guess 因为我们没有安装驱动 ✔️&lt;/p>
&lt;p>&lt;del>make.config 中 &lt;code>CUDA_LIB_DIR&lt;/code> 改为 libcudart.so 所在的路径&lt;/del>，需要的是 libcuda.so 而不是 libcudart.so&lt;/p>
&lt;p>❌ &lt;del>去&lt;a href="https://developer.nvidia.com/cuda-toolkit-42-archive">官网&lt;/a>下载驱动&lt;/del>，电脑没有 NVIDIA GPU 无法安装 Driver&lt;/p>
&lt;p>✔️ 去掉 -lcuda 编译选项，出现 &lt;code>undefined reference to symbol '__gxx_personality_v0@@CXXABI_1.3'&lt;/code> 错误时，把 &lt;code>CC = gcc&lt;/code> 更改为 &lt;code>CC = g++&lt;/code>，或者添加编译选项 &lt;code>-lstdc++&lt;/code>&lt;/p>
&lt;p>暂不清楚去掉 -lcuda 编译选项后的影响&lt;/p>
&lt;h3 id="31-kmeans-leukocyte">3.1 kmeans, leukocyte&lt;/h3>
&lt;p>&lt;strong>BUG&lt;/strong>：提示缺少 .o&lt;/p>
&lt;p>&lt;strong>Solution&lt;/strong>：Makefile 这个 [ch] 会读到 .h，从而编译不出 kmeans.o，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-makefile" data-lang="makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">%.o&lt;/span>&lt;span style="color:#f92672">:&lt;/span> %.[ch]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">$(&lt;/span>CC&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>CC_FLAGS&lt;span style="color:#66d9ef">)&lt;/span> $&amp;lt; -c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#改成后正确编译
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">%.o&lt;/span>&lt;span style="color:#f92672">:&lt;/span> %.[c]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">$(&lt;/span>CC&lt;span style="color:#66d9ef">)&lt;/span> &lt;span style="color:#66d9ef">$(&lt;/span>CC_FLAGS&lt;span style="color:#66d9ef">)&lt;/span> $&amp;lt; -c
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kmeans： &lt;code>libgomp.so.1 =&amp;gt; not found&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ apt-get install libgomp1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="32-huffman-srad">3.2 huffman, srad&lt;/h3>
&lt;p>架构版本改成 &lt;code>-arch=sm_20&lt;/code>&lt;/p>
&lt;h3 id="33-hotspot3d">3.3 hotspot3D&lt;/h3>
&lt;p>include 路径改一下&lt;/p>
&lt;h3 id="34-hybridsort">3.4 hybridsort&lt;/h3>
&lt;p>bucketsort.cu:10: fatal error: GL/glew.h: No such file or directory&lt;/p>
&lt;p>看起来是没有 OpenGL&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ sudo apt-get install libglew-dev
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-run">4. Run&lt;/h2>
&lt;h3 id="41-why-these-benchmark-so-slow">4.1 Why these benchmark so slow?&lt;/h3>
&lt;p>streamcluster, leu, fdtd2d 等等&lt;/p>
&lt;p>Rodinia 大多数 benchmark 都跑得很慢，有的在服务器上两三天都没跑完，不知道是数据量太大还是编译过程除了问题？尽管 GPGPU-Sim 可以自行在达到一定的 cycle 数时停止，还是想知道为什么 Rodinia 如此之慢。&lt;/p>
&lt;h1 id="parbiol">Parbiol&lt;/h1>
&lt;h2 id="0-前言-2">0. 前言&lt;/h2>
&lt;p>Ubuntu20.04 下使用 GPGPU-Sim 编译运行 Parboil&lt;/p>
&lt;h2 id="1-下载和修改文件">1. 下载和修改文件&lt;/h2>
&lt;h3 id="11-下载">1.1 下载&lt;/h3>
&lt;p>最好在&lt;a href="http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx">官网&lt;/a>下载后部署，Github 上的文件多了几个 benchmark，但是没有他们的数据集。&lt;/p>
&lt;p>在官网下载好需要的目录，按照 README 中的要求部署，&lt;code>Parboil&lt;/code> 中需要有 4 个目录，&lt;code>benchmarks&lt;/code>，&lt;code>common&lt;/code>，&lt;code>driver&lt;/code>，&lt;code>datasets&lt;/code>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="12-makefileconf">1.2 Makefile.conf&lt;/h3>
&lt;p>进入 common 目录，里面有对应设备的一些 Makefile examples。主要使用的是cuda，check 文件 Makefile.conf.example-nvidia 中的 CUDA 路径，&lt;strong>复制&lt;/strong>并改名为 Makefile.conf。&lt;/p>
&lt;h3 id="13-cuda_lib_path">1.3 CUDA_LIB_PATH&lt;/h3>
&lt;p>修改为 gpgpu-sim 的中的 libcudart.so 路径即可&lt;/p>
&lt;p>&lt;code>CUDA_LIB_PATH=/home/huweim/gpgpu-sim_distribution/lib/gcc-4.4.7/cuda-4020/release/&lt;/code>&lt;/p>
&lt;h2 id="2-data-set-1">2. Data Set&lt;/h2>
&lt;p>download from &lt;a href="http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx">http://impact.crhc.illinois.edu/parboil/parboil_download_page.aspx&lt;/a>，在 1.1 的步骤中应该已经下载了，但是在 Github 中不带 data set，如果 data set 不全，使用他的脚本编译可能会报错，所以建议在官网下载。&lt;/p>
&lt;p>包含 11 个 benchmark data set&lt;/p>
&lt;h2 id="3-compile">3. Compile&lt;/h2>
&lt;h3 id="31-bug">3.1 Bug&lt;/h3>
&lt;p>这里就是之前说的 BUG，所以东西都去官网下载就不会有这些 BUG 了。&lt;/p>
&lt;h4 id="311-dataset-不全">3.1.1 Dataset 不全&lt;/h4>
&lt;!-- raw HTML omitted -->
&lt;p>16 benchmark src，但是 dataset 只有11个&lt;/p>
&lt;p>✔️ 解决方法，直接去官方网站下载，不在 github 上下载，11 benchmark 对应 11 dataset&lt;/p>
&lt;h4 id="312-gcc">3.1.2 gcc&lt;/h4>
&lt;p>&lt;code>error: identifier &amp;quot;__builtin_ia32_vec_set_v8hi&amp;quot; is undefined&lt;/code>，网上也没有搜索到。
尝试切换一下 gcc 版本，发现只能用 gcc 4.7 及以前的版本。&lt;/p>
&lt;p>✔️ 解决方法，直接去官方网站下载，不在 github 上下载，11 benchmark 对应 11 dataset。这个时候 compile 也没有错误了。&lt;/p>
&lt;h3 id="32-compile-命令">3.2 Compile 命令&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ./parboil compile benchmark_name platform_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./parboil compile bfs cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#bfs 可执行文件在目录 parboil_Dir/benchmarks/bfs/build/cuda_default/bfs&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来逐一编译11个 benchmark 即可&lt;/p>
&lt;h2 id="4-run-1">4. Run&lt;/h2>
&lt;h3 id="41-run-命令">4.1 Run 命令&lt;/h3>
&lt;p>2021-12-05 13:20:02 ✔️ 搞定&lt;/p>
&lt;p>⭐ ​使用 GPGPU-Sim 需要在运行目录下放置 3 个 config 文件&lt;/p>
&lt;p>GPGPU-Sim 配置文件放在 &lt;code>~/Parboil/benchmarks/bfs&lt;/code> 目录下即可，成功运行&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ cp ~/gpgpu-sim_distribution/configs/GTX480/* ~/Parboil/benchmarks/bfs/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ./parboil run bfs cuda 1M
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="5-script">5. Script&lt;/h2>
&lt;h3 id="51-config文件">5.1 Config文件&lt;/h3>
&lt;p>每个 benchmark 目录下复制好3个 GPGPU-Sim 必备的 config 文件，怎么实现并行执行是一个考验。在不改动原来的脚本文件前提下，每次运行都是在 &lt;code>~/Parboil/benchmarks/Benchmark_Name_Dir&lt;/code> 目录下，所以在使用不同的调度策略启动前，需要将对应的 config 文件复制到此目录。
而为了保证并行，需要在其启动后（不可能等待其执行完毕再复制），就复制另一种调度策略的 config 文件。&lt;/p>
&lt;h1 id="polybench">Polybench&lt;/h1>
&lt;h2 id="0-前言-3">0. 前言&lt;/h2>
&lt;p>Ubuntu20.04 下使用 GPGPU-Sim 编译运行 Polybench&lt;/p>
&lt;h2 id="1-40-sim">1. 4.0 sim&lt;/h2>
&lt;p>在 CUDA/utilities/common.mk 中，&lt;code>nvcc&lt;/code> 后面加上 &amp;ndash;cudart shared&lt;/p>
&lt;h1 id="tango">Tango&lt;/h1>
&lt;p>CUDA Code 似乎和 parboil 类似，都是读取当前目录下的 data 文件夹，因此需要在 tango 的目录中去运行，写一下脚本。&lt;/p>
&lt;p>2022-03-18 14:32:07，确实如此，否则会出现 &lt;code>File Not Found&lt;/code>&lt;/p>
&lt;h1 id="cuda-sdk">CUDA SDK&lt;/h1>
&lt;h2 id="0-前言-4">0. 前言&lt;/h2>
&lt;p>CUDA Samples 似乎没有放置在 toolkit 里面，需要单独安装使用&lt;/p>
&lt;h2 id="1-排坑">1. 排坑&lt;/h2>
&lt;p>实际没有链接到 CUDA 4.2，而是自己装的 CUDA 11.1 版本，所以报错&lt;/p>
&lt;p>先尝试修改一下环境变量，简单地修改环境变量是不行的。切换 CUDA 版本还需要修改软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /usr/local/cuda &lt;span style="color:#75715e">#删除之前创建的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda11.4 /usr/local/cuda
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>nvcc -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Python处理输出log信息并绘图</title><link>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</link><pubDate>Wed, 08 Dec 2021 09:05:41 +0800</pubDate><guid>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_python%E5%A4%84%E7%90%86%E8%BE%93%E5%87%BAlog%E4%BF%A1%E6%81%AF%E5%B9%B6%E7%BB%98%E5%9B%BE/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>修改 GPGPU-Sim 并跑 benchmark，如果一次用12个benchmark，3种调度算法，那么一次会生成36个 output log。需要使用 python 脚本可视化这些数据来进行 high level 的分析，因此自己写了一个脚本进行输出数据的可视化工作。&lt;/p>
&lt;p>需要两个绘图工具&lt;/p>
&lt;ul>
&lt;li>对于单个 benchmark，分析其 ipc，cache hit/miss，mem_stall 等等&lt;/li>
&lt;li>对于多个 benchmark，分析总体的 ipc，cache hit/miss，mem_stall 等等&lt;/li>
&lt;/ul>
&lt;h1 id="1-正则表达式">1. 正则表达式&lt;/h1>
&lt;h2 id="11-实例">1.1 实例&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">read_string&lt;/span>(file,metrics):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output&lt;span style="color:#f92672">=&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> it_metrics &lt;span style="color:#f92672">in&lt;/span> metrics:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;gpu_ipc&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34; =(\s+)(\d+\.\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">elif&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;Stall&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34;:(\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pattern&lt;span style="color:#f92672">=&lt;/span>re&lt;span style="color:#f92672">.&lt;/span>compile(it_metrics&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#e6db74">&amp;#34; = (\d+)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_sum&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> i,line &lt;span style="color:#f92672">in&lt;/span> enumerate(open(get_file_path()&lt;span style="color:#f92672">+&lt;/span>file)):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> match &lt;span style="color:#f92672">in&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>finditer(pattern, line):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(it_metrics&lt;span style="color:#f92672">==&lt;/span>&lt;span style="color:#e6db74">&amp;#34;gpu_ipc&amp;#34;&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>list(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">2&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>list(match&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_part&lt;span style="color:#f92672">=&lt;/span>float(&lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>join(output_part))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output_sum&lt;span style="color:#f92672">+=&lt;/span>output_part
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> output[it_metrics]&lt;span style="color:#f92672">=&lt;/span>output_sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> output
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实没有找到最舒服的正则表达式，理想情况是读取到表示数据的一串字符串，然后直接转化为浮点数。但是各种匹配方法似乎都是一次匹配一个数字/字符串，所以先使用现成的。&lt;/p>
&lt;p>&lt;code>for i,line in enumerate(open(file))&lt;/code> 遍历 log 的每一行，一定要加上 &lt;code>i&lt;/code> 否则会报错。&lt;/p>
&lt;p>&lt;code>match.group(1)&lt;/code> 每次会返回一个整数，这个时候整数是元组的形式，所以需要先转化为 list，然后转化为 float 类型，这个时候便可以用于算术运算。&lt;/p>
&lt;h3 id="111-group">1.1.1 group&lt;/h3>
&lt;ul>
&lt;li>似乎有点理解这个匹配了，对于 &lt;code>gpu_ipc&lt;/code>，\s+ 匹配的是至少一个空格，实际匹配的是多个空格，如果使用 group(1) 就会返回这个元组&lt;/li>
&lt;li>我们想要的是 \d+，所以返回第二个元组，再将其转化为 float 即可&lt;/li>
&lt;li>2021-10-28 20:11:01：搞定，小数部分也能保留&lt;/li>
&lt;/ul>
&lt;h2 id="12-字符串开头结尾匹配">1.2 字符串开头/结尾匹配&lt;/h2>
&lt;p>检查字符串开头或结尾的一个简单方法是使用 &lt;code>str.startswith()&lt;/code> 或者是 &lt;code>str.endswith()&lt;/code> 方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> filename &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;spam.txt&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> filename&lt;span style="color:#f92672">.&lt;/span>endswith(&lt;span style="color:#e6db74">&amp;#39;.txt&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2-文件操作">2. 文件操作&lt;/h1>
&lt;h2 id="21-python-os-文件目录方法">2.1 Python OS 文件/目录方法&lt;/h2>
&lt;p>&lt;strong>os&lt;/strong> 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示&lt;/p>
&lt;p>&lt;code>os.listdir(path)&lt;/code>，返回path指定的文件夹包含的文件或文件夹的名字的列表。&lt;/p>
&lt;h1 id="3-绘图">3. 绘图&lt;/h1>
&lt;h2 id="31-并列柱状图">3.1 并列柱状图&lt;/h2>
&lt;p>绘制并列柱状图与堆叠柱状图类似，都是绘制多组柱体，只需要控制好每组柱体的位置和大小即可。例如：&lt;/p>
&lt;p>❗ 注意设置柱状图宽度不可忽略，否则无法正常显示&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> numpy &lt;span style="color:#66d9ef">as&lt;/span> np
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> matplotlib.pyplot &lt;span style="color:#66d9ef">as&lt;/span> plt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>arange(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c &lt;span style="color:#f92672">=&lt;/span> np&lt;span style="color:#f92672">.&lt;/span>random&lt;span style="color:#f92672">.&lt;/span>random(size)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>total_width, n &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0.8&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>width &lt;span style="color:#f92672">=&lt;/span> total_width &lt;span style="color:#f92672">/&lt;/span> n
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">-&lt;/span> (total_width &lt;span style="color:#f92672">-&lt;/span> width) &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x, a, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;a&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x &lt;span style="color:#f92672">+&lt;/span> width, b, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;b&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>bar(x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">*&lt;/span> width, c, width&lt;span style="color:#f92672">=&lt;/span>width, label&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;c&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>legend()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>plt&lt;span style="color:#f92672">.&lt;/span>show()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;!-- raw HTML omitted -->
&lt;h1 id="4-调试">4. 调试&lt;/h1>
&lt;h2 id="41-调试时需要输入">4.1 调试时需要输入&lt;/h2>
&lt;h1 id="5--">5. (), [],&lt;/h1>
&lt;h2 id="51--元组">5.1 () 元组&lt;/h2>
&lt;p>代表tuple元祖数据类型，元祖是一种不可变序列。创建方法很简单，大多数时候都是小括号括起来的。&lt;/p>
&lt;h2 id="52--列表">5.2 [] 列表&lt;/h2>
&lt;p>代表list列表数据类型，列表是一种可变序列。创建方法既简单又特别。&lt;/p>
&lt;h2 id="53--字典">5.3 {} 字典&lt;/h2>
&lt;p>代表dict字典数据类型，字典是Python中唯一内建的映射类型。字典中的值没有特殊的顺序，但都是存储在一个特定的键（key）下。键可以是数字、字符串甚至是元祖。&lt;/p>
&lt;h3 id="531-字典">5.3.1 字典&lt;/h3>
&lt;p>字典的每个键值 &lt;strong>key=&amp;gt;value&lt;/strong> 对用冒号 &lt;strong>:&lt;/strong> 分割，每个键值对之间用逗号 &lt;strong>,&lt;/strong> 分割，整个字典包括在花括号 &lt;strong>{}&lt;/strong> 中 ,格式如下所示：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>d &lt;span style="color:#f92672">=&lt;/span> {key1 : value1, key2 : value2 }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>相当于是键值对索引，key 只能是 &lt;code>字符串，数字或元组&lt;/code>&lt;/p>
&lt;ul>
&lt;li>python 中单引号和双引号字符串没有区别&lt;/li>
&lt;/ul>
&lt;h3 id="532-用到了字典排序字典转化为-list">5.3.2 用到了字典排序、字典转化为 list&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#按键(key)排序:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_lrr_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_gto_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted(y_cory_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_lrr&lt;span style="color:#f92672">=&lt;/span>list(y_lrr_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_gto&lt;span style="color:#f92672">=&lt;/span>list(y_gto_dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> y_cory&lt;span style="color:#f92672">=&lt;/span>list(y_cory_dict)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Linux任务调度</title><link>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link><pubDate>Mon, 29 Nov 2021 23:00:09 +0800</pubDate><guid>https://huweim.github.io/post/%E5%B7%A5%E5%85%B7_linux%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>记录一下 &lt;code>Linux&lt;/code> 中 &lt;code>fg&lt;/code>、&lt;code>bg&lt;/code>、&lt;code>jobs&lt;/code>、&lt;code>&amp;amp;&lt;/code>、&lt;code>ctrl + z&lt;/code> 等相关指令对任务进程的操作。&lt;/p>
&lt;p>也正好借此机会学习一下进程（process）的概念&lt;/p>
&lt;h1 id="1-process">1. Process&lt;/h1>
&lt;h2 id="10-进程类型">1.0 进程类型&lt;/h2>
&lt;ul>
&lt;li>前台进程（交互式进程）
&lt;ul>
&lt;li>这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能/服务的一部分自动启动。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>后台进程&lt;/li>
&lt;/ul>
&lt;h2 id="11-并发执行">1.1 并发执行&lt;/h2>
&lt;p>To run commands concurrently you can use the &lt;code>&amp;amp;&lt;/code> command separator&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>~$ command1 &amp;amp; command2 &amp;amp; command3
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This will start &lt;code>command1&lt;/code>, then runs it in the background. The same with &lt;code>command2&lt;/code>. Then it starts &lt;code>command3&lt;/code> normally.&lt;/p>
&lt;blockquote>
&lt;p>这样的话 command3 是在前台运行&lt;/p>
&lt;/blockquote>
&lt;p>The output of all commands will be garbled together, but if that is not a problem for you, that would be the solution.&lt;/p>
&lt;p>If you want to have a separate look at the output later, you can pipe the output of each command into &lt;code>tee&lt;/code>, which lets you specify a file to mirror the output to.&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-bsh" data-lang="bsh">~$ command1 | tee 1.log &amp;amp; command2 | tee 2.log &amp;amp; command3 | tee 3.log
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>这样可以分别在对应的 log 中查看不同 command output，我也是这么做的&lt;/p>
&lt;p>加&amp;amp;的作用其实就是将命令放到后台执行&lt;/p>
&lt;/blockquote>
&lt;h3 id="111-终止并发执行的后台进程">1.1.1 终止并发执行的后台进程&lt;/h3>
&lt;ul>
&lt;li>方法一： 通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>kill %num&lt;/code>&lt;/li>
&lt;li>方法二： 通过 &lt;code>ps&lt;/code> 命令查看任务的进程号（&lt;code>PID&lt;/code>，假设为 &lt;code>pid&lt;/code>），然后执行：&lt;code>kill pid&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="12-进程及性能分析">1.2 进程及性能分析&lt;/h2>
&lt;h3 id="121-进程状态">1.2.1 进程状态&lt;/h3>
&lt;ul>
&lt;li>R： &lt;strong>RUNNING &amp;amp; RUNNABLE&lt;/strong>，正在运行或在运行队列中等待&lt;/li>
&lt;li>S：&lt;strong>INTERRRUPTABLE_SLEEP&lt;/strong>，休眠中, 受阻, 在等待某个条件的形成或接受到 signal&lt;/li>
&lt;li>D：&lt;strong>UNINTERRUPTABLE_SLEEP&lt;/strong>，不可中断（usually IO）&lt;/li>
&lt;li>T：&lt;strong>STOPPED&lt;/strong>，ctrl + z 进入这个状态&lt;/li>
&lt;li>Z：&lt;strong>ZOMBIE&lt;/strong>，进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放&lt;/li>
&lt;/ul>
&lt;h3 id="122-查看进程状态-ps">1.2.2 查看进程状态 ps&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ ps -aux &lt;span style="color:#75715e">#显示所有包含其他使用者的行程 &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>%CPU&lt;/strong>：该 process 使用掉的 CPU 资源百分比&lt;/p>
&lt;p>&lt;strong>%MEM&lt;/strong>：该 process 所占用的物理内存百分比&lt;/p>
&lt;p>&lt;strong>TTY&lt;/strong> ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。&lt;/p>
&lt;p>&lt;strong>STAT&lt;/strong>：该程序目前的状态，主要的状态参考 &lt;strong>1.2进程状态&lt;/strong>&lt;/p>
&lt;p>&lt;strong>START&lt;/strong>：该 process 被触发启动的时间&lt;/p>
&lt;p>&lt;strong>TIME&lt;/strong> ：该 process 实际使用 CPU 运作的时间&lt;/p>
&lt;h3 id="123-性能分析-top">1.2.3 性能分析 top&lt;/h3>
&lt;h5 id="信息查看实例">信息查看实例&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>top - 19:39:49 up &lt;span style="color:#ae81ff">77&lt;/span> days, 8:54, &lt;span style="color:#ae81ff">0&lt;/span> users, load average: 5.00, 5.00, 5.00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 系统当前时间；开机到现在77days 8h 54 mins；0 users 在线；系统1分钟、5分钟、15分钟的CPU负载信息&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Tasks: &lt;span style="color:#ae81ff">13&lt;/span> total, &lt;span style="color:#ae81ff">1&lt;/span> running, &lt;span style="color:#ae81ff">12&lt;/span> sleeping, &lt;span style="color:#ae81ff">0&lt;/span> stopped, &lt;span style="color:#ae81ff">0&lt;/span> zombie
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>%Cpu&lt;span style="color:#f92672">(&lt;/span>s&lt;span style="color:#f92672">)&lt;/span>: 20.9 us, 0.0 sy, 0.0 ni, 79.1 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %sy：内核占用CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %ni：改变过优先级的进程占用CPU的百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %id：空闲CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %wa：等待I/O的CPU时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %hi：CPU硬中断时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># %si：CPU软中断时间百分比&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MiB Mem : 48192.1 total, 25777.1 free, 2605.3 used, 19809.7 buff/cache
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>MiB Swap: 19530.0 total, 19491.7 free, 38.2 used. 45002.0 avail Mem
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="查看单个进程使用cpu情况">查看单个进程使用CPU情况&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>$ top -p pid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ ps -aux &lt;span style="color:#75715e">#这个好像更加方便一点&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="13-为什么top查看只有1-running其他sleeping">1.3 为什么top查看只有1 running，其他sleeping?&lt;/h2>
&lt;h5 id="stackoverflow回答">Stackoverflow回答&lt;/h5>
&lt;p>There is no correlation between CPU usage as reported by &lt;code>top&lt;/code> and process state. The &lt;a href="http://linux.die.net/man/1/top">man page&lt;/a> says (&lt;em>emphasis&lt;/em> mine):&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>%CPU&lt;/strong> &amp;ndash; CPU usage&lt;/p>
&lt;p>The task&amp;rsquo;s share of the elapsed CPU time &lt;em>since the last screen update&lt;/em>, expressed as a percentage of total CPU time.&lt;/p>
&lt;/blockquote>
&lt;p>So, your process indeed used a huge amount of processor time since the last screen update. It is sleeping, yes, but that&amp;rsquo;s because the currently running process is &lt;code>top&lt;/code> itself (which makes sense, since it&amp;rsquo;s currently updating the screen).&lt;/p>
&lt;h5 id="理解">理解&lt;/h5>
&lt;p>这个1 running 就是 top process 本身，其他的 process 其实也是在运行的。每次 top 面板更新时活跃 process 正好是 top，所以 only 1 running。但是查看详细信息可以看到其实是在运行的。&lt;/p>
&lt;h1 id="2-进程调度">2. 进程调度&lt;/h1>
&lt;h2 id="21-基本用法">2.1. 基本用法&lt;/h2>
&lt;h3 id="211--和-jobs-指令">2.1.1 &lt;code>&amp;amp;&lt;/code> 和 &lt;code>jobs&lt;/code> 指令&lt;/h3>
&lt;p>&lt;code>&amp;amp;&lt;/code> 用在一个命令的最后，可以把这个命令转换为&lt;strong>后台运行&lt;/strong>的任务进程。&lt;/p>
&lt;p>&lt;code>jobs&lt;/code> 查看当前终端有多少在后台运行的进程。&lt;/p>
&lt;ul>
&lt;li>&lt;code>jobs&lt;/code> 命令执行的结果，&lt;code>＋&lt;/code> 表示是一个当前的作业，&lt;code>-&lt;/code> 减号表示是一个当前作业之后的一个作业。&lt;/li>
&lt;li>&lt;code>jobs -l&lt;/code> 选项可显示所有任务的进程号 &lt;code>pid&lt;/code>&lt;/li>
&lt;li>&lt;code>jobs&lt;/code> 的状态可以是 &lt;code>running&lt;/code>，&lt;code>stopped&lt;/code>，&lt;code>terminated&lt;/code>。但是如果任务进程被终止了（&lt;code>kill&lt;/code>），当前的终端环境中也就删除了任务的进程标识；也就是说 &lt;strong>jobs 命令显示的是当前 shell 环境中后台正在运行或者被挂起的任务进程信息&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="213-fg-和-bg-指令">2.1.3 &lt;code>fg&lt;/code> 和 &lt;code>bg&lt;/code> 指令&lt;/h3>
&lt;p>&lt;code>fg&lt;/code> 将后台任务进程调至&lt;strong>前台&lt;/strong>继续运行，如果后台中有多个任务进程，可以用 &lt;code>fg %num&lt;/code> 将选中的任务进程调至前台。&lt;/p>
&lt;p>&lt;code>bg&lt;/code> 将挂起的任务进程重新启动运行，如果有多个暂停的任务进程，可以用 &lt;code>bg %num&lt;/code> 将选中的任务进程启动运行。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>%num&lt;/code> 是通过 &lt;code>jobs&lt;/code> 命令查到的后台正在执行的任务的序号（不是 &lt;code>pid&lt;/code>）&lt;/p>
&lt;/blockquote>
&lt;p>❗ 使用 ispass_run.sh 的时候最好使用 &lt;code>fg&lt;/code>，如果使用 &lt;code>bg&lt;/code> 则无法再次挂起，&lt;del>猜测是因为&lt;/del>，原因是 &lt;code>ctrl + z&lt;/code> 是用于挂起前台进程，使用 &lt;code>stop&lt;/code> 将其挂起即可&lt;/p>
&lt;blockquote>
&lt;p>使用 stop 2，好像也无法将其挂起？&lt;/p>
&lt;/blockquote>
&lt;h2 id="22-进程的挂起">2.2. 进程的挂起&lt;/h2>
&lt;h3 id="221-后台进程的挂起">2.2.1 后台进程的挂起&lt;/h3>
&lt;ul>
&lt;li>在 &lt;code>solaris&lt;/code> 中通过 &lt;code>stop&lt;/code> 命令执行，通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>stop %num&lt;/code>&lt;/li>
&lt;li>在 &lt;code>redhat&lt;/code> 中，不存在 &lt;code>stop&lt;/code> 命令，可通过执行命令 &lt;code>kill -stop PID&lt;/code>，将进程挂起&lt;/li>
&lt;/ul>
&lt;h3 id="222-前台进程的挂起-ctrlz">2.2.2 前台进程的挂起 ctrl+z&lt;/h3>
&lt;p>&lt;code>ctrl + z&lt;/code>：可以将一个正在s前台执行的任务放到后台运行，并且挂起&lt;/p>
&lt;h2 id="23-挂起进程重新运行-bg-fg">2.3. 挂起进程重新运行 bg, fg&lt;/h2>
&lt;ul>
&lt;li>通过 &lt;code>bg %num&lt;/code> 即可将挂起的任务进程的状态由 &lt;code>stopped&lt;/code> 改为 &lt;code>running&lt;/code>，仍在后台运行&lt;/li>
&lt;li>通过 &lt;code>fg %num&lt;/code> 即可将挂起的任务进程转为前台执行&lt;/li>
&lt;/ul>
&lt;h2 id="24-进程的终止">2.4. 进程的终止&lt;/h2>
&lt;h3 id="241-后台进程的终止-kill-killall">2.4.1 后台进程的终止 kill, killall&lt;/h3>
&lt;ul>
&lt;li>方法一： 通过 &lt;code>jobs&lt;/code> 命令查看任务号（假设为 &lt;code>num&lt;/code>），然后执行：&lt;code>kill %num&lt;/code>&lt;/li>
&lt;li>方法二： 通过 &lt;code>ps&lt;/code> 命令查看任务的进程号（&lt;code>PID&lt;/code>，假设为 &lt;code>pid&lt;/code>），然后执行：&lt;code>kill pid&lt;/code>&lt;/li>
&lt;li>&lt;code>killall CMD&lt;/code>：通过进程名 kill 感觉比根据 pid 方便很多&lt;/li>
&lt;/ul>
&lt;h3 id="242-前台进程的终止-ctrlc">2.4.2 前台进程的终止 ctrl+c&lt;/h3>
&lt;p>执行 &lt;code>ctrl+c&lt;/code> 即可终止前台执行任务进程&lt;/p>
&lt;blockquote>
&lt;p>假设要后台运行 &lt;code>xmms&lt;/code>，可通过命令：&lt;code>xmms &amp;amp;&lt;/code>。但万一你运行程序时忘记使用 &lt;code>&amp;amp;&lt;/code> 了，又不想重新执行，你可以先使用 &lt;code>ctrl+z&lt;/code> 挂起任务进程，然后敲入&lt;code>bg&lt;/code> 命令，这样任务进程就在后台继续运行了。&lt;/p>
&lt;/blockquote>
&lt;h1 id="3-查看cpu信息">3. 查看CPU信息&lt;/h1>
&lt;ul>
&lt;li>查看物理CPU个数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;physical id&amp;#34;&lt;/span>| sort| uniq| wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>查看每个物理CPU中core的个数(即核数)&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;cpu cores&amp;#34;&lt;/span>| uniq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>查看逻辑CPU的个数&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>cat /proc/cpuinfo| grep &lt;span style="color:#e6db74">&amp;#34;processor&amp;#34;&lt;/span>| wc -l
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="4-why-jobs-看不到后台-process">4. Why &lt;code>jobs&lt;/code> 看不到后台 process&lt;/h1>
&lt;h2 id="41-关闭终端造成孤儿进程">4.1 关闭终端造成孤儿进程&lt;/h2>
&lt;blockquote>
&lt;p>jobs是查看当前后台作业（进程），是获取本次bash下的后台作业。
当本次终端退出后，后台作业变成&lt;strong>孤儿进程&lt;/strong>，孤儿进程有系统父进程接管。
当再次连接终端时，&lt;strong>原作业&lt;/strong>与&lt;strong>当前终端&lt;/strong>，不存在关系父子关系，故看不到进程。
但是原作业，会在系统中一致运行，直到完成或被停止。
这就是为什么终端退出后，jobs看不到的原因了&lt;/p>
&lt;/blockquote>
&lt;h2 id="42-nohup">4.2 nohup&lt;/h2>
&lt;h3 id="421-">4.2.1 &amp;amp;&lt;/h3>
&lt;p>守护进程貌似跟nohup + &amp;amp;方式启动的进程差不多。都可以实现与终端的无关联。&lt;/p>
&lt;p>&amp;amp; 可以让进程在后台运行，ctrl + C 无法终端，对 SIGINT 信号免疫，但是直接关闭 shell 后进程会消失。&amp;amp; 后台没有那么硬 :)，对 SIGHUP 信号不免疫&lt;/p>
&lt;h3 id="422-nohup--作用">4.2.2 nohup 作用&lt;/h3>
&lt;p>nohup 的作用是忽略 SIGHUP 信号，也就是不挂断地运行&lt;/p>
&lt;p>&amp;amp;和nohup没有半毛钱的关系， 要让进程真正不受shell中Ctrl C和shell关闭的影响， 那该怎么办呢？ 那就用nohup ./start.sh &amp;amp;吧， 两全其美。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/">https://ehlxr.me/2017/01/18/Linux-%E4%B8%AD-fg%E3%80%81bg%E3%80%81jobs%E3%80%81-%E6%8C%87%E4%BB%A4/&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.cnblogs.com/machangwei-8/p/10391440.html">https://www.cnblogs.com/machangwei-8/p/10391440.html&lt;/a>&lt;/p></description></item><item><title>Ubuntu多版本CUDA,GCC切换</title><link>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_ubuntu%E5%A4%9A%E7%89%88%E6%9C%ACcudagcc%E5%88%87%E6%8D%A2/</link><pubDate>Sun, 14 Nov 2021 22:07:35 +0800</pubDate><guid>https://huweim.github.io/post/%E7%BC%96%E7%A8%8B_ubuntu%E5%A4%9A%E7%89%88%E6%9C%ACcudagcc%E5%88%87%E6%8D%A2/</guid><description>&lt;h1 id="ubuntu多版本cudagcc切换">Ubuntu多版本CUDA,GCC切换&lt;/h1>
&lt;h1 id="切换cuda90和cuda100">切换CUDA9.0和CUDA10.0&lt;/h1>
&lt;p>保证多个CUDA版本共存的前提是NVIDIA的驱动都能够支持你所安装的CUDA版本，所以驱动的版本尽可能高，越新的驱动支持的CUDA版本越多，博主的430能够支持9.0和10.0。&lt;/p>
&lt;p>在先前安装的CUDA的过程中，大家一般都会选择生成cuda-x.0文件夹的软链接/usr/local/cuda，这个文件夹是实际安装的cuda-x.0文件夹的链接，不包含实际文件，是方便系统设置环境变量直接调用cuda的，安装多个版本的CUDA，然后利用软链接就可以实现版本切换。&lt;/p>
&lt;ul>
&lt;li>理解这个软链接，用到了很多次&lt;/li>
&lt;/ul>
&lt;h2 id="step">Step&lt;/h2>
&lt;h3 id="1-更换软链接">1 更换软链接&lt;/h3>
&lt;p>不过之前环境变量用的 cuda11.1 的地址而非软链接，现在替换成软链接&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo rm -rf /usr/local/cuda &lt;span style="color:#75715e">#删除之前生成的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /home/huweim/cuda/toolkit/4.2/cuda /usr/local/cuda &lt;span style="color:#75715e">#生成新的软链接&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo ln -s /usr/local/cuda-11.1 /usr/local/cuda &lt;span style="color:#75715e">#使用11.1版本&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-check-环境变量的地址">2 Check 环境变量的地址&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>export CUDA_INSTALL_PATH&lt;span style="color:#f92672">=&lt;/span>/usr/local/cuda/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PATH&lt;span style="color:#f92672">=&lt;/span>$PATH:/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:$CUDA_INSTALL_PATH/bin:$MPI_ROOT/bin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export LD_LIBRARY_PATH&lt;span style="color:#f92672">=&lt;/span>$LD_LIBRARY_PATH:$CUDA_INSTALL_PATH/lib64 &lt;span style="color:#75715e">#这个不用改&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export NVIDIA_COMPUTE_SDK_LOCATION&lt;span style="color:#f92672">=&lt;/span>~/cuda/sdk/4.2
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-查看版本信息">3 查看版本信息&lt;/h3>
&lt;p>上述步骤全部没问题就可以弹出版本信息了，&lt;code>source ~/.bashrc&lt;/code> 或者重启终端&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>nvcc: NVIDIA &lt;span style="color:#f92672">(&lt;/span>R&lt;span style="color:#f92672">)&lt;/span> Cuda compiler driver
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Copyright &lt;span style="color:#f92672">(&lt;/span>c&lt;span style="color:#f92672">)&lt;/span> 2005-2012 NVIDIA Corporation
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Built on Thu_Apr__5_00:24:31_PDT_2012
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Cuda compilation tools, release 4.2, V0.2.1221
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-bug">4. Bug&lt;/h3>
&lt;h4 id="41-sh-1-nvopencc-permission-denied">4.1 sh: 1: nvopencc: Permission denied&lt;/h4>
&lt;p>解决方法&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>sudo chmod -R &lt;span style="color:#ae81ff">777&lt;/span> /usr/local/cuda
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="切换gcc-g-9---5">切换gcc, g++ 9 -&amp;gt; 5&lt;/h1>
&lt;p>Reference&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/EternallyAccompany/article/details/108865331">https://blog.csdn.net/EternallyAccompany/article/details/108865331&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>linux上可以gcc多版本共存，可以通过&lt;strong>修改软链接&lt;/strong>的方式选择自己要用的gcc版本，该方法简单方便，可以随时依据自己的需求将gcc降级或升级，解决不同的软件要求不同的环境的问题。&lt;/p>
&lt;p>apt-get安装gcc、g++，默认下载最新版本的，此时ubuntu里的gcc和g++版本均为9。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>1. sudo apt-get install gcc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2. sudo apt-get install g++
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>3. gcc -v //查看的版本为9.0.0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>4. g++ -v //查看的版本为9.0.0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="1-软件源">1. 软件源&lt;/h2>
&lt;p>打开sources.list&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo gedit /etc/apt/sources.list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Add&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>deb http://dk.archive.ubuntu.com/ubuntu/ xenial main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deb http://dk.archive.ubuntu.com/ubuntu/ xenial universe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Update&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get update
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="2-安装gcc5-g5">2. 安装gcc5, g++5&lt;/h2>
&lt;p>apt-get 安装gcc、g++ 5版本。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install g++-5 gcc-5sudo apt-get -f install &lt;span style="color:#75715e">#if need &lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>2021-07-09 10:40:42 gcc5版本又出现了一些问题，找&lt;a href="https://blog.csdn.net/qq_42566274/article/details/106399531">教程&lt;/a>安装了 gcc4.8 版本，这个文章里面说最低 4.7 版本，那就先用 4.8 版本试试 gpgpu-sim 能不能 work&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo apt-get install gcc-4.8sudo apt-get install g++-4.8
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="3-查看">3. 查看&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ls /usr/bin/gcc*ls /usr/bin/g++*
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="4-设置优先级">4. 设置优先级&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 90sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 80sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 90sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 &lt;span style="color:#ae81ff">80&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>增加&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 95sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.8 &lt;span style="color:#ae81ff">95&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>成功配置上了 gcc 4.8&lt;/p>
&lt;blockquote>
&lt;p>由于gpgpusim必须使用gcc4.7及以前的版本，而修改自己的电脑系统可能带来不方便，因此使用docker来运行程序，docker在运行程序时，性能损失大概在10%以内，但也比vbox快多了。&lt;/p>
&lt;/blockquote>
&lt;p>好吧，必须使用 gcc4.7 以前的版本&lt;/p>
&lt;h2 id="5-选择gccg版本">5. 选择gcc/g++版本&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo update-alternatives --config gccsudo update-alternatives --config g++
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输入编号选择gcc/g++版本&lt;/p>
&lt;p>⚠️ &lt;em>gcc/g++版本须保持一致&lt;/em>&lt;/p>
&lt;h2 id="6-check-版本">6. Check 版本&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>gcc -vg++ -v
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>GPGPU-Sim中的CTA &amp; warp scheduling</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_gpgpu-sim%E4%B8%AD%E7%9A%84cta-warp-scheduling/</link><pubDate>Sun, 14 Nov 2021 20:42:52 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_gpgpu-sim%E4%B8%AD%E7%9A%84cta-warp-scheduling/</guid><description>&lt;h1 id="cta-scheduling">CTA Scheduling&lt;/h1>
&lt;p>CTA/Thread Block/Work Group&lt;/p>
&lt;p>调度发生在 &lt;code>shader_core_ctx::issue_block2core(...)&lt;/code>，&lt;code>shader_core_config::max_cta(...)&lt;/code> 计算 core 中能容纳的 max CTA。这个取决于各硬件资源的短板，在报告中能看到是被什么限制了。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>printf(&lt;span style="color:#e6db74">&amp;#34;GPGPU-Sim uArch: CTA/core = %u, limited by:&amp;#34;&lt;/span>, result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> result_thread) printf(&lt;span style="color:#e6db74">&amp;#34; threads&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> result_shmem) printf(&lt;span style="color:#e6db74">&amp;#34; shmem&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> result_regs) printf(&lt;span style="color:#e6db74">&amp;#34; regs&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (result &lt;span style="color:#f92672">==&lt;/span> result_cta) printf(&lt;span style="color:#e6db74">&amp;#34; cta_limit&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在矩阵乘法代码中 create, verify are both limited by thread, multiple is limited by regs.&lt;/p>
&lt;p>When each thread finishes, the SIMT core calls &lt;code>register_cta_thread_exit(...)&lt;/code> to update the active thread block&amp;rsquo;s state. CTA 中的所有线程执行完毕后，active CTA 数量减一，允许新的 CTA 在下个周期被调度。&lt;/p>
&lt;h1 id="warp-scheduling">Warp Scheduling&lt;/h1>
&lt;h2 id="1-from-code">1. From Code&lt;/h2>
&lt;ul>
&lt;li>A new front-end that models instruction caches and separates the &lt;strong>warp scheduling (issue) stage&lt;/strong> from the fetch and decode stage&lt;/li>
&lt;/ul>
&lt;h5 id="flow">Flow&lt;/h5>
&lt;p>&lt;code>shader_core_ctx::issue()&lt;/code> call &lt;code>scheduler_unit::cycle()&lt;/code>。&lt;/p>
&lt;p>In function &lt;code>scheduler_unit::cycle()&lt;/code> , call &lt;code>order_warps()&lt;/code> to sort warps according to their priority.&lt;/p>
&lt;p>排序后的 warp 放在 vector &lt;code>m_next_cycle_prioritized_warps&lt;/code> 中，对其进行遍历来处理这个 vector 中的 warp。&lt;/p>
&lt;p>进入 for 循环，拿到 warp id，判断&lt;/p>
&lt;ul>
&lt;li>I-Buffer 是否为空；是否处于 waiting 状态。如果都通过，进入一个 while 循环
&lt;ul>
&lt;li>如果指令是有效的 &lt;code>if(pI)&lt;/code>
&lt;ul>
&lt;li>如果出现分支 &lt;code>if(pc != pI-&amp;gt;pc)&lt;/code>，刷掉 I-Buffer&lt;/li>
&lt;li>如果没有分支，此时 &lt;code>valid=true&lt;/code>，指令是有效的。如果通过 scoreboard 检测，终于可以执行了。先读取 active mask 确定要执行哪些线程，然后判断 &lt;code>pI-&amp;gt;op&lt;/code> 是 内存操作 还是 运算操作。如果相应的寄存器可以使用 &lt;code>has_free()&lt;/code>，则 call &lt;code>issue_warp()&lt;/code> 将寄存器、指令、active mask、warp id、scheduler id 发送并执行。&lt;/li>
&lt;li>&lt;code>warp_inst_issued = true;&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>else if 下一条指令是有效的
&lt;ul>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果指令成功发射 &lt;code>if (warp_inst_issued)&lt;/code>
&lt;ul>
&lt;li>call &lt;code>do_on_warp_issued(warp_id, issued, iter);&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>checked++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h5 id="scheduler_size">scheduler_size()&lt;/h5>
&lt;p>scheduler.size 就是2，代表一个 core 中 warp scheduler 的数量&lt;/p>
&lt;h5 id="lrr-特征">lrr 特征&lt;/h5>
&lt;ul>
&lt;li>单双数 round-robin 1-3-5-7-9, 2-4-6-8-10&lt;/li>
&lt;/ul>
&lt;p>Why? there are two schedulers per SM, an even and odd scheduler that concurrently execute even and odd warps.&lt;/p>
&lt;h5 id="gto-特征">gto 特征&lt;/h5>
&lt;p>贪心，没有 stall 的话会看到连续的 warp id 相同&lt;/p>
&lt;p>OP: 8 (LOAD) 后面可能会接一个相同 warp id 的 OP: 1 (ALU_OP)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>warp id:24 OP:6 &lt;span style="color:#75715e">#INTP_OP&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warp id:24 OP:8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>warp id:24 OP:1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="12-构造-scheduler">1.2 构造 scheduler&lt;/h3>
&lt;p>根据 warp scheduling policy 构造 scheduler。config 文件传入调度策略，&lt;code>shader_core_ctx::create_schedulers()&lt;/code> 根据传入的字符构造对应的 scheduler 类。&lt;/p>
&lt;h4 id="131-class-scheduler_unit">1.3.1 class scheduler_unit&lt;/h4>
&lt;h5 id="i-stdvector-shd_warp_t--m_next_cycle_prioritized_warps">I. std::vector&amp;lt; shd_warp_t* &amp;gt; m_next_cycle_prioritized_warps&lt;/h5>
&lt;p>This is the prioritized warp list that is looped over each cycle to determine which warp gets to issue.&lt;/p>
&lt;p>作为 order 函数的 result_list。每个 cycle 遍历这个 list，决定发射哪个 warp。已经按调度策略/优先级排序。size 为 24&lt;/p>
&lt;h5 id="ii-stdvector-shd_warp_t--m_supervised_warps">II. std::vector&amp;lt; shd_warp_t* &amp;gt; m_supervised_warps;&lt;/h5>
&lt;p>The m_supervised_warps list is &lt;strong>all the warps&lt;/strong> this scheduler is supposed to arbitrate between. This is useful in systems where there is more than one warp scheduler. In a single scheduler system, this is simply all the warps assigned to this core.&lt;/p>
&lt;p>这个作为 order 函数的 input_list，里面装了所有待仲裁的 warp。size 为 24&lt;/p>
&lt;p>在构造 scheduler 时，通过函数 &lt;code>add_supervised_war_id(i)&lt;/code> 向 m_supervised_warps 添加 warp。warp 0 -&amp;gt; scheduler 0, warp 1 -&amp;gt; scheduler 1, warp 2 -&amp;gt; scheduler 0&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> m_warp.size(); i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//distribute i&amp;#39;s evenly though schedulers;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> schedulers[i&lt;span style="color:#f92672">%&lt;/span>m_config&lt;span style="color:#f92672">-&amp;gt;&lt;/span>gpgpu_num_sched_per_core]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add_supervised_warp_id(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="iii-stdvector-shd_warp_t-const_iterator-m_last_supervised_issued">III. std::vector&amp;lt; shd_warp_t* &amp;gt;::const_iterator m_last_supervised_issued;&lt;/h5>
&lt;p>记录上一个被发射的 warp&lt;/p>
&lt;h2 id="2-from-paper">2. From Paper&lt;/h2>
&lt;h3 id="21-warp-scheduler">2.1 Warp Scheduler&lt;/h3>
&lt;p>The warp scheduler connects to the back end of the SIMT processor and is responsible for issuing instructions.&lt;/p>
&lt;blockquote>
&lt;p>warp scheduler 是 front-end and back-end 之间的连接&lt;/p>
&lt;/blockquote>
&lt;p>Because the registers for each warp are independent, saving and restoring warp states are not needed.&lt;/p>
&lt;blockquote>
&lt;p>warp 有自己独享的寄存器，所以无需专门保存 warp state&lt;/p>
&lt;/blockquote>
&lt;p>The warp scheduler only needs to keep track of those warps whose instructions are ready for issue.&lt;/p>
&lt;blockquote>
&lt;p>在 ready intructions 选一个来发射&lt;/p>
&lt;/blockquote>
&lt;p>If none of the warps are ready for issue or the back-end of the SIMT processor does not have enough free space, the warps are &lt;strong>stalled&lt;/strong> and no instruction is sent to the back-end of the SIMT processor.&lt;/p>
&lt;blockquote>
&lt;p>可以在 Output 中观察到，LRR and GTO 的 stall cycle 是不同的&lt;/p>
&lt;/blockquote>
&lt;h3 id="22-functional-units">2.2 Functional Units&lt;/h3>
&lt;p>The memory instructions and arithmetic instructions operate in different pipelines.&lt;/p>
&lt;p>Each back-end pipeline owns a set of dedicated collector units shared in a pool. The data from the collector units are sent to the functional units including arithmetic logic units (ALU) and load-store units (LSU).&lt;/p>
&lt;p>When an instruction from a warp occupies the arithmetic logic units, the other warps may use the load-store units to enhance instruction level parallelism and hide the latency.&lt;/p>
&lt;blockquote>
&lt;p>一个 warp 使用 ALU，其他的 warp 指令仍然可以使用 LSU。以此来隐藏延迟，增加并行度&lt;/p>
&lt;/blockquote>
&lt;p>As for the load-store units, the coalescer combines the memory requests within a warp, which allows fewer requests to be sent to the L1 cache memory. There are also miss status holding registers (MSHR) supporting multiple outstanding requests to external memory, which enhances the memory level parallelism to hide the latency.&lt;/p>
&lt;blockquote>
&lt;p>coalescing access, MSHR&lt;/p>
&lt;/blockquote></description></item><item><title>Software Design of GPGPU-Sim</title><link>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</link><pubDate>Sun, 14 Nov 2021 20:35:44 +0800</pubDate><guid>https://huweim.github.io/post/%E6%96%87%E6%A1%A3_software-design-of-gpgpu-sim/</guid><description>&lt;p>4 Software Design of GPGPU-Sim&lt;/p>
&lt;p>所有标题都可以升一级，整个文档全是 manual 的第 4 章&lt;/p>
&lt;h1 id="1-file-list-and-brief-description">1. File list and brief description&lt;/h1>
&lt;ul>
&lt;li>cuda-sim - The functional simulator that executes PTX kernels generated by NVCC or OpenCL compiler&lt;/li>
&lt;li>gpgpu-sim - The performance simulator that simulates the timing behavior of a GPU (or other many core accelerator architectures)&lt;/li>
&lt;li>intersim - The interconnection network simulator adopted from Bill Dally&amp;rsquo;s BookSim&lt;/li>
&lt;/ul>
&lt;h2 id="11-overallutilities">1.1 Overall/Utilities&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>abstract_hardware_model.h abstract_hardware_model.cc&lt;/th>
&lt;th>Provide a set of classes that interface between functional and timing simulator.&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>shader.h &lt;!-- raw HTML omitted -->shader.cc&lt;/td>
&lt;td>SIMT core timing model. It calls cudu-sim for functional simulation of a particular thread and cuda-sim would return with performance-sensitive information for the thread.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>visualizer.h &lt;!-- raw HTML omitted -->visualizer.cc&lt;/td>
&lt;td>Output dynamic statistics for the visualizer&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="13-gpgpu-sim">1.3 gpgpu-sim&lt;/h2>
&lt;p>几个需要注意的列出来，gluing 时钟频率，注意有单独的 gpu-cache.cc 和 l2cache.cc&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>gpu-sim.h gpu-sim.cc&lt;/th>
&lt;th>Gluing different timing models in GPGPU-Sim into one. It contains implementations to support multiple clock domains and implements the thread block dispatcher.&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="3-abstract-hardware-model">3. Abstract Hardware Model&lt;/h1>
&lt;p>The files abstract_hardware_model{.h,.cc} provide a set of classes that interface between functional and timing simulator.&lt;/p>
&lt;p>只列了一部分，查表的话去官方文档更方便，注意有单独的 cache operator type&lt;/p>
&lt;p>kernel function 的信息也存在里面了&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">Enum Name&lt;/th>
&lt;th style="text-align:center">Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">_memory_space_t&lt;/td>
&lt;td style="text-align:center">Memory space type (register, local, shared, global, &amp;hellip;)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">uarch_op_t&lt;/td>
&lt;td style="text-align:center">Type of operation (ALU_OP, SFU_OP, LOAD_OP, STORE_OP, &amp;hellip;)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">_memory_op_t&lt;/td>
&lt;td style="text-align:center">Defines whether instruction accesses (load or store) memory.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">mem_access_type&lt;/td>
&lt;td style="text-align:center">Different types of accesses in the timing simulator to different types of memories.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">cache_operator_type&lt;/td>
&lt;td style="text-align:center">Different types of &lt;strong>L1 data cache access&lt;/strong> behavior provided by PTX&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">&lt;strong>Class Name&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;strong>Description&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class kernel_info_t&lt;/td>
&lt;td style="text-align:center">Holds information of a kernel. It contains information like kernel function(function_info), &lt;strong>grid and block size&lt;/strong> and list of &lt;strong>active threads&lt;/strong> inside that kernel (ptx_thread_info).&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class core_t&lt;/td>
&lt;td style="text-align:center">Abstract base class of a core for both functional and performance model. shader_core_ctx (the class that implements a SIMT core in timing model) is derived from this class.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class memory_space_t&lt;/td>
&lt;td style="text-align:center">Information of a memory space like type of memory and number of banks for this memory space.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class mem_access_t&lt;/td>
&lt;td style="text-align:center">Contains information of each &lt;strong>memory access&lt;/strong> in the timing simulator. This class has information about type of memory access, requested address, size of data and active masks of threads inside warp accessing the memory.This class is used as one of parameters of mem_fetch class, which basically instantiated for each memory access. This class is for interfacing between two different level of memory and passing through interconnects.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">struct dram_callback_t&lt;/td>
&lt;td style="text-align:center">This class is the one who is responsible for atomic operations. The function pointer is set during functional simulation(atom_impl()) to atom_callback(&amp;hellip;). During timing simulation this function pointer is being called when in l2cache memory controller pop memory partition unit to interconnect. This function is supposed to compute result of atomic operation and saving it in memory.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class inst_t&lt;/td>
&lt;td style="text-align:center">Base class of all instruction classes. This class contains information about type and size of instruction, address of instruction, inputs and outputs, latency and memory scope (memory_space_t) of the instruction.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:center">class warp_inst_t&lt;/td>
&lt;td style="text-align:center">Data of instructions need during timing simulation. Each instruction (ptx_instruction) which is inherited from warp_inst_t contains data for timing and functional simulation. ptx_instruction is filled during functional simulation. After this level program needs only timing information so it casts ptx_instruction to warp_inst_t (some data is being loosed) for timing simulation. warp_inst_t inherited from inst_t. It holds &lt;strong>warp_id, active thread mask&lt;/strong> inside the warp, list of &lt;strong>memory accesses (mem_access_t)&lt;/strong> and information of threads inside that warp (per_thread_info)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="4-gpgpu-sim---performance-simulation-engine">4. GPGPU-sim - Performance Simulation Engine&lt;/h1>
&lt;h2 id="41-performance-model-software-objects">4.1 Performance Model Software Objects&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>ldst_unit &lt;span style="color:#f92672">*&lt;/span>m_ldst_unit;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>前面的 m 可能表示这个类型的变量&lt;/p>
&lt;h3 id="411-simt-core-cluster-class">4.1.1 SIMT Core Cluster Class&lt;/h3>
&lt;p>SIMT Core Cluster 通过类 &lt;code>simt_core_cluster&lt;/code> 建模。这个类在 &lt;code>m_core&lt;/code> 中包含一组 SIMT core 对象。&lt;code>simt_core_cluster::core_cycle()&lt;/code> 方法只是按顺序 循环调用 (cycles) 每个 SIMT core.&lt;/p>
&lt;p>&lt;code>simt_core_cluster::icnt_cycle()&lt;/code> 方法将内存请求从 interconnection network push 到 SIMT Core Cluster&amp;rsquo;s response FIFO. 它也将 FIFO 中的请求出队，送到合适的 core&amp;rsquo;s instruction cache or LDST unit. 这些与前面描述的硬件块密切对应。&lt;/p>
&lt;h3 id="412-simt-core-class-">4.1.2 SIMT Core Class ⭐&lt;/h3>
&lt;p>SIMT Core 中的微架构在 shader.h/cc 的类 shader_core_ctx 中实现&lt;/p>
&lt;ul>
&lt;li>shd_warp_t objects 的集合用于建模每个 warp 在 core 中的状态&lt;/li>
&lt;li>simt_stack object, 处理每个 warp 的分支&lt;/li>
&lt;li>set of scheduler_unit obj, 选择 set 中 warp 的一条 or 多条指令发射执行&lt;/li>
&lt;li>Scoreboard obj 处理 data hazard&lt;/li>
&lt;li>opndcoll_rfu_t obj, model operand collector&lt;/li>
&lt;li>set of &lt;code>simd_function_unit&lt;/code> obj 实现 ALU pipeline&lt;/li>
&lt;li>&lt;code>ldst_unit&lt;/code> 实现 memory pipeline&lt;/li>
&lt;li>&lt;code>shader_memroy_interface&lt;/code> 将 SIMT Core 连接到相应的 SIMT Core Cluster&lt;/li>
&lt;/ul>
&lt;p>每个 core cycle, 调用 &lt;code>shader_core_ctx::cycle()&lt;/code> 来模拟 SIMT Core 的一个 cycle。cycle function 以按从下往上的顺序 (也就是从 writeback() 到 fetch()) 调用下列函数&lt;/p>
&lt;ul>
&lt;li>fetch()&lt;/li>
&lt;li>decode()&lt;/li>
&lt;li>issue()&lt;/li>
&lt;li>read_operand()&lt;/li>
&lt;li>execute()&lt;/li>
&lt;li>writeback()&lt;/li>
&lt;/ul>
&lt;p>多个流水线阶段通过一组指向 &lt;code>warp_inst_t&lt;/code> 的流水线寄存器链接 (除了 Fetch and Decode, 它们通过 &lt;code>ifetch_buffer_t&lt;/code> 连接)&lt;/p>
&lt;blockquote>
&lt;p>也就是 Fetch 和 Decode 函数中的变量 m_inst_fetch_buffer&lt;/p>
&lt;/blockquote>
&lt;p>当访问特定于 SIMT core 的配置选项时，每个 &lt;code>shader_core_ctx&lt;/code> 对象引用一个公共 &lt;code>shader_core_config&lt;/code> 对象。所有 &lt;code>shader_core_ctx&lt;/code> 对象也链接到 &lt;code>shader_core_stats&lt;/code> 对象的一个普通实例，该对象跟踪所有 SIMT core 的一组性能测量值。&lt;/p>
&lt;h4 id="4121-fetch-and-decode-software-model">4.1.2.1 Fetch and Decode Software Model&lt;/h4>
&lt;p>I-Buffer 在 &lt;code>shd_warp_t&lt;/code> 类中作为数组实现，每个 &lt;code>shd_warp_t&lt;/code> 有集合 m_ibuffer，默认大小为 2&lt;/p>
&lt;blockquote>
&lt;p>可以修改 IBUFFER_SIZE 来调整每个 warp 的 I-Buffer slot 大小&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code>shd_warp_t&lt;/code> 也有标志位决定 warp 的 eligibility 以备发射。解码的指令存在 ibuffer_entry，作为指针指向 &lt;code>warp_inst_t&lt;/code> object, &lt;code>warp_inst_t&lt;/code> 保留指令使用的操作类型和操作数的信息&lt;/p>
&lt;p>&lt;strong>Fetch&lt;/strong>&lt;/p>
&lt;p>如果 decode stage 没有 stall, 即 &lt;code>m_inst_fetch_buffer&lt;/code> 没有有效指令，那么 fetch unit 就可以工作 (&lt;code>shader_core_ctx::m_inst_fetch_buffer&lt;/code> 作为 fetch 和 decode stage 之间的 pipeline register)&lt;/p>
&lt;blockquote>
&lt;p>也就是 fetch() 函数中的 !m_inst_fetch_buffer.m_valid 时进入最外层 if 语句&lt;/p>
&lt;/blockquote>
&lt;p>外层循环用于实现轮询调度器，最新调度的 warp id 存在 &lt;code>m_last_warp_fetched&lt;/code>。&lt;/p>
&lt;p>在 fetch() 函数中，进入最外层 if 语句，以及第2层中的 else 语句后，&lt;/p>
&lt;ul>
&lt;li>第3层中的第1个 if 语句检查 warp 是否已经完成执行&lt;/li>
&lt;li>第3层中的第2个 if 语句完成实际的从指令 cache 中取数据 (hit)，或者生成内存访问 (miss) 的操作。
&lt;ul>
&lt;li>第2个 if 语句主要是检查当前 warp 对应的 entry 是否已经存储了有效的指令
&lt;ul>
&lt;li>条件语句中的 &lt;code>m_warp[warp_id]-&amp;gt;ibuffer_empty()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Decode&lt;/strong>&lt;/p>
&lt;p>decode stage 简单地检查 &lt;code>shader_core_ctx::m_inst_fetch_buffer&lt;/code>，然后开始解码指令，当前配置是一个周期解码2条指令，并将其存入对应的 I-Buffer entry (也就是 &lt;code>m_ibuffer &lt;/code>)&lt;/p>
&lt;h4 id="4122-schedule-and-issue-software-model">4.1.2.2 Schedule and Issue Software Model&lt;/h4>
&lt;p>每个 core 中，有数量可配置的 scheduler unit. 在函数 &lt;code>shader_core_ctx::issue()&lt;/code> 中，会使用一个 for loop 遍历这些 scheduler unit，每个 scheduler unit 都调用 &lt;code>scheduler_unit::cycle()&lt;/code> 函数&lt;/p>
&lt;ul>
&lt;li>在 &lt;code>scheduler_unit::cycle()&lt;/code> 函数中，通过调用 &lt;code>shader_core_ctx::issue_warp()&lt;/code> 将指令发送到执行流水线&lt;/li>
&lt;li>&lt;strong>在 &lt;code>shader_core_ctx::issue_warp()&lt;/code> 函数中&lt;/strong>，指令通过调用 &lt;code>shader_core_ctx::func_exec_inst()&lt;/code> 来执行，调用 &lt;code>updateSIMTStack()&lt;/code> 中的 &lt;code>simt_stack::update()&lt;/code> 来更新 SIMT Stack。指令也会因为 &lt;code>warp_t:set_membar()&lt;/code> 以及 &lt;code>set_t::warp_reaches_barrier&lt;/code> 而等待/释放&lt;/li>
&lt;/ul>
&lt;p>另一方面，寄存器信息由 &lt;code>Scoreboard::reserveRegisters()&lt;/code> 保存。&lt;code>scheduler_unit::m_sp_out, scheduler_unit::m_sfu_out, scheduler_unit::m_mem_out&lt;/code> 分别指向 SP, SFU, Mem 流水线的 issue stage and execution stage 之间的第一个 pipeline register。这也是为什么在每条指令发射之前都要检查这些单元&lt;/p>
&lt;h4 id="4123-simt-stack-software-model">4.1.2.3 SIMT Stack Software Model&lt;/h4>
&lt;p>每个scheduler unit 有一个 SIMT stacks. 每个 SIMT stack 对应一个 warp&lt;/p>
&lt;blockquote>
&lt;p>所以 SIMT Stack 可以作为 warp scheduler unit 中的硬件实现，为一个 warp 服务&lt;/p>
&lt;/blockquote>
&lt;p>在 &lt;code>scheduler_unit::cycle()&lt;/code> 函数中，被调度的 warp 对应的 SIMT Stack 中的栈顶 entry 决定被发射的指令。栈顶 entry 的 PC value 通常与该 warp 对应 I-Buffer 下一条指令的 PC value 一致 (一致说明没有出现分支)。否则出现 control hazard, 它们如果不匹配，I-Buffer 中的指令会被 flush.&lt;/p>
&lt;blockquote>
&lt;p>也就是说这是一个简单的分支跳转检测机制。SIMT Stack 的栈顶存放的是下一条指令，也就是 next PC value. 无跳转情况下 I-Buffer 中的下一条指令的 PC value 应该和 SIMT Stack 栈顶的 next PC value 一致。&lt;/p>
&lt;p>如果不一致说明出现了跳转，那么在 I-Buffer 中的下一条指令的 PC value 是无效的，需要刷掉 I-Buffer&lt;/p>
&lt;/blockquote>
&lt;p>❓ ​SIMT Stack 在类 &lt;code>simt_stack&lt;/code> 中实现。SIMT Stack 在每次发射后通过函数 &lt;code>simt_stack::update(...)&lt;/code> 更新。函数 &lt;code>simt_stack::update(...)&lt;/code> (in abstarct_hardware_model.cc) 实现了在发散点和聚合点所需的算法。Functional execution (参见4.5，这个部分讲述了指令的执行) 是在更新 SIMT stack 之前的发射阶段执行的。这允许发射阶段拥有每个线程的 next PC 的信息，因此，可以根据需要更新 SIMT stack.&lt;/p>
&lt;blockquote>
&lt;p>Functional execution 是什么？可能要看了4.5才知道&lt;/p>
&lt;/blockquote>
&lt;h4 id="4124-scoreboard-software-model">4.1.2.4 Scoreboard Software Model&lt;/h4>
&lt;p>scoreboard unit 在 &lt;code>shader_core_ctx&lt;/code> 作为成员对象被实例化，通过引用 (指针) 传递到 &lt;code>scheduler_unit &lt;/code>。&lt;/p>
&lt;blockquote>
&lt;p>理解为 scoreboard 作为 core 的一个硬件单元&lt;/p>
&lt;/blockquote>
&lt;p>它存储了 shader core id (&lt;code>m_sid&lt;/code>) 和一个通过 warp id 索引的寄存器表 (&lt;code>reg_table&lt;/code>)。寄存器表存储了每个 warp 保留的寄存器的数量。 函数 &lt;code>Scoreboard::reserveRegisters(...), Scoreboard::releaseRegisters(...) and Scoreboard::checkCollision(...)&lt;/code> 分别用于保留寄存器，释放寄存器，在 warp 发射前检查冲突。&lt;/p>
&lt;h4 id="4125-operand-collector-software-model">4.1.2.5 Operand Collector Software Model&lt;/h4>
&lt;p>Operand Collector 建模在主流水线的一个阶段，由函数 &lt;code>shader_core_ctx::cycle()&lt;/code> 调用执行。这个阶段由函数 &lt;code> shader_core_ctx::read_operands()&lt;/code> 表示。关于 ALU Pipeline 的更多细节在下一节 1.2.6&lt;/p>
&lt;p>类 &lt;code>opndcoll_rfu_t &lt;/code> 基于寄存器文件单元建模了 operand collector. 包括 collector unit 集合，仲裁器，dispatch 单元的抽象。&lt;/p>
&lt;p>&lt;code>opndcoll_rfu_t::allocate_cu(...)&lt;/code> 用于将 &lt;code>warp_inst_t &lt;/code> 分配到给定 operand collector 集合中的空闲 operand collector. 它也将所有源操作数的读请求添加到仲裁器中相应的 bank 队列&lt;/p>
&lt;p>然而，&lt;code>opndcoll_rfu_t::allocate_reads(...)&lt;/code> 处理没有冲突的读请求，也就是不同寄存器 bank 中并且没有进入同一个 operand collector 的读请求将从仲裁器队列中出队。写请求总是优先于读请求。&lt;/p>
&lt;p>函数 &lt;code>opndcoll_rfu_t::dispatch_ready_cu()&lt;/code> 会 dispatch ready operand collectors 的操作数寄存器到执行阶段&lt;/p>
&lt;p>函数 &lt;code>opndcoll_rfu_t::writeback( const warp_inst_t &amp;amp;inst )&lt;/code> 在内存流水线的写回阶段被调用。用于分配写请求。&lt;/p>
&lt;p>上述内容总结了建模 operand collector 的主要函数的重点，更多的细节在源代码中的 &lt;code>shader.cc/h&lt;/code> 中的类 &lt;code>opndcoll_rfu_t&lt;/code>&lt;/p>
&lt;h4 id="4126-alu-pipeline-software-model">4.1.2.6 ALU Pipeline Software Model&lt;/h4>
&lt;p>SP 单元和 SFU 单元的时间模型主要在 &lt;code>shader.h&lt;/code> 中的类 &lt;code>pipelined_simd_unit&lt;/code> 中实现。建模这两个单元的特定类 (&lt;code>sp_unit&lt;/code> and &lt;code>sfu&lt;/code>) 派生自这个类 (&lt;code>pipelined_simd_unit&lt;/code>)，其中包含被重写的成员函数 &lt;code>can_issue()&lt;/code> ，用于指定单元可执行的指令类型。&lt;/p>
&lt;blockquote>
&lt;p>比如源代码中，类 &lt;code>sfu&lt;/code> 可以执行执行类型 &lt;code>SFU_OP, ALU_SFU_OP, DP_OP&lt;/code>&lt;/p>
&lt;/blockquote>
&lt;p>SP 单元通过流水线寄存器 &lt;code>OC_EX_SP&lt;/code> 连接 operand collector, SFU 单元通过流水线寄存器 &lt;code>OC_EX_SFU&lt;/code> 连接 operand collector. 两个单元通过流水线寄存器 &lt;code>WB_EX&lt;/code> 共享写回阶段。为了避免两个单元在写回阶段冲突而停滞，每一条进入任一单元的指令都必须在结果总线(&lt;code>m_result_bus&lt;/code>)中分配一个 slot，然后才会被发送到指定单元 (细节在 &lt;code>shader_core_ctx::execute()&lt;/code>)&lt;/p>
&lt;blockquote>
&lt;p>OC -&amp;gt; operand collector&lt;/p>
&lt;/blockquote>
&lt;p>下图说明了 &lt;code>pipelined_simd_unit&lt;/code> 如何建模不同类型指令的吞吐量和延迟&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>在每个 &lt;code>pipelined_simd_unit&lt;/code>, 成员函数 &lt;code>issue(warp_inst_t*&amp;amp;)&lt;/code> 将给定的流水线寄存器的内容移动到 &lt;code>m_dispatch_reg&lt;/code>. 指令在 &lt;code>m_dispatch_reg&lt;/code> 中等待 &lt;code>initiation_interval&lt;/code> cycles. 同时，没有其他指令被发射到这个单元，所以这个等待建模了指令的吞吐量。在等待后，指令派遣 (dispatch) 到内部流水线寄存器 &lt;code>m_pipeline_reg&lt;/code> 以建模延迟 (可以得到指令等待了多久才被派遣到 &lt;code>m_pipeline_reg&lt;/code>)。派遣位置是确定的，这样花费在 &lt;code>m_dispatch_reg&lt;/code> 中的时间也被计入延迟。每个周期，指令将通过流水线寄存器前进，最终进入 &lt;code>m_result_port&lt;/code>，这是 SP and SFU 单元的公共回写阶段的共享流水线寄存器 (&lt;code>WB_EX&lt;/code>)。&lt;/p>
&lt;p>每种指令类型的吞吐量和延迟在 &lt;code>cuda-sim.cc&lt;/code> 中的&lt;code>ptx_instruction::set_opcode_and_latency()&lt;/code> 中指定。这个函数在预解码期间被调用。&lt;/p>
&lt;blockquote>
&lt;p>指令吞吐量，一个 cycle 内处理指令的条数，也就是 ipc?&lt;/p>
&lt;p>延迟也就是指令等待的时间&lt;/p>
&lt;p>指令执行吞吐一般指的是每个时钟周期内可以执行的指令数目，不同指令的吞吐会有所不同。通常GPU的指令吞吐用每个SM每周期可以执行多少指令来计量。对于多数算术逻辑指令而言，指令执行吞吐只与SM内的单元有关，整个GPU的吞吐就是每个SM的吞吐乘以SM的数目。&lt;/p>
&lt;p>主要受以下因素影响&lt;/p>
&lt;ul>
&lt;li>&lt;strong>功能单元&lt;/strong>的数目&lt;/li>
&lt;li>指令&lt;strong>Dispatch Port&lt;/strong>和&lt;strong>Dispatch Unit&lt;/strong>的吞吐。
&lt;ul>
&lt;li>一个 warp 的指令要发射，首先要 eligible, 也就是没有等待 cache miss, 通过了 scoreboard 等待。&lt;/li>
&lt;li>其次要被 warp scheduler 选中，由 Dispatch Unit 发送到相应的 Dispatch Port. Kepler、Maxwell和Pascal是一个Warp Scheduler有两个Dispatch Unit，所以每cycle最多可以发射两个指令，也就是双发射。而Turing、Ampere每个Warp Scheduler只有一个Dispatch Unit，没有双发射，那每个周期就最多只能发一个指令。但是Kepler、Maxwell和Pascal都是一个Scheduler带32个单元（这里指full-throughput的单元），每周期都可以发新的warp。而Turing、Ampere是一个Scheduler带16个单元，每个指令要发两cycle，从而空出另一个cycle给别的指令用。&lt;/li>
&lt;li>&lt;strong>最后要求Dispatch Port或其他资源不被占用&lt;/strong>，port被占的原因可能是前一个指令的执行吞吐小于发射吞吐，导致要Dispatch多次，比如Turing的两个FFMA至少要stall 2cycle，LDG之类的指令至少是4cycle。更详细的介绍大家可以参考之前的专栏文章。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>GPR读写吞吐&lt;/strong>。绝大部分的指令都要涉及GPR的读写，由于Register File每个bank每个cycle的吞吐是有限的（一般是32bit），如果一个指令读取的GPR过多或是GPR之间有bank conflict，都会导致指令吞吐受影响。GPR的吞吐设计是影响指令发射的重要原因之一，有的时候甚至占主导地位，功能单元的数目配置会根据它和指令集功能的设计来定。比如NV常用的配置是4个Bank，每个bank每个周期可以输出一个32bit的GPR。这样FFMA这种指令就是3输入1输出，在没有bank conflict的时候可以一个cycle读完。其他如DFMA、HFMA2指令也会根据实际的输入输出需求，进行功能单元的配置。&lt;/li>
&lt;li>很多指令有&lt;strong>replay&lt;/strong>的逻辑（&lt;a href="https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/35566178/how-to-explain-instruction-replay-in-cuda">参考Greg Smith在StackOverflow上的一个回答&lt;/a>）。这就意味着有的指令一次发射可能不够。这并不是之前提过的由于功能单元少而连续占用多轮dispath port，而是指令处理的逻辑上有需要分批或是多次处理的部分。比如constant memory做立即数时的cache miss，memory load时的地址分散，shared memory的bank conflict，atomic的地址conflict，甚至是普通的cache miss或是TLB的miss之类。根据上面Greg的介绍，Maxwell之前，这些replay都是在warp scheduler里做的，maxwell开始将它们下放到了各级功能单元，从而节约最上层的发射吞吐。不过，只要有replay，相应dispath port的占用应该是必然的，这样同类指令的总发射和执行吞吐自然也就会受影响。
&lt;ul>
&lt;li>L1 cache miss 也有进行 replay 的逻辑&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="4127-memory-stage-software-model">4.1.2.7 Memory Stage Software Model&lt;/h4>
&lt;p>&lt;code>shader.cc&lt;/code> 中的类 &lt;code>ldst_unit&lt;/code> 实现了 shader 流水线的内存阶段。这个类实例化了所有 in-shader 内存的操作: texture (&lt;code>m_L1T&lt;/code>), constant (&lt;code>m_L1C&lt;/code>) and data (&lt;code>m_L1D&lt;/code>). &lt;code>ldst_unit::cycle()&lt;/code> implements the guts of the unit&amp;rsquo;s operation and is pumped &lt;code>m_config-&amp;gt;mem_warp_parts&lt;/code> times pre core cycle. 完全对齐的内存访问 (fully coalesced memory access) 可以在一个 shader cycle 内被处理。&lt;code>ldst_unit::cycle()&lt;/code> 处理来自 interconnect 的内存响应 (存在 &lt;code>m_response_fifo&lt;/code>), 填充 cache 并将存储标记为完成。这个函数还 cycles the caches 以便它们可以将未命中数据的请求发送给 interconnect.&lt;/p>
&lt;p>每种 L1 内存类型的 cache 访问分别在 &lt;code>shared_cycle(), constant_cycle(), texture_cycle()&lt;/code> and &lt;code>memory_cycle()&lt;/code> 中完成。&lt;/p>
&lt;ul>
&lt;li>&lt;code>memory_cycle()&lt;/code> 用于访问 L1 data cache.&lt;/li>
&lt;/ul>
&lt;p>每个函数会调用 &lt;code>process_memory_access_queue()&lt;/code>, 这是一个通用函数，它从指令内部访问队列中提取访问并将这个请求发送到 cache 中。如果访问不能再这个 cycle 中被处理 (即没有未命中，也没有命中 (也就是之前介绍中提到的第三个状态 reserved fail)，这可能发生在系统队列满的时候，或是所有 cache line reserved 但还没有 fill)，那么会在下个 cycle 再次试图访问。&lt;/p>
&lt;p>值得注意的是，并不是所有的指令都到达单元的写回阶段。在所有请求的 cache block 命中时，所有的 ST 指令和 LD 指令都将在 &lt;code>cycle&lt;/code> 函数中退出流水线。这是因为它们不需要等待来自 interconnect 的响应，并且可以 by-pass 写回逻辑，该逻辑保存指令所请求的 cache line 和那些已经返回的 cache line。&lt;/p>
&lt;h4 id="4128-cache-software-model">4.1.2.8 Cache Software Model&lt;/h4>
&lt;p>&lt;code>gpu-cache.h&lt;/code> 实现了 &lt;code>ldst_unit&lt;/code> 用到的所有 cache. constant cache and data cache 都包含一个成员对象 &lt;code>tag_array&lt;/code>，用于实现保留和替换的逻辑。函数 &lt;code>probe()&lt;/code> 检查 cache block 地址而不影响相关数据的 LRU 位置, 函数 &lt;code>access()&lt;/code> 旨在建模影响 LRU 位置的查找，生成未命中和访问的统计信息。MSHR 用类 &lt;code>msgr_table&lt;/code> 建模，它建模了一个全相联 table, 合并有限数量的请求。请求通过 &lt;code>next_access()&lt;/code> 函数从MSHR释放。&lt;/p>
&lt;p>类 &lt;code>read_only_cache&lt;/code> 被 constant cache 使用，并作为类 &lt;code>data_cache&lt;/code> 的基类。这个层次结构可能有点令人困惑，因为 R/W data cache 是从 &lt;code>read_only_cache&lt;/code> 扩展的 (理解为 R/W data cache 就是在只读 cache 类基础上加了一些功能来实现，从代码角度很好理解这句话)。原因是它们共享很多相同功能的函数，除了函数 &lt;code>access&lt;/code> 需要写 &lt;code>data_cacje&lt;/code> 这一点有所区别。L2 cache 也是通过类 &lt;code>data_cache&lt;/code> 实现。&lt;/p>
&lt;blockquote>
&lt;p>这一点从 C 语言中类的角度去理解就好&lt;/p>
&lt;/blockquote>
&lt;p>类 &lt;code>tex_cache&lt;/code> 实现 texture cache. 它没有使用 &lt;code>tag_array&lt;/code> 或是 &lt;code>mshr_table&lt;/code>，因为它的操作和传统 cache 不太一样&lt;/p>
&lt;h4 id="4129-thread-block--cta--work-group-scheduling">4.1.2.9 Thread Block / CTA / Work Group Scheduling&lt;/h4>
&lt;p>Thread Block 向 SIMT cores 的调度在 &lt;code>shader_core_ctx::issue_block2core(...)&lt;/code> 中实现。一个 core 中可以并行调度的最大 block 数量由函数 &lt;code>shader_core_config::max_cta(...)&lt;/code> 计算。这个函数基于程序中定义的 ThreadPerBlock (CUDA 编程中由程序员定义), 以及每个线程的寄存器使用情况、共享内存使用情况以及每个 core 的最大线程块数量的配置限制来计算上述 &lt;strong>可以并行调度的最大 block 数量&lt;/strong>。具体地说，计算可以分配给 SIMT core 的 block 数量，上面的每个标准都是限制因素。其中的最小值是可以分配给 SIMT core 的最大 block 数量。&lt;/p>
&lt;blockquote>
&lt;p>各种资源中的短板决定了最多可以有多少个 block 并行。CUDA 编程的知识&lt;/p>
&lt;/blockquote>
&lt;p>在函数 &lt;code>shader_core_ctx::issue_block2core(...)&lt;/code> 中，block size 首先被填充为 warp size 的倍数。然后决定一个空闲硬件 thread id 的范围。通过调用函数 &lt;code>ptx_sim_init_thread&lt;/code> 来初始化每个线程的函数状态。调用函数 &lt;code>shader_core_ctx::init_warp&lt;/code> 初始化 SIMT stack and warp state.&lt;/p>
&lt;p>当每条线程完成，SIMT core 调用函数 &lt;code>shader_core_ctx::init_warp(...)&lt;/code> 来更新 active thread block 的状态。当 block 内所有线程完成执行， 同一个函数会减少 core 上 active block 的数量，允许在下一 cycle 调度更多 block. 从 pending kernels 中选择要调度的新线程块。&lt;/p>
&lt;h3 id="4413-interconnection-network">4.4.1.3 Interconnection Network&lt;/h3>
&lt;p>Interconnection Network 接口有以下几个功能。这些函数在 &lt;code>interconnect_interface.cpp&lt;/code> 中实现。这些函数被封装在 &lt;code>icnt_wrapper.cpp&lt;/code> 中。使用&lt;code>icnt_wrapper.cpp&lt;/code> 的最初目的是允许其他 network 模拟器连接到 GPGPU-Sim。&lt;/p>
&lt;ul>
&lt;li>&lt;code>init_interconnect()&lt;/code>: 初始化网络模拟器。它的输入是互连网络的配置文件和SIMT核心团簇和内存节点的数量。&lt;/li>
&lt;li>&lt;code>interconnect_push()&lt;/code>: 指定源节点、目的节点、指向要传输的数据包的指针和数据包大小(以字节为单位)。&lt;/li>
&lt;li>&lt;code>interconnect_pop()&lt;/code>: 获取一个节点号作为输入，并返回一个指向在该节点等待被弹出的数据包的指针。如果没有数据包，则返回NULL。&lt;/li>
&lt;li>&lt;code>interconnect_has_buffer()&lt;/code>: 获取作为输入要发送的节点号和数据包大小，如果源节点的输入缓冲区有足够的空间，则返回1 (true)。&lt;/li>
&lt;li>&lt;code>advance_interconnect()&lt;/code>: 应该在每个互连时钟周期被调用。顾名思义，它在一个周期内完成网络的所有内部步骤。&lt;/li>
&lt;li>&lt;code>interconnect_busy()&lt;/code>: 如果网络中有一个正在传输的数据包，则返回1 (true)&lt;/li>
&lt;li>&lt;code>interconnect_stats()&lt;/code>: 打印网络统计信息。&lt;/li>
&lt;/ul>
&lt;h3 id="415-memory-partition">4.1.5 Memory Partition&lt;/h3>
&lt;p>l2cache.cc/h 中有 class &lt;code>memory_partition_unit&lt;/code>&lt;/p>
&lt;p>II. L2 Cache Model&lt;/p>
&lt;p>&lt;code>mem_fetch *mf = m_L2cache-&amp;gt;next_access();&lt;/code> 产生等待 fill MSHR entry 的内存请求的 reply,&lt;/p></description></item><item><title>GPU_benchmark说明（转）</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</link><pubDate>Sun, 14 Nov 2021 20:34:48 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpu_benchmark%E8%AF%B4%E6%98%8E%E8%BD%AC/</guid><description>&lt;h1 id="introduction">Introduction&lt;/h1>
&lt;p>本文内容主要系摘录翻译自&lt;a href="http://parse.ele.tue.nl/ali">Ang Li&lt;/a>的博士毕业论文。&lt;/p>
&lt;h1 id="1perfect">1.Perfect&lt;/h1>
&lt;p>Power Efficiency Revolution for Embedded Computing&lt;/p>
&lt;p>&lt;a href="http://hpc.pnl.gov/PERFECT/">http://hpc.pnl.gov/PERFECT/&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;strong>Application Domains&lt;/strong>&lt;/th>
&lt;th style="text-align:left">&lt;strong>Kernels&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">PERFECT Application 1&lt;/td>
&lt;td style="text-align:left">Discrete Wavelet Transform&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">2D Convolution&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Histogram Equalization&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Space Time Adaptive Processing&lt;/td>
&lt;td style="text-align:left">System Solver&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Inner Product&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Outer Product&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Synthetic Aperture Radar&lt;/td>
&lt;td style="text-align:left">Interpolation 1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Interpolation 2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Back Projection (Non-Fourier SAR)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Wide Area Motion Imaging&lt;/td>
&lt;td style="text-align:left">Debayer&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Image Registration&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">Change Detection&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Required Kernels&lt;/td>
&lt;td style="text-align:left">Sort&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FFT 1D&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;/td>
&lt;td style="text-align:left">FFT 2D&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="2-axbench">2. AxBench&lt;/h1>
&lt;p>A Multiplatform Benchmark Suite for Approximate Computing&lt;/p>
&lt;p>One of the goals of AxBench is to provide a diverse set of applications to further facilitate research and development in approximate computing.&lt;/p>
&lt;p>&lt;a href="http://ieeexplore.ieee.org/abstract/document/7755728/">http://ieeexplore.ieee.org/abstract/document/7755728/&lt;/a>&lt;/p>
&lt;p>下载地址&lt;/p>
&lt;p>&lt;a href="http://axbench.org/">http://axbench.org/&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">benchmark&lt;/th>
&lt;th style="text-align:left">platform&lt;/th>
&lt;th style="text-align:left">domain&lt;/th>
&lt;th style="text-align:left">Quality Metric&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">binarization&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">blackscholes&lt;/td>
&lt;td style="text-align:left">CPU, GPU&lt;/td>
&lt;td style="text-align:left">Finance&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">brent-kung&lt;/td>
&lt;td style="text-align:left">ASIC&lt;/td>
&lt;td style="text-align:left">Arithmetic Computation&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">canneal&lt;/td>
&lt;td style="text-align:left">CPU&lt;/td>
&lt;td style="text-align:left">Optimization&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">convolution&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Machine Learning&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fastwalsh&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fft&lt;/td>
&lt;td style="text-align:left">CPU&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fir&lt;/td>
&lt;td style="text-align:left">ASIC&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">forwardk2j&lt;/td>
&lt;td style="text-align:left">CPU, ASIC&lt;/td>
&lt;td style="text-align:left">Robotics&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">inversek2j&lt;/td>
&lt;td style="text-align:left">CPU, GPU, ASIC&lt;/td>
&lt;td style="text-align:left">Robotics&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">jmeint&lt;/td>
&lt;td style="text-align:left">CPU, GPU&lt;/td>
&lt;td style="text-align:left">3D Gaming&lt;/td>
&lt;td style="text-align:left">Miss Rate&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">jpeg&lt;/td>
&lt;td style="text-align:left">CPU&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">kmeans&lt;/td>
&lt;td style="text-align:left">CPU, ASIC&lt;/td>
&lt;td style="text-align:left">Machine Learning&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">kogge-stone&lt;/td>
&lt;td style="text-align:left">ASIC&lt;/td>
&lt;td style="text-align:left">Arithmetic Computation&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">laplacian&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">meanfilter&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Machine Vision&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">neural network&lt;/td>
&lt;td style="text-align:left">ASIC&lt;/td>
&lt;td style="text-align:left">Machine Learning&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">newton-raph&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Numerical Analysis&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sobel&lt;/td>
&lt;td style="text-align:left">CPU, GPU, ASIC&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">srad&lt;/td>
&lt;td style="text-align:left">GPU&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Image Diff&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">wallace-tree&lt;/td>
&lt;td style="text-align:left">ASIC&lt;/td>
&lt;td style="text-align:left">Arithmetic Computation&lt;/td>
&lt;td style="text-align:left">Avg. Relative Error&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="3-rodinia">3. Rodinia&lt;/h1>
&lt;p>&lt;a href="http://rodinia.cs.virginia.edu/">http://rodinia.cs.virginia.edu/&lt;/a>&lt;/p>
&lt;p>下载页面：&lt;/p>
&lt;p>&lt;a href="http://lava.cs.virginia.edu/Rodinia/download_links.htm">http://lava.cs.virginia.edu/Rodinia/download_links.htm&lt;/a>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">&lt;/th>
&lt;th style="text-align:left">&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">Applications&lt;/td>
&lt;td style="text-align:left">Dwarves&lt;/td>
&lt;td style="text-align:left">Domains&lt;/td>
&lt;td style="text-align:left">Parallel Model&lt;/td>
&lt;td style="text-align:left">Incre. Ver.&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Leukocyte">Leukocyte&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">√&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Heart_Wall">Heart Wall&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/MUMmerGPU">MUMmerGPU&lt;/a>&lt;/td>
&lt;td style="text-align:left">Graph Traversal&lt;/td>
&lt;td style="text-align:left">Bioinformatics&lt;/td>
&lt;td style="text-align:left">CUDA, OMP&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/CFD_Solver">CFD Solver1&lt;/a>&lt;/td>
&lt;td style="text-align:left">Unstructured Grid&lt;/td>
&lt;td style="text-align:left">Fluid Dynamics&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/LU_Decomposition">LU Decomposition&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dense Linear Algebra&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">√&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/HotSpot">HotSpot&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Physics Simulation&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Back_Propagation">Back Propagation&lt;/a>&lt;/td>
&lt;td style="text-align:left">Unstructured Grid&lt;/td>
&lt;td style="text-align:left">Pattern Recognition&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Needleman-Wunsch">Needleman-Wunsch&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dynamic Programming&lt;/td>
&lt;td style="text-align:left">Bioinformatics&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">√&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/K-Means">Kmeans&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dense Linear Algebra&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Graph_traversal">Breadth-First Search1&lt;/a>&lt;/td>
&lt;td style="text-align:left">Graph Traversal&lt;/td>
&lt;td style="text-align:left">Graph Algorithms&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/SRAD">SRAD&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">√&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Streamcluster">Streamcluster1&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dense Linear Algebra&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Particle_Filter">Particle Filter&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Shortest_Path">PathFinder&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dynamic Programming&lt;/td>
&lt;td style="text-align:left">Grid Traversal&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Gaussian_Elimination">Gaussian Elimination&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dense Linear Algebra&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">CUDA, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Nearest_Neighbor">k-Nearest Neighbors&lt;/a>&lt;/td>
&lt;td style="text-align:left">Dense Linear Algebra&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/LavaMD">LavaMD2&lt;/a>&lt;/td>
&lt;td style="text-align:left">N-Body&lt;/td>
&lt;td style="text-align:left">Molecular Dynamics&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Myocyte">Myocyte&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Biological Simulation&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/B%2B_Tree">B+ Tree&lt;/a>&lt;/td>
&lt;td style="text-align:left">Graph Traversal&lt;/td>
&lt;td style="text-align:left">Search&lt;/td>
&lt;td style="text-align:left">CUDA, OMP, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/GPUDWT">GPUDWT&lt;/a>&lt;/td>
&lt;td style="text-align:left">Spectral Method&lt;/td>
&lt;td style="text-align:left">Image/Video Compression&lt;/td>
&lt;td style="text-align:left">CUDA, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php/Hybrid_Sort">Hybrid Sort&lt;/a>&lt;/td>
&lt;td style="text-align:left">Sorting&lt;/td>
&lt;td style="text-align:left">Sorting Algorithms&lt;/td>
&lt;td style="text-align:left">CUDA, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php?title=Hotspot3D&amp;amp;action=edit&amp;amp;redlink=1">Hotspot3D&lt;/a>&lt;/td>
&lt;td style="text-align:left">Structured Grid&lt;/td>
&lt;td style="text-align:left">Physics Simulation&lt;/td>
&lt;td style="text-align:left">CUDA, OCL, OMP&lt;/td>
&lt;td style="text-align:left">Hotspot for 3D IC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;a href="https://www.cs.virginia.edu/~skadron/wiki/rodinia/index.php?title=Huffman&amp;amp;action=edit&amp;amp;redlink=1">Huffman&lt;/a>&lt;/td>
&lt;td style="text-align:left">Finite State Machine&lt;/td>
&lt;td style="text-align:left">Lossless data compression&lt;/td>
&lt;td style="text-align:left">CUDA, OCL&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Ang Li的分类：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">OpenMP&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">backprop&lt;/td>
&lt;td style="text-align:left">Perceptron back propagation&lt;/td>
&lt;td style="text-align:left">Neural Network&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bfs&lt;/td>
&lt;td style="text-align:left">Breadth first search&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">b+tree&lt;/td>
&lt;td style="text-align:left">B+tree Operation&lt;/td>
&lt;td style="text-align:left">Searching Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">leukocyte&lt;/td>
&lt;td style="text-align:left">Detect leukocytes in blood vessel video&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">heartwall&lt;/td>
&lt;td style="text-align:left">Tracks the mouse heart movement by stimulus&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">cfd&lt;/td>
&lt;td style="text-align:left">Finite volume solver for 3D Euler equations for flow&lt;/td>
&lt;td style="text-align:left">Fluid Dynamics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lud&lt;/td>
&lt;td style="text-align:left">Calculate the solutions of a set of linear equations&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">hotspot&lt;/td>
&lt;td style="text-align:left">Estimate processor temperature&lt;/td>
&lt;td style="text-align:left">Physical Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">nw&lt;/td>
&lt;td style="text-align:left">Optimization method for DNA sequence alignments&lt;/td>
&lt;td style="text-align:left">Bioinformatics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">kmeans&lt;/td>
&lt;td style="text-align:left">Clustering algorithm&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">srad&lt;/td>
&lt;td style="text-align:left">Speckle reducing anisotropic diffusion&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">streamcluster&lt;/td>
&lt;td style="text-align:left">Finds medians to assign points to nearest centers&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">particlefilter&lt;/td>
&lt;td style="text-align:left">Locate object location based on Noise and path&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pathfinder&lt;/td>
&lt;td style="text-align:left">Dynamic programming to find a path on a 2D grid Grid&lt;/td>
&lt;td style="text-align:left">Traversal&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">gaussian&lt;/td>
&lt;td style="text-align:left">Solving variables in a linear system&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">nn&lt;/td>
&lt;td style="text-align:left">Find k-nearest neighbors from an unstructured data set&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lavaMD&lt;/td>
&lt;td style="text-align:left">Calculate particle potential and relocation in 3D&lt;/td>
&lt;td style="text-align:left">Molecular Dynamics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">myocyte&lt;/td>
&lt;td style="text-align:left">Simulate the behavior of cardiac hear muscle cell&lt;/td>
&lt;td style="text-align:left">Biological Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="4-parboil">4. Parboil&lt;/h1>
&lt;p>Parboil强调面向吞吐量的流媒体应用。其中的每个应用都有原生的CUDA应用和优化过的应用。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">bfs&lt;/td>
&lt;td style="text-align:left">Breadth-first-search&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">cutcp&lt;/td>
&lt;td style="text-align:left">Compute Coulombic potential for a 3D grid&lt;/td>
&lt;td style="text-align:left">Molecular Dynamics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">histogram&lt;/td>
&lt;td style="text-align:left">Compute 2D saturating histogram with maximum 256 bins&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lbm&lt;/td>
&lt;td style="text-align:left">Fluid dynamics simulation using Lattice-Bolzmann Method&lt;/td>
&lt;td style="text-align:left">Fluid Dynamics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mm&lt;/td>
&lt;td style="text-align:left">Dense matrix-matrix multiply&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mri-gridding&lt;/td>
&lt;td style="text-align:left">Compute regular data grid via weighted interpolation&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mir-q&lt;/td>
&lt;td style="text-align:left">Compute scanner configuration for calibration in 3D MRI&lt;/td>
&lt;td style="text-align:left">Medical Imaging&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sad&lt;/td>
&lt;td style="text-align:left">Sum of absolute differences kernel in MPEG video encoders&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">spmv&lt;/td>
&lt;td style="text-align:left">Compute the product of a sparse matrix with a dense vector&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">stencil&lt;/td>
&lt;td style="text-align:left">An iterative Jacobi stencil operation on a regular 3D grid&lt;/td>
&lt;td style="text-align:left">Cellular Automation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">tpacf&lt;/td>
&lt;td style="text-align:left">Analyze the spatial distribution of astronomical bodies&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="5-shoc">5. Shoc&lt;/h1>
&lt;p>测量协处理的稳定性和性能，such as GPUs, Xeon-Phi, etc。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">qtclustering&lt;/td>
&lt;td style="text-align:left">Group genes into high quality clusters&lt;/td>
&lt;td style="text-align:left">Bioinformatics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">s3d&lt;/td>
&lt;td style="text-align:left">Compute chemical reaction rate across a 3D grid&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">scan&lt;/td>
&lt;td style="text-align:left">Parallel prefix sum of floating point numbers&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">reduction&lt;/td>
&lt;td style="text-align:left">Sum reduction operation of floating point numbers&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">md&lt;/td>
&lt;td style="text-align:left">Lennard-Jones potential computations&lt;/td>
&lt;td style="text-align:left">Molecular Dynamics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fft&lt;/td>
&lt;td style="text-align:left">Fast Fourier transform&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sgemm&lt;/td>
&lt;td style="text-align:left">Single precision general matrix multiply&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sort&lt;/td>
&lt;td style="text-align:left">Fast radix sort program&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">stencil2d&lt;/td>
&lt;td style="text-align:left">Standard 2d 9 points stencil calculation&lt;/td>
&lt;td style="text-align:left">Cellular Automation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bfs&lt;/td>
&lt;td style="text-align:left">Breadth-first-search&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">spmv&lt;/td>
&lt;td style="text-align:left">Sparse matrix vector multiplication&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="6-polybench">6. Polybench&lt;/h1>
&lt;p>包含从[非]结构循环嵌套转换的Kernel。这些循环以前用于评估基于多面体模型的优化工具。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">2dconv&lt;/td>
&lt;td style="text-align:left">2D convolution&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">2mm&lt;/td>
&lt;td style="text-align:left">2 matrix multiply&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">3dconv&lt;/td>
&lt;td style="text-align:left">3D convolution&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">3mm&lt;/td>
&lt;td style="text-align:left">3 matrix multiply&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">atax&lt;/td>
&lt;td style="text-align:left">Matrix transpose and vector multiplication&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bicg&lt;/td>
&lt;td style="text-align:left">Bicg kernel for BiCGStab linear solver&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">corr&lt;/td>
&lt;td style="text-align:left">Correlation computation&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">covar&lt;/td>
&lt;td style="text-align:left">Covariance computation&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fdtd2d&lt;/td>
&lt;td style="text-align:left">2D finite difference time domain kernel&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">gemm&lt;/td>
&lt;td style="text-align:left">matrix multiply&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">gesummv&lt;/td>
&lt;td style="text-align:left">Scalar vector and matrix multiplication&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">gramschm&lt;/td>
&lt;td style="text-align:left">Gram-schmidt process&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mvt&lt;/td>
&lt;td style="text-align:left">Matrix vector product and transpose&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">syr2k&lt;/td>
&lt;td style="text-align:left">Symmetric rank-2k operations&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">syrk&lt;/td>
&lt;td style="text-align:left">Symmetric rank-k operations&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="7-mars">7. Mars&lt;/h1>
&lt;p>用map reduce实现的data-mining的benchmark。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">sm&lt;/td>
&lt;td style="text-align:left">Find the position of a string in a file&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ii&lt;/td>
&lt;td style="text-align:left">Build inverted index for links in HTML files&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ss&lt;/td>
&lt;td style="text-align:left">Compute pair-wise similarity score for docs&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mm&lt;/td>
&lt;td style="text-align:left">Multiply two matrices&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pvc&lt;/td>
&lt;td style="text-align:left">Count distinct page views from web logs&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pvr&lt;/td>
&lt;td style="text-align:left">Find the top ten hottest pages in the web log&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="8-longstar">8. Longstar&lt;/h1>
&lt;p>关注于不规则的应用，主要是数据依赖和拓扑依赖。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">bfs&lt;/td>
&lt;td style="text-align:left">Breadth first search&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">bh&lt;/td>
&lt;td style="text-align:left">Simulate the gravitational forces in Barnes-Hut&lt;/td>
&lt;td style="text-align:left">algorithm Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dc&lt;/td>
&lt;td style="text-align:left">Lossless compression upon double-precision FP data&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dmr&lt;/td>
&lt;td style="text-align:left">Meshrefinement algorithm from computational geometry&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">pta&lt;/td>
&lt;td style="text-align:left">Andersen’s flow/context-insensitive points-to analysis&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sp&lt;/td>
&lt;td style="text-align:left">Heuristic SAT-solver based on BaYesian inference&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sssp&lt;/td>
&lt;td style="text-align:left">Shortest path in a directed graph with weighted edges&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">tsp&lt;/td>
&lt;td style="text-align:left">Traveling salesman problem&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="9-cuda-sdk">9. CUDA SDK&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">bilateralFilter&lt;/td>
&lt;td style="text-align:left">Edge-preserving non-linear smoothing filter&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">binomialOption&lt;/td>
&lt;td style="text-align:left">Evaluate option call price using binomial model&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">BlackScholes&lt;/td>
&lt;td style="text-align:left">Evaluate option call price using Black-Scholes model&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">convolutionFFT2D&lt;/td>
&lt;td style="text-align:left">2D convolutions using FFT&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dct8x8&lt;/td>
&lt;td style="text-align:left">Discrete cosine transform for blocks of 8 by 8 pixels&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dxtc&lt;/td>
&lt;td style="text-align:left">High quality DXT compression&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dwtHaar1D&lt;/td>
&lt;td style="text-align:left">1D discrete Haar wavelet decomposition&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">eigenvalues&lt;/td>
&lt;td style="text-align:left">Eigenvalues of a tridiagonal symmetric matrix&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">fastWalshTransform&lt;/td>
&lt;td style="text-align:left">Hadamard-ordered Fast Walsh transform&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">FDTD3d&lt;/td>
&lt;td style="text-align:left">Finite differences&lt;/td>
&lt;td style="text-align:left">time domain progression stencil&lt;/td>
&lt;td style="text-align:left">Cellular Automation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">grabcutNPP&lt;/td>
&lt;td style="text-align:left">GrabCut approach using the 8 neighborhood&lt;/td>
&lt;td style="text-align:left">Graph Algorithm&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">histogram&lt;/td>
&lt;td style="text-align:left">64/256 bin histogram&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">imageDenoising&lt;/td>
&lt;td style="text-align:left">Using KNN and NLM for image denoising&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lineOfSight&lt;/td>
&lt;td style="text-align:left">A simple line-of-sight algorithm&lt;/td>
&lt;td style="text-align:left">Graphic Application&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">Mandelbrot&lt;/td>
&lt;td style="text-align:left">Mandelbrot or Julia sets interactively&lt;/td>
&lt;td style="text-align:left">Graphic Application&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">matrixMul&lt;/td>
&lt;td style="text-align:left">Matrix multiplication&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mergeSortv&lt;/td>
&lt;td style="text-align:left">Merge Sort algorithm&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">MersenneTwister&lt;/td>
&lt;td style="text-align:left">The Mersenne Twister random number generator&lt;/td>
&lt;td style="text-align:left">Signal Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">MonteCarlo&lt;/td>
&lt;td style="text-align:left">Evaluate option call price using Monte Carlo approach&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">nbody&lt;/td>
&lt;td style="text-align:left">All-pairs gravitational n-body simulation&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">oceanFFT&lt;/td>
&lt;td style="text-align:left">Simulate an Ocean height field&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">reduction&lt;/td>
&lt;td style="text-align:left">Compute the sum of a large arrays of values&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">scalarProd&lt;/td>
&lt;td style="text-align:left">Calculate scalar products of input vector pairs&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">scan&lt;/td>
&lt;td style="text-align:left">Parallel prefix sum&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">SobelFilter&lt;/td>
&lt;td style="text-align:left">Sobel edge detection filter for 8-bit monochrome images&lt;/td>
&lt;td style="text-align:left">Image Processing&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">SobolQRNG&lt;/td>
&lt;td style="text-align:left">Sobol Quasirandom Sequence Generator&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">transpose&lt;/td>
&lt;td style="text-align:left">Matrix transpose&lt;/td>
&lt;td style="text-align:left">Linear Algebra&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="10-gpgpu-sim">10. GPGPU-Sim&lt;/h1>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">Application&lt;/th>
&lt;th style="text-align:left">Description&lt;/th>
&lt;th style="text-align:left">Domain&lt;/th>
&lt;th style="text-align:left">CUDA&lt;/th>
&lt;th style="text-align:left">OpenCL&lt;/th>
&lt;th style="text-align:left">C&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">aes&lt;/td>
&lt;td style="text-align:left">AES algorithm in CUDA to encrypt and decrypt files&lt;/td>
&lt;td style="text-align:left">Cryptography&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">dc&lt;/td>
&lt;td style="text-align:left">A discontinuous Galerkin time-domain solver&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lps&lt;/td>
&lt;td style="text-align:left">3D Laplace Solver&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">lib&lt;/td>
&lt;td style="text-align:left">Monte Carlo simulation in London-interbank-offered-rate Model&lt;/td>
&lt;td style="text-align:left">Computational Finance&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">mum&lt;/td>
&lt;td style="text-align:left">Pairwise local sequence alignment for DNA string&lt;/td>
&lt;td style="text-align:left">Bioinformatics&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">nn&lt;/td>
&lt;td style="text-align:left">Convolutional neural network to recognize handwritten digits&lt;/td>
&lt;td style="text-align:left">Machine Learning&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">nqu&lt;/td>
&lt;td style="text-align:left">The N-Queen solver&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">ray&lt;/td>
&lt;td style="text-align:left">Ray-tracing (rendering graphics with near photo-realism)&lt;/td>
&lt;td style="text-align:left">Graphic Application&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">sto&lt;/td>
&lt;td style="text-align:left">Sliding-window implementation of the MD5 algorithm&lt;/td>
&lt;td style="text-align:left">Data Mining&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">wp&lt;/td>
&lt;td style="text-align:left">Accelerate part of the Weather Research and Forecast Model (WRF)&lt;/td>
&lt;td style="text-align:left">Simulation&lt;/td>
&lt;td style="text-align:left">Yes&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;td style="text-align:left">No&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://www.findhao.net/easycoding/2304.html">https://www.findhao.net/easycoding/2304.html&lt;/a>&lt;/p></description></item><item><title>如何评价自己的编程能力</title><link>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/</link><pubDate>Mon, 11 Oct 2021 19:52:15 +0800</pubDate><guid>https://huweim.github.io/post/%E6%80%BB%E7%BB%93_%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>从入学以来，编程能力一直放在自己需要提升的部分当中。慢慢的学习了一些常用的算法，Leetcode 上也刷了更多的题。自己在课程作业中比着葫芦画瓢完成了一些小的 project，现在使用模拟器也需要阅读 C/C++ 代码。不过还是存在疑惑，什么才叫做编程能力呢？如何评估自己的编程能力呢？&lt;/p>
&lt;h1 id="1-个人理解">1. 个人理解&lt;/h1>
&lt;ul>
&lt;li>针对实际应用，top to down 的抽象。需要在脑海中建立相应的一套模型，包括类的构造、函数需求等等。&lt;/li>
&lt;li>动手实现的能力。有了思路后快速构造出模型，并加以验证，通过反馈不断地迭代自己的代码。这个应该算是实实在在的 coding 能力。&lt;/li>
&lt;li>Debug 能力。目前对于真正工程中的 Debug 还是有一些困惑。&lt;/li>
&lt;/ul>
&lt;p>总结了一些东西，归根结底是感觉自己虽然写了一些小 project，但还是什么都不会，编程能力很差，不知道怎么办。但是好像学再多的知识还是有这种感觉。所以有想法可能得先做起来。该有的东西都学了，还没学的东西，只有需要用到的时候去学，才能记得深刻。&lt;/p>
&lt;p>这也是为什么觉得 CS 课程里面的 lab 是最重要的东西，最让人印象深刻的东西。做 lab 之前我也什么都不会，但是没办法我需要在 Due 之前做出来，不然就拿不到分。于是我去搜索相关资料，我去想怎么做怎么写，我去真正地写了，我去找哪里写得有问题，最后我把正确的东西做出来，或者没有做出来 :( 但是不管怎么说，这就是一个学习的过程，提升编程能力，阅读代码能力的过程。&lt;/p>
&lt;ul>
&lt;li>从最基础的东西开始做，一点一点增加功能和深度。&lt;/li>
&lt;li>做一个成品，一个有完整功能的成品。不能 work 的半成品没有意义&lt;/li>
&lt;li>早点开始做，不要想太多。对于模拟器也是一样的，源码看的差不多就可以上手自己改了，不要等到把模拟器每个位置都看懂。&lt;/li>
&lt;/ul></description></item><item><title>Hugo 文章写作格式</title><link>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E6%A0%BC%E5%BC%8F/</link><pubDate>Fri, 08 Oct 2021 12:13:07 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E6%96%87%E7%AB%A0%E5%86%99%E4%BD%9C%E6%A0%BC%E5%BC%8F/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>记录一下文章写作和 扉页标签的内容，文章完全转载自 &lt;a href="https://shuzang.github.io/2019/hugo-blog-article-write/#3-%E6%8E%92%E7%89%88%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83">博客&lt;/a>&lt;/p>
&lt;hr>
&lt;p>本文是 Hugo 使用记录的第二篇，介绍关于文章写作的一些问题，包括分类管理、排版技巧、特殊语法等，所有语法基于 LoveIt 主题。&lt;/p>
&lt;p>Hugo支持的文章格式为&lt;code>.md&lt;/code>，即用markdown语言编辑的文章。所有的文章都放在&lt;code>content/posts&lt;/code>目录下，支持级联目录，即在&lt;code>posts&lt;/code>目录下按分类建立多个子文件夹放置文章，比如本博客的文章按分类放在四个子文件夹下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ ls posts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>爱编程爱技术的孩子/ 我所热爱的生活啊/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>平日里的白日梦/ 研究生的区块链学习之路/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下面是三条方便清晰管理和生成文章的目录结构建议:&lt;/p>
&lt;ul>
&lt;li>保持博客文章存放在 &lt;code>content/posts&lt;/code> 目录, 例如: &lt;code>content/posts/我的第一篇文章.md&lt;/code>&lt;/li>
&lt;li>保持简单的静态页面存放在 &lt;code>content&lt;/code> 目录, 例如: &lt;code>content/about.md&lt;/code>&lt;/li>
&lt;li>保持图片之类的媒体资源存放在 &lt;code>static&lt;/code> 目录, 例如: &lt;code>static/images/screenshot.png&lt;/code>&lt;/li>
&lt;/ul>
&lt;h2 id="1-前置参数">1. 前置参数&lt;/h2>
&lt;p>Hugo 允许在文章内容前面添加 &lt;code>yaml&lt;/code>, &lt;code>toml&lt;/code> 或者 &lt;code>json&lt;/code> 格式的前置参数，LoveIt 默认文章模板提供的前置参数有&lt;/p>
&lt;blockquote>
&lt;p>不过自己现在用的模板似乎不支持这么多参数&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;我的第一篇文章&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">subtitle&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">date&lt;/span>: &lt;span style="color:#e6db74">2020-03-04T15:58:26&lt;/span>&lt;span style="color:#ae81ff">+08&lt;/span>:&lt;span style="color:#ae81ff">00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">lastmod&lt;/span>: &lt;span style="color:#e6db74">2020-03-04T15:58:26&lt;/span>&lt;span style="color:#ae81ff">+08&lt;/span>:&lt;span style="color:#ae81ff">00&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">draft&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">author&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">authorLink&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">description&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">license&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">hiddenFromHomePage&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">featured_image&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">featured_image_preview&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">toc&lt;/span>: &lt;span style="color:#66d9ef">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">autoCollapseToc&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">math&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">mapbox&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">accessToken&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">lightStyle&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">darkStyle&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">navigation&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">geolocate&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">scale&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">fullscreen&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">lightgallery&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">linkToMarkdown&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">share&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">enable&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">comment&lt;/span>: &lt;span style="color:#66d9ef">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>---
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;strong>title&lt;/strong>: 文章标题.&lt;/li>
&lt;li>&lt;strong>subtitle&lt;/strong>: 文章副标题.&lt;/li>
&lt;li>&lt;strong>date&lt;/strong>: 这篇文章创建的日期时间. 它通常是从文章的前置参数中的 &lt;code>date&lt;/code> 字段获取的, 但是也可以在 &lt;a href="../theme-documentation-basics/#site-configuration">网站配置&lt;/a> 中设置.&lt;/li>
&lt;li>&lt;strong>lastmod&lt;/strong>: 上次修改内容的日期时间.&lt;/li>
&lt;li>&lt;strong>draft&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 除非 &lt;code>hugo&lt;/code> 命令使用了 &lt;code>--buildDrafts&lt;/code>/&lt;code>-D&lt;/code> 参数, 这篇文章不会被渲染.&lt;/li>
&lt;li>&lt;strong>author&lt;/strong>: 文章作者.&lt;/li>
&lt;li>&lt;strong>authorLink&lt;/strong>: 文章作者的链接.&lt;/li>
&lt;li>&lt;strong>description&lt;/strong>: 文章内容的描述.&lt;/li>
&lt;li>&lt;strong>license&lt;/strong>: 这篇文章特殊的许可.&lt;/li>
&lt;li>&lt;strong>tags&lt;/strong>: 文章的标签.&lt;/li>
&lt;li>&lt;strong>categories&lt;/strong>: 文章所属的类别.&lt;/li>
&lt;li>&lt;strong>hiddenFromHomePage&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 这篇文章将不会显示在主页上, 但是此行为可以在 &lt;a href="../theme-documentation-basics/#site-configuration">网站配置&lt;/a> 中设置的.&lt;/li>
&lt;li>&lt;strong>featuredImage&lt;/strong>: 文章的特色图片.&lt;/li>
&lt;li>&lt;strong>featuredImagePreview&lt;/strong>: 用在主页预览的文章特色图片.&lt;/li>
&lt;li>&lt;strong>toc&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 这篇文章会显示右侧目录.&lt;/li>
&lt;li>&lt;strong>autoCollapseToc&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 文章目录会自动折叠.&lt;/li>
&lt;li>&lt;strong>math&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 将自动渲染文章中的数学公式.&lt;/li>
&lt;li>&lt;strong>mapbox&lt;/strong>: 和 &lt;a href="../theme-documentation-basics/#site-configuration">网站配置&lt;/a> 中的 &lt;code>params.mapbox&lt;/code> 对象相同.&lt;/li>
&lt;li>&lt;strong>lightgallery&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 文章中的图片将可以按照画廊形式呈现.&lt;/li>
&lt;li>&lt;strong>linkToMarkdown&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 内容的页脚将显示指向原始 Markdown 文件的链接.&lt;/li>
&lt;li>&lt;strong>share&lt;/strong>: 和 &lt;a href="../theme-documentation-basics/#site-configuration">网站配置&lt;/a> 中的 &lt;code>params.share&lt;/code> 对象相同.&lt;/li>
&lt;li>&lt;strong>comment&lt;/strong>: 如果设为 &lt;code>true&lt;/code>, 将启用评论系统.&lt;/li>
&lt;/ul>
&lt;h2 id="2-标签与分类">2. 标签与分类&lt;/h2>
&lt;p>标签和分类字段是归档文章最常用的两种形式。为了更好的使用，我们需要弄清楚它们的区别。以生活与健身的韦恩图为例&lt;a href="#fn:1">1&lt;/a>，饮食与睡眠同时属于这两个分类，当出现这类型文章时，就可以添加标签来管理。&lt;/p>
&lt;p>&lt;img src="https://cdn.sspai.com/2019/11/17/07062af1ba37669fa8b7e91484e1d3da.jpg?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt="标签与分类">标签与分类&lt;/p>
&lt;p>博客文章的存储方式决定了它无法拥有太多的分类，因此，树形逐级检索的方法不适用这种情况，我们应当在将博客分为几个大类的同时，使用标签来管理和检索文章，当同样也要注意不应滥用标签，否则会带来视觉上的混乱和管理的不便。&lt;/p>
&lt;p>在每篇文章的元数据(Front-Matter字段)中添加&lt;code>categories&lt;/code>字段作为文章分类，添加&lt;code>tags&lt;/code>字段作为文章标签，比如本文：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">tags&lt;/span>: [&lt;span style="color:#ae81ff">博客写作]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">categories&lt;/span>: [&lt;span style="color:#ae81ff">爱编程爱技术的孩子]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>标签可以有多个，以逗号分隔，不过即使只有一个标签，外面的中括号也不能省略。&lt;/p>
&lt;h2 id="3-排版风格规范">3. 排版风格规范&lt;/h2>
&lt;p>本节内容参考少数派写作排版指南&lt;a href="#fn:2">2&lt;/a>&lt;/p>
&lt;h3 id="31-空格">3.1 空格&lt;/h3>
&lt;p>行文时在中文与英文、中文与数字、英文与数字之间增加空格。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推荐&lt;/strong>：苹果公司在 2015 年 9 月 9 日发布了 iPhone 6s。&lt;/li>
&lt;li>&lt;strong>不推荐&lt;/strong>：苹果公司在2015年9月9日发布了iPhone 6s。&lt;/li>
&lt;/ul>
&lt;p>一段文字中有超链接的部分，在超链接的前后使用空格。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推荐&lt;/strong>：你可以前往 &lt;a href="https://www.apple.com/cn">苹果官网&lt;/a> 了解详情。&lt;/li>
&lt;li>&lt;strong>不推荐&lt;/strong>：你可以前往&lt;a href="https://www.apple.com/cn">苹果官网&lt;/a>了解详情。&lt;/li>
&lt;/ul>
&lt;p>英文前后接全角标点符号或者表示单位的角标符号时，不需要加空格。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>正确&lt;/strong>：新款屏幕的可视角度为 125°，相比旧款提升了 25%。&lt;/li>
&lt;li>&lt;strong>错误&lt;/strong>：新款屏幕的可视角度为 125 °，相比旧款提升了 25 %。&lt;/li>
&lt;/ul>
&lt;p>对于有特殊用法的专有名词，如 4K、1080p、iOS 10 等，英文和数字之间是否空格以官方标准为准。&lt;/p>
&lt;p>每段文字的开头不需要空两格。&lt;/p>
&lt;h3 id="32-标点符号">3.2 标点符号&lt;/h3>
&lt;p>引号使用直角引号「」，而不是弯引号 “”。对于微软拼音输入法可以键入&lt;code>uubd&lt;/code>四个字母开启标点符号的选择。&lt;/p>
&lt;p>省略号使用 …… 的标准用法，正确输入方法是 shift + 6。不要使用三个句号。。。，也不要使用三个英文句点 …。&lt;/p>
&lt;p>不要重复使用标点符号，尤其是在表达强烈情感的时候。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>推荐&lt;/strong>：这个提议真棒！我喜欢。&lt;/li>
&lt;li>&lt;strong>不推荐&lt;/strong>：这个提议真棒！！！我喜欢~~~~&lt;/li>
&lt;/ul>
&lt;p>同时，抒发情感的方法有很多，不建议在文中大量使用感叹号等表达强烈情感的符号，也不建议使用波浪号。&lt;/p>
&lt;h3 id="33-中文和西文符号">3.3 中文和西文符号&lt;/h3>
&lt;p>一般情况下，一个中文句子中出现了英文部分，仍然使用中文标点，即全角符号。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>正确&lt;/strong>：我常用的电子设备是 Kindle、iPad Pro、iPhone。&lt;/li>
&lt;li>&lt;strong>错误&lt;/strong>：我常用的电子设备是 Kindle, iPad Pro, iPhone.&lt;/li>
&lt;/ul>
&lt;p>如果引用一段完整的英文句子，或是出现在专有名词中的标点，则不需要更改标点符号。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>正确&lt;/strong>：乔布斯说「Stay hungry, Stay foolish.」&lt;/li>
&lt;li>&lt;strong>错误&lt;/strong>：乔布斯说「Stay hungry，Stay foolish。」&lt;/li>
&lt;li>&lt;strong>正确&lt;/strong>：我最喜欢的手机游戏是 Lifeline: Silent Night。&lt;/li>
&lt;li>&lt;strong>错误&lt;/strong>：我最喜欢的手机游戏是 Lifeline：Silent Night。&lt;/li>
&lt;/ul>
&lt;h3 id="34-专有名词">3.4 专有名词&lt;/h3>
&lt;p>所有品牌名称以官方网站写法为准，应用名称遵循 Google Play 或 App Store 的命名。若无官方中文名称，可使用网络上被大家熟知的通用译名，否则请直接使用外文名称，不要自行翻译。&lt;/p>
&lt;p>请正确书写常用英文名词的大小写和空格。例如：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>正确&lt;/strong>：iOS 10、macOS、App Store、Android&lt;/li>
&lt;li>&lt;strong>错误&lt;/strong>：iOS10、MacOS、AppStore、android&lt;/li>
&lt;/ul>
&lt;p>若应用名称过长可在文中自定缩写，但需用括号注明缩写名称，并声明「下同」。&lt;/p>
&lt;p>一般情况下，品牌和应用名称不需要使用直角引号「」括起来。&lt;/p>
&lt;p>在称呼 app 时，请使用「应用」「应用程序」或「app」，而非「软件」「程序」。&lt;/p>
&lt;h3 id="35-样式工具">3.5 样式工具&lt;/h3>
&lt;p>虽然可以使用加粗、斜体、删除线、引用等样式工具，这些工具的使用也可以增加文章的可读性，但是过度使用则会造成排版混乱，因此建议正确、克制地使用样式工具。&lt;/p>
&lt;p>例如，需要着重显示的部分请使用「加粗」功能，不要使用「斜体」，更不要使用「加粗 + 斜体」的组合。&lt;/p>
&lt;h3 id="36-注明引用来源">3.6 注明引用来源&lt;/h3>
&lt;p>文中有使用外站或外部内容的，务必在引用最后部分注明来源。&lt;/p>
&lt;p>文中有使用外站图片，必须在文末标明。来源如果来自外站必须添加链接。例如，&lt;/p>
&lt;ul>
&lt;li>本文部分图片来自 &lt;a href="http://www.theverge.com/">The Verge&lt;/a>&lt;/li>
&lt;li>题图来自电影《春娇与志明》截图&lt;/li>
&lt;/ul>
&lt;p>若文章为全文翻译，必须在文中注明原作者及原文地址，并添加原文链接。&lt;/p>
&lt;h3 id="37-写作建议">3.7 写作建议&lt;/h3>
&lt;p>理清文章结构，动笔之前可以先列一下写作大纲。&lt;/p>
&lt;p>用主动语态，不要用被动语态。一般情况下，主动语态比被动语态更有力。&lt;/p>
&lt;p>使用具体、明确、展示细节的词汇，能激发想象，使读者自己代入情境。「把硬币放进口袋里，他咧开嘴笑了」，远远强过「他满意地拿走了辛苦挣来的奖赏」。&lt;/p>
&lt;p>减少形容词的使用，少用 「的」。&lt;/p>
&lt;p>文中涉及到参数规格、数据的部分，要保证严谨性。&lt;/p>
&lt;p>文章完成之后通读一遍，记住，不要让读者猜测你在讲什么。&lt;/p>
&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://shuzang.github.io/2019/hugo-blog-article-write/#3-%E6%8E%92%E7%89%88%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83">https://shuzang.github.io/2019/hugo-blog-article-write/#3-%E6%8E%92%E7%89%88%E9%A3%8E%E6%A0%BC%E8%A7%84%E8%8C%83&lt;/a>&lt;/p></description></item><item><title>Hugo 归档页面制作</title><link>https://huweim.github.io/post/blog_hugo_%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C/</link><pubDate>Fri, 08 Oct 2021 12:09:11 +0800</pubDate><guid>https://huweim.github.io/post/blog_hugo_%E5%BD%92%E6%A1%A3%E9%A1%B5%E9%9D%A2%E5%88%B6%E4%BD%9C/</guid><description>&lt;h1 id="0-前言">0. 前言&lt;/h1>
&lt;p>最近在学习使用 hugo 制作自己的博客，把制作过程的记录下来。我想博客应该会是之后的学习工作中会频繁使用和交互的东西。&lt;/p>
&lt;p>本文记录添加 archives 页面的过程。目前使用的 Hugo 主题 Ink 需要自己添加归档页面&lt;/p>
&lt;h1 id="1-新建归档页面模板">1. 新建归档页面模板&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>进入自己的 Hugo 主题文件夹，我自己的是 &lt;code>themes/hugo-ink&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在主题文件夹的 &lt;code>layouts/_default&lt;/code> 文件夹下新建文件 &lt;code>archives.html&lt;/code>，内容直接复制 &lt;code>single.html&lt;/code>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将 &lt;code>archives.html&lt;/code> 文件中的 &lt;code>{{ .Content }}&lt;/code> 替换为以下内容&lt;/p>
&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>{{ range (.Site.RegularPages.GroupByDate &amp;#34;2006&amp;#34;) }}
&amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;
&amp;lt;ul class=&amp;#34;archive-list&amp;#34;&amp;gt;
{{ range (where .Pages &amp;#34;Type&amp;#34; &amp;#34;posts&amp;#34;) }}
&amp;lt;li&amp;gt;
{{ .PublishDate.Format &amp;#34;2006-01-02&amp;#34; }}
-&amp;gt;
&amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;
&amp;lt;/li&amp;gt;
{{ end }}
&amp;lt;/ul&amp;gt;
{{ end }}
&lt;/code>&lt;/pre>&lt;h5 id="解释">解释&lt;/h5>
&lt;ul>
&lt;li>&lt;code>{{ range (where .Pages &amp;quot;Type&amp;quot; &amp;quot;posts&amp;quot;) }}&lt;/code>
&lt;ul>
&lt;li>归档目录设置为 &lt;code>content/posts&lt;/code>&lt;/li>
&lt;li>注意我的文章文件夹是 &lt;code>posts&lt;/code>，如果你的是 &lt;code>post&lt;/code>，请对应修改，否则无法正确解析&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code> {{ .PublishDate.Format &amp;quot;2006-01-02&amp;quot; }}&lt;/code>
&lt;ul>
&lt;li>可以选择归档的方式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="2-新建-archives-文档">2. 新建 archives 文档&lt;/h1>
&lt;p>假设文章都存在目录 &lt;code>content/posts&lt;/code> 下，打开 Git 命令行，输入&lt;/p>
&lt;pre tabindex="0">&lt;code>hugo new posts/archives.md
&lt;/code>&lt;/pre>&lt;p>将其顶部配置内容进行如下修改&lt;/p>
&lt;pre tabindex="0">&lt;code>---
title: &amp;#34;Archives&amp;#34;
layout: archives
hidden: true
type: posts
summary: 历史文章按照年月归档.
url: /archives/
---
&lt;/code>&lt;/pre>&lt;h1 id="3-主题jane">3. 主题Jane&lt;/h1>
&lt;p>不同主题的配置上会有细微的差距，比如配置主题 &lt;a href="https://github.com/xianmin/hugo-theme-jane">Jane&lt;/a>，文章目录的名称是 post 而非 posts，没有弄对就无法显示。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>{{ &lt;span style="color:#ae81ff">range (.Site.RegularPages.GroupByDate &amp;#34;2006&amp;#34;) }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;h3&amp;gt;{{ .Key }}&amp;lt;/h3&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;ul class=&amp;#34;archive-list&amp;#34;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ &lt;span style="color:#ae81ff">range (where .Pages &amp;#34;Type&amp;#34; &amp;#34;post&amp;#34;) }}&lt;/span> &lt;span style="color:#75715e">#注意是post&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;li&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ &lt;span style="color:#ae81ff">.PublishDate.Format &amp;#34;2006-01-02&amp;#34; }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&amp;gt;&lt;span style="color:#e6db74">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;a href=&amp;#34;{{ .RelPermalink }}&amp;#34;&amp;gt;{{ .Title }}&amp;lt;/a&amp;gt;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;lt;/li&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {{ &lt;span style="color:#ae81ff">end }}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">&amp;lt;/ul&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{{ &lt;span style="color:#ae81ff">end }}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="reference">Reference&lt;/h1>
&lt;p>&lt;a href="https://xbc.me/how-to-create-an-archives-page-with-hugo/">https://xbc.me/how-to-create-an-archives-page-with-hugo/&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://maitianblog.com/hugo-archives.html">http://maitianblog.com/hugo-archives.html&lt;/a>&lt;/p></description></item><item><title>GPGPU-Sim源码阅读</title><link>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</link><pubDate>Tue, 28 Sep 2021 15:51:46 +0800</pubDate><guid>https://huweim.github.io/post/%E5%AE%9E%E9%AA%8C_gpgpu-sim%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</guid><description>&lt;h1 id="shadercc">Shader.cc&lt;/h1>
&lt;p>shader_core_stats 类型含有非常多的数据统计，包括 cycle 数，m_num_decoded_insn, m_num_FPdecoded_insn, m_num_loadqueued_insn, m_num_INTdecoded_insn 等等&lt;/p>
&lt;p>m_stats 也就是 shader_core_stats 类型的变量&lt;/p>
&lt;p>num_shaer 就是 n_simt_clusters*n_simt_cores_per_cluster，也就是 SIMT Core 的数量&lt;/p>
&lt;p>tw_get_oracle_CPL_counter 计算 warp 的 CPL counter 值&lt;/p>
&lt;h3 id="shader_core_ctxdecode-函数">shader_core_ctx::decode 函数&lt;/h3>
&lt;p>检查 fetch buffer 中的指令是否有效，如有效则进入循环。获得当前指令的 pc，并取指令。&lt;/p>
&lt;p>指令用变量 pI1 存储，调用函数 ibuffer_fill, 将 pI 装进对应 warp id 的 I-Buffer, 并将 valid bit 置为1&lt;/p>
&lt;p>随后会取下一条指令，用变量 pI2 存储，注意下一条指令的 &lt;code>pc = pc + pI1 -&amp;gt; isize&lt;/code>。也就是我们常说的 pc = pc + 1, 这里的1实际上是一条指令的长度&lt;/p>
&lt;p>每个 warp 有两个 ibuffer slot, 也就是 ibuffer_fill 中的0和1&lt;/p>
&lt;h5 id="ifetch_buffer_taddress_type-pc-unsigned-nbytes-unsigned-warp_id">ifetch_buffer_t(address_type pc, unsigned nbytes, unsigned warp_id)&lt;/h5>
&lt;p>是一个结构体，包含 m_valid, m_pc, m_nbytes, m_warp_id&lt;/p>
&lt;p>构造时 valid 直接置为1&lt;/p>
&lt;p>其变量作为 fetch 和 decode stage 之间的 pipeline register&lt;/p>
&lt;p>理解为用于使得 fetch and decode 可以流水线执行的一个结构体&lt;/p>
&lt;h3 id="shader_core_ctxfetch-函数">shader_core_ctx::fetch 函数&lt;/h3>
&lt;p>访问内存 (L1 Cache or memory)，获取指令的 pc, size, warp_id&lt;/p>
&lt;p>如果 L1 Cache 的 access ready, 也就是已经可以内存访问（之前 Miss 的时候需要的 data 已经从内存中取到了）&lt;/p>
&lt;p>如果没有 access ready, 就去找一个 active, 并且在 I-Buffer 中还有空间, 没有在等待 cache miss 的 warp，取其 next instruction from i-cache&lt;/p>
&lt;blockquote>
&lt;p>第3层中的第1个 if 语句检查 warp 是否已经完成执行，第3层中的第2个 if 语句检查当前 warp 对应的 entry 是否已经存储了有效的指令&lt;/p>
&lt;/blockquote>
&lt;h3 id="issue_warp-函数">issue_warp 函数&lt;/h3>
&lt;p>free 掉相应的 I-Buffer&lt;/p>
&lt;h3 id="scheduler_unitcycle">scheduler_unit::cycle()&lt;/h3>
&lt;p>In function &lt;code>scheduler_unit::cycle()&lt;/code> , call &lt;code>order_warps()&lt;/code> to sort warps according to their priority.&lt;/p>
&lt;p>排序后的 warp 放在 vector &lt;code>m_next_cycle_prioritized_warps&lt;/code> 中，对其进行遍历来处理这个 vector 中的 warp。&lt;/p>
&lt;p>❗ 值得注意的是在 order_warp() 后，for 循环会遍历 vector &lt;code>m_next_cycle_prioritized_warps&lt;/code> 中的所有 warp。而不是发射一个 warp 就重新排序一次。&lt;/p>
&lt;blockquote>
&lt;p>这一点和自己的理解与猜想不太一样&lt;/p>
&lt;/blockquote>
&lt;hr>
&lt;p>进入 for 循环，拿到 warp id，判断&lt;/p>
&lt;ul>
&lt;li>I-Buffer 是否为空；是否处于 waiting 状态。如果都通过，进入一个 while 循环
&lt;ul>
&lt;li>如果指令是有效的 &lt;code>if(pI)&lt;/code>
&lt;ul>
&lt;li>如果出现分支 &lt;code>if(pc != pI-&amp;gt;pc)&lt;/code>，刷掉 I-Buffer&lt;/li>
&lt;li>如果没有分支，此时 &lt;code>valid=true&lt;/code>，指令是有效的。如果通过 scoreboard 检测，终于可以执行了。先读取 active mask 确定要执行哪些线程，然后判断 &lt;code>pI-&amp;gt;op&lt;/code> 是 内存操作 还是 运算操作。如果相应的寄存器可以使用 &lt;code>has_free()&lt;/code>，则 call &lt;code>issue_warp()&lt;/code> 将寄存器、指令、active mask、warp id、scheduler id 发送并执行。&lt;/li>
&lt;li>&lt;code>warp_inst_issued = true; issued++; issued_inst = true&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>else if 下一条指令是有效的
&lt;ul>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果指令成功发射 &lt;code>if (warp_inst_issued)&lt;/code>，执行了 issue_warp() 后会进入这个 if 语句，做一些 warp 发射后的统计信息等等
&lt;ul>
&lt;li>call &lt;code>do_on_warp_issued(warp_id, issued, iter);&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>checked++&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从 while 循环出来，如果至少有一个 warp 被发射 &lt;code>if(issued)&lt;/code>，遍历 &lt;code>m_supervised_warps&lt;/code>，找到那个被发射的 warp，然后将其赋值给 &lt;code>m_last_supervised_issued&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h5 id="scheduler_size">scheduler_size()&lt;/h5>
&lt;p>scheduler.size 就是2，代表一个 core 中 warp scheduler 的数量&lt;/p>
&lt;h2 id="关于类">关于类&lt;/h2>
&lt;p>阅读一个类，应该先观察他还包含哪些子类，继承自哪个类，从全局上把握他的作用&lt;/p>
&lt;p>class opndcoll_rfu_t&lt;/p>
&lt;ul>
&lt;li>class op_t&lt;/li>
&lt;li>class allocation_t&lt;/li>
&lt;li>class arbiter_t&lt;/li>
&lt;li>class input_port_t&lt;/li>
&lt;li>class collector_unit_t&lt;/li>
&lt;li>dispatch_unit_t&lt;/li>
&lt;/ul>
&lt;h2 id="地址信息">地址信息&lt;/h2>
&lt;p>src/abstract_hardware_model.h&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">per_thread_info&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> per_thread_info() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> MAX_ACCESSES_PER_INSN_PER_THREAD; i&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memreqaddr[i] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dram_callback_t callback;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_addr_type
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memreqaddr[MAX_ACCESSES_PER_INSN_PER_THREAD]; &lt;span style="color:#75715e">// effective address,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// upto 8 different
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// requests (to support
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 32B access in 8 chunks
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// of 4B each)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>per_thread_info&lt;span style="color:#f92672">&amp;gt;&lt;/span> m_per_scalar_thread;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们关注每个 kernel_launch_uid 中的访存信息和打印出来的访存次数是否匹配&lt;/p>
&lt;ul>
&lt;li>✔️ 匹配。前两个 kernel (都是 create matrix) &lt;code>gpgpu_n_param_mem_insn + gpgpu_n_store_insn = number of memaddr&lt;/code>&lt;/li>
&lt;li>不过要注意 Memory Access Statistics 的信息应该是总和而非单一 kernel&lt;/li>
&lt;/ul>
&lt;h1 id="tracing">Tracing&lt;/h1>
&lt;h2 id="4个-cycle-函数调用关系">4个 Cycle() 函数调用关系&lt;/h2>
&lt;p>4个 cycle() 函数&lt;/p>
&lt;p>shader_core_ctx::cycle() 在 issue 中调用 scheduler_unit::cycle(), 这两个应该是负责 SIMT Front 部分，从指令 fetch, decode, 到准备好后的调度发射 (sheduling and issue).&lt;/p>
&lt;p>ldst_unit::cycle() 负责各个 memory 的时钟建模，包括 shared memory, L1 latebcy queue, constant menory, texture memory&lt;/p>
&lt;h5 id="shader_core_ctxcycle">shader_core_ctx::cycle()&lt;/h5>
&lt;ul>
&lt;li>SIMT Core Cluster clock domain = frequency of the pipeline stages in a core clock (i.e. the rate at which &lt;code>simt_core_cluster::core_cycle()&lt;/code> is called)
&lt;ul>
&lt;li>&lt;code>simt_core_cluster::core_cycle()&lt;/code> will call &lt;code>shader_core_ctx::cycle()&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>⭐ &lt;code>m_thread[tid]-&amp;gt;ptx_exec_inst(inst, t);&lt;/code> 用于执行 ptx 指令的执行&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>shader_core_ctx&lt;span style="color:#f92672">::&lt;/span>cycle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> writeback();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> execute();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_fu[n]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>cycle(); &lt;span style="color:#75715e">//m_fu[] contains ldst_unit, sfu_unit, sp_unit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> ldst_unit&lt;span style="color:#f92672">::&lt;/span>cycle();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> writeback();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_operand_collector&lt;span style="color:#f92672">-&amp;gt;&lt;/span>step();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> issue(register_set &lt;span style="color:#f92672">&amp;amp;&lt;/span>source_reg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> read_operands();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> issue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> scheduler_unit&lt;span style="color:#f92672">::&lt;/span>cycle();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> order_warps();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_shader&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_pdom_stack_top_info(warp_id, pI, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pc, &lt;span style="color:#f92672">&amp;amp;&lt;/span>rpc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_shader&lt;span style="color:#f92672">-&amp;gt;&lt;/span>issue_warp();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> (&lt;span style="color:#f92672">*&lt;/span>pipe_reg)&lt;span style="color:#f92672">-&amp;gt;&lt;/span>warp_inst_t&lt;span style="color:#f92672">::&lt;/span>issue();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> func_exec_inst(&lt;span style="color:#f92672">**&lt;/span>pipe_reg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> execute_warp_inst_t(inst);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_thread[tid]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>ptx_exec_inst(inst, t);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> insn_memaddr &lt;span style="color:#f92672">=&lt;/span> last_eaddr();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> inst.set_addr(lane_id, insn_memaddr); &lt;span style="color:#75715e">//util this, we have //the address in the class warp_inst_t
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> updateSIMTStack(warp_id, &lt;span style="color:#f92672">*&lt;/span>pipe_reg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> reserveRegisters(&lt;span style="color:#f92672">*&lt;/span>pipe_reg);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> set_next_pc(next_inst&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pc &lt;span style="color:#f92672">+&lt;/span> next_inst&lt;span style="color:#f92672">-&amp;gt;&lt;/span>isize);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> decode();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> ibuffer_fill(&lt;span style="color:#ae81ff">0&lt;/span>, pI1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> inc_inst_in_pipeline();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> fetch();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="scheduler_unitcycle-1">scheduler_unit::cycle()&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> order_warps();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//if warp is valid and not waiting
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|--&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> warp_inst_t &lt;span style="color:#f92672">*&lt;/span>pI &lt;span style="color:#f92672">=&lt;/span> warp(warp_id).ibuffer_next_inst();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> m_shader&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_pdom_stack_top_info(warp_id, pI, &lt;span style="color:#f92672">&amp;amp;&lt;/span>pc, &lt;span style="color:#f92672">&amp;amp;&lt;/span>rpc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//deal with the control hazard
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//pc is the PC in the top of SIMT stack, pI-&amp;gt;pc is the PC in the I-Buffer
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//not equal means jump or ohter control hazard
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span>(pI){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (pc &lt;span style="color:#f92672">!=&lt;/span> pI&lt;span style="color:#f92672">-&amp;gt;&lt;/span>pc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> warp(warp_id).set_next_pc(pc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> warp(warp_id).ibuffer_flush(); &lt;span style="color:#75715e">//need to flush
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">else&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(&lt;span style="color:#f92672">!&lt;/span>m_scoreboard&lt;span style="color:#f92672">-&amp;gt;&lt;/span>checkCollision(warp_id, pI)){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_shader&lt;span style="color:#f92672">-&amp;gt;&lt;/span>get_active_mask(warp_id, pI);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// need to check which pipieline to send, MEM, SP, SFU...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// the only different is the first parameter, register_set *m_XX_out
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> m_shader&lt;span style="color:#f92672">-&amp;gt;&lt;/span>shader_core_ctx&lt;span style="color:#f92672">::&lt;/span>issue_warp(&lt;span style="color:#f92672">*&lt;/span>m_mem_out, pI, active_mask, warp_id, m_id);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span>(valid){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// this case can happen after a return instruction in diverged warp
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> warp(warp_id).set_next_pc(pc);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> warp(warp_id).ibuffer_flush(); &lt;span style="color:#75715e">//need to flush
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="color:#75715e">//while
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>执行这个 issue_warp 的时候需要的源操作数的寄存器已经拿到了 (判断 has_free()才会进入这个条件语句)&lt;/p>
&lt;h5 id="ldst_unitcycle">ldst_unit::cycle()&lt;/h5>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>ldst_unit&lt;span style="color:#f92672">::&lt;/span>cycle()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> writeback();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> Scoreboard&lt;span style="color:#f92672">::&lt;/span>releaseRegister();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> warp_inst_complete(m_next_wb);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">|--&lt;/span> m_operand_collector&lt;span style="color:#f92672">-&amp;gt;&lt;/span>step();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> dispatch_ready_cu(); &lt;span style="color:#75715e">//把 ready_cu 发射到执行单元
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> cu&lt;span style="color:#f92672">-&amp;gt;&lt;/span>dispatch();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> allocate_reads(); &lt;span style="color:#75715e">// process read requests that do not have conflicts. Map bank
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// and collector unit, 连接了 bank 和 cu, 准确到 cu 的哪个操作数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span>()&lt;span style="color:#f92672">|--&lt;/span> allocate_cu(p);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> allocated &lt;span style="color:#f92672">=&lt;/span> cu&lt;span style="color:#f92672">-&amp;gt;&lt;/span>allocate(inp.m_in[i], inp.m_out[i]);&lt;span style="color:#75715e">//终于找到了
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> m_arbiter.add_read_requests(cu); &lt;span style="color:#75715e">//把 cu 对特定 bank 的读请求入队
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//m_queue[bank].push_back(op);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> process_banks(); &lt;span style="color:#75715e">//reset allocation, free cu
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|--&lt;/span> move_warp(warp_inst_t &lt;span style="color:#f92672">*&amp;amp;&lt;/span>dst, warp_inst_t &lt;span style="color:#f92672">*&amp;amp;&lt;/span>src); &lt;span style="color:#75715e">// move src to dst
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|--&lt;/span> m_L1T&lt;span style="color:#f92672">/&lt;/span>m_L1C&lt;span style="color:#f92672">/&lt;/span>m_L1D&lt;span style="color:#f92672">-&amp;gt;&lt;/span>fill(); &lt;span style="color:#75715e">//deal with fill request
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">|--&lt;/span> m_L1T&lt;span style="color:#f92672">/&lt;/span>m_L1C&lt;span style="color:#f92672">/&lt;/span>m_L1D&lt;span style="color:#f92672">-&amp;gt;&lt;/span>cycle(); &lt;span style="color:#75715e">//send next request to lower level of memory
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上述的 &lt;code>allocated = cu-&amp;gt;allocate(inp.m_in[i], inp.m_out[i])&lt;/code> 函数中&lt;del>为寄存器赋值&lt;/del> 确定读哪个bank的哪个寄存器&lt;/p>
&lt;p>m_src_op 中装的就是32个 源操作数寄存器，去哪个位置找 寄存器 的详细信息&lt;/p>
&lt;p>dispatch() 后会 reset m_src_op,&lt;/p>
&lt;h5 id="pipelined_simd_unitcycle">pipelined_simd_unit::cycle()&lt;/h5>
&lt;p>用于模拟流水线，移动寄存器的 value..&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>m_pipeline_reg[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">-&amp;gt;&lt;/span>empty()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> m_result_port&lt;span style="color:#f92672">-&amp;gt;&lt;/span>move_in(m_pipeline_reg[&lt;span style="color:#ae81ff">0&lt;/span>]); &lt;span style="color:#75715e">//move src to m_pipeline_reg[0]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> warp_inst_t &lt;span style="color:#f92672">**&lt;/span>free &lt;span style="color:#f92672">=&lt;/span> get_free(); &lt;span style="color:#75715e">//return a free register to variable **free
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">|--&lt;/span> move_warp(&lt;span style="color:#f92672">*&lt;/span>free, src); &lt;span style="color:#75715e">//move src to *free
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> active_insts_in_pipeline&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (active_insts_in_pipeline) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">unsigned&lt;/span> stage &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; (stage &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&lt;/span> m_pipeline_depth; stage&lt;span style="color:#f92672">++&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">|--&lt;/span> move_warp(m_pipeline_reg[stage], m_pipeline_reg[stage &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="文档中-cycle-的介绍">文档中 Cycle() 的介绍&lt;/h2>
&lt;h5 id="simt_core_clustercore_cycle">simt_core_cluster::core_cycle()&lt;/h5>
&lt;p>&lt;code>simt_core_cluster::core_cycle()&lt;/code> 方法只是按顺序 循环调用 (cycles) 每个 SIMT core.&lt;/p>
&lt;p>&lt;code>simt_core_cluster::icnt_cycle()&lt;/code> 方法将内存请求从 interconnection network push 到 SIMT Core Cluster&amp;rsquo;s response FIFO. 它也将 FIFO 中的请求出队，送到合适的 core&amp;rsquo;s instruction cache or LDST unit. 这些与前面描述的硬件块密切对应。&lt;/p>
&lt;h5 id="shader_core_ctxcycle-1">shader_core_ctx::cycle()&lt;/h5>
&lt;ul>
&lt;li>每个 core cycle, 调用 &lt;code>shader_core_ctx::cycle()&lt;/code> 来模拟 SIMT Core 的一个 cycle。&lt;/li>
&lt;li>operand collector 被建模为主流水线中的一个 stage, 通过函数 &lt;code>shader_core_ctx::cycle()&lt;/code> 执行&lt;/li>
&lt;/ul>
&lt;h5 id="scheduler_unitcycle-2">scheduler_unit::cycle()&lt;/h5>
&lt;ul>
&lt;li>在 &lt;code>scheduler_unit::cycle()&lt;/code> 中，函数 &lt;code>shader_core_ctx::issue_warp()&lt;/code> 将指令发送到执行单元&lt;/li>
&lt;li>调用 &lt;code>func_exec_inst()&lt;/code> 执行指令&lt;/li>
&lt;li>调用 &lt;code>simt_stack::update()&lt;/code> 更新 SIMT Stack&lt;/li>
&lt;/ul>
&lt;h5 id="ldst_unitcycle-1">ldst_unit::cycle()&lt;/h5>
&lt;ul>
&lt;li>·ldst_unit::cycle()· 处理来自 interconnect 的内存响应（存储在 m_response_fifo 中），填充 cache (&lt;code>m_L1D-&amp;gt;fill()&lt;/code>) 并将存储标记为完成。&lt;/li>
&lt;li>该函数还 cycle caches，以便它们可以将 missed data 的请求发送到 interconnect&lt;/li>
&lt;li>对每种类型的 L1 内存的 cache accesses 分别在 &lt;code>shared cycle()&lt;/code>、&lt;code>constant cycle()&lt;/code>、&lt;code>texture cycle() &lt;/code>和 &lt;code>memory cycle()&lt;/code> 中完成 (在 &lt;code>ldst_unit::cycle()&lt;/code> 函数中调用)&lt;/li>
&lt;/ul>
&lt;h5 id="gpgpu_simcycle">gpgpu_sim::cycle()&lt;/h5>
&lt;ul>
&lt;li>&lt;code>gpgpu sim::cycle()&lt;/code> 方法为 gpgpu - sim 中的所有架构组件的时钟，包括 Memory Partition 的队列，DRAM channel 和 L2 cache bank.&lt;/li>
&lt;li>对 &lt;code>memory_partition_unit::dram_cycle()&lt;/code> 的调用将内存请求从 L2-&amp;gt;dram queue 移动到 dram channele，从 dram channel 移动到 dram-&amp;gt;L2 queue，并 cycles 片外 GDDR3 dram 内存。&lt;/li>
&lt;li>在这个函数中，调用
&lt;ul>
&lt;li>icnt_cycle()&lt;/li>
&lt;li>dram_cycle()&lt;/li>
&lt;li>cache_cycle()&lt;/li>
&lt;li>core_cycle()&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以可以看到，这个函数应该是调用了每个组件的 cycle(), 以此来建模整个 GPGPU-Sim cycle&lt;/p>
&lt;h5 id="memory_partition_unitcache_cycle">memory_partition_unit::cache_cycle()&lt;/h5>
&lt;ul>
&lt;li>在 &lt;code>memory_partition_unit::cache_cycle()&lt;/code> 中，调用 &lt;code>mem_fetch *mf = m_L2cache-&amp;gt;next_access();&lt;/code> 为在 filled MSHR entry 中等待的内存请求产生 replies.&lt;/li>
&lt;li>L2 产生的由于 read miss 的 fill 请求将从 L2&amp;rsquo;s miss queu 中弹出，并通过调用 &lt;code>m_L2cache-&amp;gt;cycle();&lt;/code> 将其push into L2-&amp;gt;dram queue&lt;/li>
&lt;/ul>
&lt;h5 id="dram_tcycle">dram_t::cycle()&lt;/h5>
&lt;ul>
&lt;li>The function &lt;code>dram_t::cycle()&lt;/code> represents a DRAM cycle&lt;/li>
&lt;li>每个周期，DRAM从请求队列中弹出一个请求，然后调用调度器函数，让调度器根据调度策略选择一个需要服务的请求。&lt;/li>
&lt;/ul></description></item></channel></rss>