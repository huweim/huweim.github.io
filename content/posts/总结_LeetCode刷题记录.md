---
title: "LeetCode刷题记录"
date: 2022-03-16T08:59:50+08:00
lastmod: 2022-03-16 09:01:09
draft: false
author: "Cory"
tags: ["LeetCode"]
categories: ["总结"]
---

#### 关键字检索

+ 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。
+ 知识点：题目所涉及到的大概知识点。
+ 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针
+ 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。

#### 总结

+ 短板：二叉树，矩阵，DFS，BFS

### 3.11

#### 查缺补漏

+ 二叉树建树
+ 二叉树后序遍历

### 3.11

##### JZ.03 

3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；

第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)

第三种原地Hash，鸽巢原理。源于一个条件 `element value < nums.size()`，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)

**知识点**

+ vector 可以用下标索引
+ 标签：hash，排序，数组

##### JZ.04 二维数组中的查找 :x:

感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)

并非 DP，没有秒这题；主要是思路上的解法而非常规算法

> 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
>
> 二分查找也是解法之一

**知识点**

+ 二维 vector 能否用下标索引？
  + 可以
+ 标签：数组，二分查找，分治，矩阵

##### JZ.05 替换空格 

简单的字符串替换，被 string 和 char，"" 和 '' 的一些知识卡了一会儿。

**知识点**

+ 字符串裁剪 `str.substr(pos, len)`，
+ :warning: 字符串比较；string 可以直接用 `==`，但是注意 s[0] 是 char 型；所以 `s[0] == " "` 会报错，应该是 `s[0] == ' '`；或者 `strcmp(s[0], ' ');`
+ 注意 "" 和 ''
+ :exclamation: 为什么不能用 strcmp？
  + 用 `strcmp(string , string)` 会就报错；使用 `strcmp(char [], char[])` 就可以了；有什么区别？
  + string 是一个 managed type，不用担心有多长；char[] 分配的长度固定


##### **JZ.06 反转链表** 

从尾到头打印链表，单链表

自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$

也可以使用 递归

:warning: 注意边界条件，基本每次 case 都会有

**知识点**

+ 单向链表；指针；vector
+ 标签：栈，链表，递归，双指针

### 3.13

##### JZ.07 重建二叉树 :x: 

二叉树和链表的数据结构要记住。

如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解

In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。

:x: 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。

pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size

**知识点**

+ 前序遍历列表：第一个元素永远是 【根节点 (root)】
+ 中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】
+ 做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end
+ 标签：数组，hash，分治，二叉树

##### JZ.09 用两个栈实现队列

自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。

更好的思路：其实不用再把 stack_2 中全部倒回 stack_1

**知识点**

+ 栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？`stack<int> stk; queue<int> q;`
+ 两个栈实现队列
+ 标签：栈，队列

##### JZ.10 斐波那契数列 DP

自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归

更好的思路：这题可以用 DP，没有想到。

现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；

转移方程：$dp[i+1] = dp[i] + dp[i-1]$

初始状态：$dp[0] = 0; dp[1] = 1$

返回值：$dp[n]$

**知识点**

+ 查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路
+ 标签：DP

##### JZ.11 青蛙跳台阶

自己的思路：hash 递归；DP

和上一题很类似，写的是优化空间后的 DP，

:heavy_check_mark: 要求自己写一个常规的 DP 加深理解

**知识点**

+ DP

##### JZ.11 旋转数组的最小数字 :x: 

> 这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的

确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。

**知识点**

+ 标签：二分查找，数组
+ 查缺补漏：二分查找熟练度不够

### 3.14

##### JZ.12 矩阵中的路径 :x:

自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$

题解 DFS，DFS 已经非常生疏了

看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。

**知识点**

+ 典型的矩阵搜索问题

##### JZ.13 机器人运动范围

这个也是算法设计课程中出现的考试题目。

自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。

写错了一句 `tag[i][j] == -1;`，报错居然是 `stackoverflow`，要注意尽量一次写出 bug-free code。 

题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵

**知识点**

+ 和上一题类似，也是矩阵，DFS还是可以用。
+ 标签：**DP**，BFS，DFS；DP 体现在哪？了解 DP 的解法

##### JZ.14-I 剪绳子 :x:

自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$

更好的思路：

**DP**

+ 求长度为 n 的绳子剪掉后的乘积，从 <n 的绳子转移而来
+ `dp数组` 记录 `0到n` 的绳子的最大乘积，初始化 `dp[2] = 1`
+ 剪掉第一段，长度为 j，j > 1
+ 剪了第一段，剩下长度为 `(i - j)` 可以剪或者不剪。不剪的话 `length = j * (i - j)`；剪了的话 `length = j * dp[i - j]`；`max(j * (i - j), j * dp[i - j])`
+ 遍历 j，$j \in [2, i)$，取最大值。

难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。

**2022-03-16 10:38:06**，尝试写一下 DP 解法 :heavy_check_mark:。DP 和自己的思路性能差不多。

**贪心**

+ 均值不等式思想；n > 4 时，尽可能把绳子分为长度为 3 的小段，进行乘加。

### 3.16

##### JZ.14-II 剪绳子 

在 I 的基础上加了一个答案取模，取模对于加法没有影响，~~但是会影响乘法的计算结果。~~并没有，那么这题在考察什么？

这个题目就是考察贪心的解法，如果继续用 DP，应该会超时

##### JZ.15 二进制中1的个数 

考察位运算。

自己的思路：比较基础的 $/2\%2$ 进行二进制化，时间复杂度 $O(logn)$，可以AC。bitset

更好的思路：$n\&(n-1)$，$n-1:$ 二进制数字 $n$ 最右边的 1 变成 0 ，此 1 右边的 0 都变成 1；$n\&(n - 1):$  二进制数字 $n$ 最右边的 1 变成 0 ，其余不变。时间复杂度 $O(M)$，M 为 1 的数量

<img src="D:\ShanghaiTech\2021-Fall\Note_Archive\Job\Img\JZ_15.png" align =left alt="JZ_15" style="zoom: 25%;" />

**知识点**

+ 标签：位运算

##### JZ.16 数值的整数次方 :x:

自己的思路：计算 $pow(x, n)$，naive 直接乘 $n$ 次，时间复杂度 $O(n)$，会超时，因此需要的不是 $O(n)$ 的解法。好像和复杂度没有关系，注意 $n$ 的范围，涉及越界的问题。

> ~~我认为这个应该就是考察 INT 型表示范围的细节，尤其是 $n = 0 - n$ 这种写法会越界~~。看来并非如此

处理了越界仍然会超时，用 $x$ 的范围去换 $n$ 的范围。这样并没有降低时间复杂度的数量级，304 case 全过但是仍然超时。因此猜测 $O(n)$​ 的解法 A 不了。加了一个判断 `if(x < 0.000005) return x * init_x;` 后 AC 了，因为输出只保留到小数点后 5 位，有点取巧，虽然 AC 但是可能没有满足这道题的考察意图。:warning: 这个取巧做法不能算真正的 AC。

**更好的解法**：确实有 $O(logn)$ 的解法，**快速幂**。快速幂也就是在循环中递归地使用你只用了一次的降幂操作，每次可以降幂的时候，$x *= x, n >>= 1$，这样将复杂度降至 $O(logn)$

**知识点**

+ $(-3) \% 2$，余数是 1 还是 -1？答案：余数是 -1
+ 标签：递归，数学

##### JZ.17 打印从1到最大的n位数

自己的思路：遍历，时间复杂度 $O(10^n)$，直接 A，意义在哪？评论区有人说原题目是要考虑大数越界问题的。因此，这道题的本意应该是考察字符串和整型数字的转换。

先放一下

> 若不考虑大数问题，则十分简单一个从1到最大数的循环即可。 若考虑大数问题，则首先需要将数字转成字符串避免溢出，然后全排列字符串的第0位到第n-1位。 存储结果时需去掉字符串前几位的0(0099没有意义，应为99)再放入结果。

**知识点**

+ 标签：数组（越界，大数），字符串

##### JZ.18 删除链表的节点

自己的思路：最简单的单链表删除，时间复杂度 $O(n)$，AC。

**知识点**

+ 标签：链表

##### JZ.20 表示数值的字符串

这个题是有实用性的，也许在某些爬虫提取数据的时候会用到。

自己的思路：就是用条件判断筛选出不合规的情况 `return false`，第一次以为空格直接删除就行，提交后发现空格不能出现在有效符号的中间。

提交 23 次 AC，基本就是看着 case 补条件，完全没有周全考虑，没有使用正则表达式思想。

**知识点**

+ 标签：字符串，有限状态机

##### JZ.21 调整数组顺序使奇数位于偶数前面

自己的思路：两次遍历，$O(n)$，AC，有没有复杂度更低的解法？

题解的思路：也是 $O(n)$ 复杂度，但只用遍历一次，双指针，类似快排的思路。分别从左右开始遍历，然后交换。稍快一点。

**知识点**

+ 标签：数组，双指针，排序

##### JZ.22 链表中倒数第k个节点

自己的思路：打印倒数的节点，所以遍历两次，第一次确定链表长度 L，L - k 次 next 就可以找到目标结果，然后返回，AC，时间复杂度 $O(n)$

更好的解法：双指针，无需统计链表的长度。前指针先走 $k$ 步，然后共同移动，前指针到终点时返回后指针即可，时间复杂度 $O(n)$

**知识点**

+ 标签：链表，双指针

##### JZ.24 反转链表

自己的思路：一次遍历，forward 指针在前，head 自己在后，一遍遍历一边调整，AC，时间复杂度 O(n)。

:x: 注意边界条件，注意条件判断时写了 `if(head->next == NULL || head == NULL)`，报错。因为当 head==NULL，是找不到 head->next，自己写代码不要忽略边界和细节。

题解：除双指针，还有递归的解法，时间空间都是 $O(n)$

**知识点**

+ 标签：递归，链表
+ 关于递归，心中要有明确的终止条件的概念。

##### JZ.25 合并两个递增排序的链表

自己的思路：非常基础的算法题，一次遍历，其中一个链表完成遍历后直接接过去。最初出现错误的原因：遍历的时候 `l2 = l2->next`，忘记保存头结点。

一开始的合并写法没有 AC，逻辑有点混乱了，后来直接换了一种写法，新建了一个链表，比较耗费空间，时间复杂度 $O(m+n)$，空间复杂度 $O(m+n)$。

**知识点**

+ 标签：递归，链表
+ 引入 **伪头结点** 合并链表是本题的最优解

#### 3.17

