---
title: "LeetCode刷题记录"
date: 2022-03-16T08:59:50+08:00
lastmod: 2022-03-16 09:01:09
draft: false
author: "Cory"
tags: ["总结"]
categories: ["LeetCode"]
---

#### 关键字检索

+ 查缺补漏：做题时比较生疏的知识点，后面复习的时候最好也check一下熟练程度。
+ 知识点：题目所涉及到的大概知识点。
+ 分类：根据题库现有的tag，可以大概分为 DP，贪心，数学技巧，滑动窗口，hash，二分算法，单调栈（队列），DFS/BFS，位运算，字符串，数组，二叉树，并查集，双指针
+ 第一遍顺序过剑指Offer，第二遍根据类型和短板刷。

#### 总结

+ 短板：二叉树，矩阵，DFS，BFS

### 3.11

#### 查缺补漏

+ 二叉树建树
+ 二叉树后序遍历

### 3.11

##### JZ.03 

3钟方法，Hash 遍历，时间空间均为O(n)，用的这一种秒了；

第二种排序后，check 相邻是否重复，时间 O(nlogn)，空间O(1)

第三种原地Hash，鸽巢原理。源于一个条件 `element value < nums.size()`，元素值归位时如果该索引处已经存在该元素，则为重复。t.O(n), s.O(1)

**知识点**

+ vector 可以用下标索引
+ 标签：hash，排序，数组

##### JZ.04 二维数组中的查找 :x:

感觉是 DP or 一些奇淫技巧；这个题感觉算法考试里面有考过:)

并非 DP，没有秒这题；主要是思路上的解法而非常规算法

> 从右上角开始比较，比它大就往下数一行，比它小就往左数一列
>
> 二分查找也是解法之一

**知识点**

+ 二维 vector 能否用下标索引？
  + 可以
+ 标签：数组，二分查找，分治，矩阵

##### JZ.05 替换空格 

简单的字符串替换，被 string 和 char，"" 和 '' 的一些知识卡了一会儿。

**知识点**

+ 字符串裁剪 `str.substr(pos, len)`，
+ :warning: 字符串比较；string 可以直接用 `==`，但是注意 s[0] 是 char 型；所以 `s[0] == " "` 会报错，应该是 `s[0] == ' '`；或者 `strcmp(s[0], ' ');`
+ 注意 "" 和 ''
+ :exclamation: 为什么不能用 strcmp？
  + 用 `strcmp(string , string)` 会就报错；使用 `strcmp(char [], char[])` 就可以了；有什么区别？
  + string 是一个 managed type，不用担心有多长；char[] 分配的长度固定


##### **JZ.06 反转链表** 

从尾到头打印链表，单链表

自己的思路：用一个数组存，反向打印这个数组。都是 $O(n)$

也可以使用 递归

:warning: 注意边界条件，基本每次 case 都会有

**知识点**

+ 单向链表；指针；vector
+ 标签：栈，链表，递归，双指针

### 3.13

##### JZ.07 重建二叉树 :x: 

二叉树和链表的数据结构要记住。

如何由前序和中序遍历确定一颗二叉树？确定根节点和左右子树，然后继续递归，确定左右子树的根节点和左右子树。可以用分治和递归求解

In_Hash 映射作用：pre 第一个节点为 root，根据第一个节点 val，在 In 中快速定位到 index。

:x: 看了题解第一遍没写对，注意传入参数为 pre 的起始以及 In 的起始，而非 left_start, right_start。

pre_start 作用：找到 root。In_start 作用：确定 root index，进一步确定 left_child_size 和 right_child_size

**知识点**

+ 前序遍历列表：第一个元素永远是 【根节点 (root)】
+ 中序遍历列表：根节点 (root)【左边】的所有元素都在根节点的【左分支】，【右边】的所有元素都在根节点的【右分支】
+ 做题时忽略了一个关键的知识点，确定了pre root，后面的节点都是其左子树，然后才是右子树，也就是说知道了 left_child_size，就能够确定 pre_end
+ 标签：数组，hash，分治，二叉树

##### JZ.09 用两个栈实现队列

自己的思路：stack_1 用来插入，需要删除时把 stack_1 全部倒入 stack_2，此时先进来的 element 在栈顶，出栈即可，再把 stack_2 中全部倒回 stack_1。操作上开销比较大。

更好的思路：其实不用再把 stack_2 中全部倒回 stack_1

**知识点**

+ 栈和队列；自带的 stack 和 queue 库使用的不多；创建栈和队列的关键字？`stack<int> stk; queue<int> q;`
+ 两个栈实现队列
+ 标签：栈，队列

##### JZ.10 斐波那契数列 DP

自己的思路：感觉是经典的递归教学，但是肯定有比递归更好的解法。用递归会超时，可以加一个 hash 表来优化。加了 hash 优化后 AC，题解中称之为记忆递归

更好的思路：这题可以用 DP，没有想到。

现成的状态转移方程 $f(n+1) = f(n) + f(n-1)$；

转移方程：$dp[i+1] = dp[i] + dp[i-1]$

初始状态：$dp[0] = 0; dp[1] = 1$

返回值：$dp[n]$

**知识点**

+ 查缺补漏：对迭代的概念不太熟悉；DP 的概念和思路
+ 标签：DP

##### JZ.11 青蛙跳台阶

自己的思路：hash 递归；DP

和上一题很类似，写的是优化空间后的 DP，

:heavy_check_mark: 要求自己写一个常规的 DP 加深理解

**知识点**

+ DP

##### JZ.11 旋转数组的最小数字 :x: 

> 这个题目肯定有复杂度要求的，小于线性复杂度，也就是要求 $O(logn)$；看题解做出来的

确实值得一道 hard。也是二分查找的思想，只是舍弃的区间有一定的变化。

**知识点**

+ 标签：二分查找，数组
+ 查缺补漏：二分查找熟练度不够

### 3.14

##### JZ.12 矩阵中的路径 :x:

自己的思路：递归查找可以解，但是复杂度为 $O(mn)$ ；确实是用 DFS递归查找，而题解的复杂度为 $O(3^kmn)$

题解 DFS，DFS 已经非常生疏了

看了题解后手写了一个性能比较差的 DFS，通过了 case。和题解的写法差不多，性能也是一个级别。

**知识点**

+ 典型的矩阵搜索问题

##### JZ.13 机器人运动范围

这个也是算法设计课程中出现的考试题目。

自己的思路：看起来暴力遍历可解，不过应该有复杂度要求；第一次做的时候没考虑到棋盘被截断的情况，如果有截断，那么一些满足条件的区域也是去不了的。

写错了一句 `tag[i][j] == -1;`，报错居然是 `stackoverflow`，要注意尽量一次写出 bug-free code。 

题解：差不多，也上题一样，也是 DFS/BFS，回溯算法，矩阵

**知识点**

+ 和上一题类似，也是矩阵，DFS还是可以用。
+ 标签：**DP**，BFS，DFS；DP 体现在哪？了解 DP 的解法

##### JZ.14-I 剪绳子 :x:

自己的思路：m 从 2 到 n/2 进行遍历，每次均分长度，求出最大的乘积，可以AC，$O(n^2)$

更好的思路：

**DP**

+ 求长度为 n 的绳子剪掉后的乘积，从 <n 的绳子转移而来
+ `dp数组` 记录 `0到n` 的绳子的最大乘积，初始化 `dp[2] = 1`
+ 剪掉第一段，长度为 j，j > 1
+ 剪了第一段，剩下长度为 `(i - j)` 可以剪或者不剪。不剪的话 `length = j * (i - j)`；剪了的话 `length = j * dp[i - j]`；`max(j * (i - j), j * dp[i - j])`
+ 遍历 j，$j \in [2, i)$，取最大值。

难道其实你已经用了 DP 思想？3.16 早上来给出答案。2022-03-15 23:27:16。

